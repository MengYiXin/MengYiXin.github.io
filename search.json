[{"title":"Linux的学习","url":"/2021/05/04/Linux/","content":"Linux学习： https://www.shiyanlou.com/courses/1 http://linuxcommand.org/tlcl.php http://www.imooc.com/read/39 https://fanzhongwei.com/linux/shadowsocks.html\n","tags":["Linux"]},{"title":"important-link","url":"/2021/11/07/important-link/","content":"link:\nVMware不同版本的对比：https://www.vmware.com/products/vsphere.htmlVMware iso lenovo OEM下载地址：https://vmware.lenovo.com/content/custom_iso/VMware版本KB：https://kb.vmware.com/s/article/2143838 （vcenter）https://kb.vmware.com/s/article/2143832（ESXi）VMware vcenter下载：需要vmware官网账号联想机型兼容性查询：https://lenovopress.com/osigVMware兼容性列表查询：http://partnerweb.vmware.com/comp_guide2/search.php?action=base&amp;deviceCategory=ioLenovo固件下载地址：https://datacentersupport.lenovo.com/cn/en/\n","tags":["VMware"]},{"title":"Python Day0","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day0%EF%BC%882021.2.23%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"今天玲姐带我们学习 Python，启动。\n讲明了学习的计划与方法，并且分享了相关的文件。\n建了微信群众，从此每天写点代码，进行 Python 学习。\n玲姐:1.gitlab 地址是 gitlab.vthink.cloud没有注册过的，先注册一下，注册完成后，我会拉到 SRE group，然后就可以下载代码了2. learning-python 库的地址是：http://gitlab.vthink.cloud/sre/learning-python.git  \n \nAnaconda:  https://www.anaconda.com/products/individual https://www.anaconda.com/products/individual \nPycharm:  https://www.jetbrains.com/pycharm/download/#section=windows https://www.jetbrains.com/pycharm/download/#section=windows\n配置好了编辑器与 Gitlab 仓库\n建立了 SRE group，用 git 提交代码。\n\n其实以前学过 Python，但是都是皮毛。这次趁着有人带，想好好学习一下。\n\n","tags":["Python"]},{"title":"Python Day1","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day1%EF%BC%882021.2.24%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"# 试试变量x &#x3D; 3print(x) 幸运数 &#x3D; 1997 print(幸运数) name &#x3D; &#39;yixin&#39;print(name) # 试试基本的数据类型# 整数（int) 浮点型（float） 字符串（str) 布尔值（bool) # 1, 空（NoneTypesome &#x3D; Noneprint(type(some)) # 2, 布尔型（bool)some &#x3D; Trueprint(type(some)) # 3,整形（int）some &#x3D; 12345print(type(some)) # 4,浮点型（float）some &#x3D; 12.345print(type(some)) # 字符串（str）some &#x3D; &#39;abc&#39;print(type(some)) print(type(8)) counter &#x3D; 100  # 整型变量miles &#x3D; 1000.0  # 浮点型变量name &#x3D; &quot;runoob&quot;  # 字符串 print(counter)print(miles)print(name)  x &#x3D; 3y &#x3D; 5x,y &#x3D; y,x print(x,y) # 字符串的特性# 1,Python中单引号和双引号使用完全相同m &#x3D; &#39;abc&#39;n &#x3D; &quot;abc&quot;q &#x3D; (m &#x3D;&#x3D; n)print(q) # 2,使用三引号 （&#39;&#39;&#39;或 &#39;&#39;&#39;）some &#x3D; &#39;&#39;&#39; abc def gbk lll&#39;&#39;&#39;print(some) # 3，转义符’\\‘some &#x3D; &#39;abc\\n def&#39;print(some) # 4,自然字符串，通过在字符串前加r或者R，可以忽略转义符some &#x3D; r&#39;abc\\n def&#39;print(some) # 5，python 允许处理unicode字符串，加前缀u或者U \n\n\n\n","tags":["Python"]},{"title":"K8S学习","url":"/2021/05/04/k8s-%E7%BA%AA%E6%B3%BD/","content":"以下是我个人对学习 k8s 的意见，很多资料都涉及网络（自行解决）和英文（google翻译）：\n\n仅以 k8s 官方文档作为参考手册，尽量不看中文博客（具有局限性和滞后性，多数都有错误）官方文档： https://kubernetes.io/docs/home/\n\n（初步了解它能做什么）先了解基本概念，然后动手实践\n  建议用官方的 tutorial 做实践内容：https://kubernetes.io/docs/tutorials/  建议用本地环境做实践环境，可以用 Minikube 或者 Kind, 我建议用kind：https://github.com/kubernetes-sigs/kind  建议把 https://www.katacoda.com/ 的实验做一遍\n\n进一步了解Kubernetes的架构、理念及组件\n  3.1 部署方案（下面都是针对on-premise方案，如果能用 cloud，建议优先考虑cloud）：   只建议用官方文档推荐的方案\n\n\nhttps://kubernetes.io/docs/setup/production-environment/\n多数情况下我都建议用 kubeadm 做部署         \n\n  如果有兴趣可以看 https://github.com/kelseyhightower/kubernetes-the-hard-way，可以深入理解 k8s 的组件及组件关系大规模部署交付建议考虑 kubespray\n 3.2 较为系统的了解 k8s 的 concepts、glossary，这些在官方文档中都有，建议自行查找（用于练习文档查阅能力，k8s的CKA认证就是开卷考试，所有内容都可以在官方文档中找到参考）\n\n 3.3 继续多做练习，比如官网的 tasks\n\n\n了解 K8S 的生态，包括 CRI、CNI、CSI、可观测性等，建议通过 CNCF 全景图找感兴趣的部分，具体情况可以找我沟通。 https://landscape.cncf.io/\n\n多看k8s 博客（https://kubernetes.io/blog/）及cncf博客（ https://www.cncf.io/blog/ ），都是大厂分享理念和实践\n\n\n","tags":["K8S"]},{"title":"Python Day2","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day2%EF%BC%882021.2.25%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"# 标准数据类型import math &quot;&quot;&quot;Number(数字)String(字符串)List(列表)Tuple(元组)Set(集合)Dictionary(字典)可变数据（3个）：List(列表)，Dictionary(字典)，Set(集合)代码风格整理： Ctrl + Alt +l&quot;&quot;&quot; a, b, c, d &#x3D; 20, 5.5, True, 4 + 3j print(type(a)), print(type(b)), print(type(c)), print(type(d))# # ------------------------------------------------------------------------## # 此外还可以用 isinstance 来判断：# a &#x3D; 111# isinstance(a, int)## # isinstance 和 type 的区别在于：# &#39;&#39;&#39;# type()不会认为子类是一种父类类型。# isinstance()会认为子类是一种父类类型。# &#39;&#39;&#39;### class A:#     pass### class B(A):#     pass### isinstance(A(), A)## type(A()) &#x3D;&#x3D; A## isinstance(B(), A)## type(B()) &#x3D;&#x3D; A# ------------------------------------------------------------------------# # 数值运算： 5 + 4  # 加法 4.3 - 2  # 减法\n\n\n\n","tags":["Python"]},{"title":"Python Day3","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day3%EF%BC%882021.2.26%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"# Python的数据结构有三种:列表、元组和字典  # 列表（list）# 初始化：[],[1,3,7],[&#39;a&#39;,&#39;c&#39;],[1,&#39;s&#39;,&#39;des&#39;,256]等# 1，增加：append(value),extend(list2),insert(i,value) mylist &#x3D; [1, 3, 7]mylist.append(&#39;a&#39;)mylist.insert(2, &#39;fff&#39;)print(mylist) newList &#x3D; [&#39;abc&#39;, &#39;kkk&#39;, 123]mylist.extend(newList)print(mylist) # 2,删除：pop([i]）,remove（value）# i 可以是负数# i 超出范围会报out of range错误# remove只会移除第一个遇到的值# pop 有返回值，remove没有 mylist &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]a &#x3D; mylist.pop()print(a)print(mylist)b &#x3D; mylist.pop(2)print(b)print(mylist)c &#x3D; mylist.pop(-1)print(c)print(mylist)newList &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]k &#x3D; newList.remove(&#39;b&#39;)print(k)print(newList) # 3.查询:index(value, [start, [stop]])　　# ---返回列表中第一个出现的值为value的索引，如果没有，则异常 ValueError mylist &#x3D; [1, 2, 5]a &#x3D; mylist.index(2)print(a)&#39;b &#x3D; mylist.index(3)  # 此处会报错，返回以下信息&#39; # Traceback (most recent call last):#   File &quot;C:&#x2F;Users&#x2F;mengyx3&#x2F;Desktop&#x2F;Python learning&#x2F;learning-python&#x2F;mengyixin&#x2F;day3.py&quot;, line 44, in &lt;module&gt;#     b &#x3D; mylist.index(3)# ValueError: 3 is not in list &quot;&quot;&quot;4.修改:list没有直接修改对应元素的方法，   只能先找到目标元素所在位置，然后直接赋值&quot;&quot;&quot; mylist &#x3D; [&#39;a&#39;, &#39;k&#39;, &#39;m&#39;]myIndex &#x3D; mylist.index(&#39;k&#39;)mylist[myIndex] &#x3D; &#39;fff&#39;print(mylist) # 5.排序:sort() mylist &#x3D; [6, 23, 7, 39, 1, 90]mylist.sort()print(mylist) # 6.反转：reverse() mylist &#x3D; [&#39;f&#39;, &#39;m&#39;, &#39;a&#39;, &#39;z&#39;]mylist.reverse()print(mylist) # 清空：clear() mylist &#x3D; [1, 2, 4]mylist.clear()print(mylist) \n\n\n","tags":["Python"]},{"title":"Python Day5","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day5%EF%BC%882021.3.2%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"集合\nbasket &#x3D; &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;print(basket)  # 这里演示的是去重功能&#123;&#39;orange&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;&#125;&#39;orange&#39; in basket  # 快速判断元素是否在集合内True&#39;crabgrass&#39; in basketFalse # 下面展示两个集合间的运算. a &#x3D; set(&#39;abracadabra&#39;)b &#x3D; set(&#39;alacazam&#39;)a&#123;&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125;a - b  # 集合a中包含而集合b中不包含的元素&#123;&#39;r&#39;, &#39;d&#39;, &#39;b&#39;&#125;a | b  # 集合a或b中包含的所有元素&#123;&#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;&#125;a &amp; b  # 集合a和b中都包含了的元素&#123;&#39;a&#39;, &#39;c&#39;&#125;a ^ b  # 不同时包含于a和b的元素&#123;&#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;&#125;","tags":["Python"]},{"title":"Python Day4","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day4%EF%BC%882021.3.1%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"# 字典（dict）# 　定义:键值对集合## 　　初始化:&#123;&#125;, &#123;&#39;1&#39; : &#39;abc&#39;, &#39;2&#39; : &#39;def&#39;&#125;## 　　1.增加:单个数据直接赋值 #    update(dict2)　　---把dict2的元素加入到dict中去，键字重复时会覆盖dict中的键值 myd &#x3D; &#123;&#125; myd[&#39;1&#39;] &#x3D; &#39;one&#39; print(myd) myd1 &#x3D; &#123;1: &#39;one&#39;, 2: &#39;two&#39;&#125;myd2 &#x3D; &#123;1: &#39;one&#39;, 3: &#39;three&#39;&#125;myd1.update(myd2)print(myd1) #     2,删除:pop(key, [default])　　---若字典中key键存在，删除并返回dict[key]，若不存在，且未给出default值，引发KeyError异常## 　　　　　popitem()　　---删除任意键值对，并返回该键值对，如果字典为空，则产生异常KeyError## 　　　　　clear()  ---略 myd &#x3D; &#123;1: &quot;one&quot;, 2: &quot;two&quot;, 3: &quot;there&quot;&#125;item &#x3D; myd.pop(1)print(item)print(myd)newItem &#x3D; myd.popitem()print(newItem) print(myd) #     3,查询：get(key,[default])　　---返回字典dict中键key对应值，如果字典中不存在此键，则返回default 的值(default默认值为None)## 　　　　　　items()　　---返回一个包含字典中(键, 值)对元组的列表## 　　　　　　keys()　　---返回一个包含字典中所有键的列表## 　　　　　　values()　　---返回一个包含字典中所有值的列表#myd &#x3D; &#123;1: &quot;one&quot;, 2: &quot;two&quot;, 3: &quot;there&quot;&#125;print(myd.get(2)) print(myd.items()) print(myd.keys())print(myd.values())\n\n\n","tags":["Python"]},{"title":"Python Day6","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day6%EF%BC%882021.3.3%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"函数\n# 函数# 函数是可重复调用的代码段，能提高代码的复用率。 # 无参数def print_hello():    print (&quot;hello&quot;)  print_hello()  # 带参数def print_str(s):    print(s)    return s * 2  print_str(&quot;fuck&quot;)  # 带默认参数def print_default(s&#x3D;&quot;hello&quot;):    print(s)  print_default()print_default(&quot;default&quot;)  # 不定长参数def print_args(s, *arg):    print(s)    for a in arg:        print(a)    return  print_args(&quot;hello&quot;)print_args(&quot;hello&quot;, &quot;world&quot;, &quot;1&quot;)  # 参数次序可以变def print_two(a, b):    print(a, b)  print_two(a&#x3D;&quot;a&quot;, b&#x3D;&quot;b&quot;)print_two(b&#x3D;&quot;b&quot;, a&#x3D;&quot;a&quot;)","tags":["Python"]},{"title":"Python Day7","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day7%EF%BC%882021.3.4%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"集合# 模块# 通常来说，比较正规的工程不会把所有代码放在一个py文件里，我们会把代码拆成各个模块，分别调用。对python来说，拆成各个模块可以看做拆成各个py文件。  # 搜索路径# 通常来说，同文件夹下的py文件可以直接import。 def print_hello():    print(&quot;hello&quot;)  # 我们把这个保存至hello.pyimport hello hello.print_hello() # 在run.py里import，然后调用print_hello() 目录结构# .....&#x2F; hello.pyrun.py # hello.py和run.py在同一目录下，可以直接import 如果在不同路径下，可以在sys.path里手动加入你想import的路径 import sys sys.path.append(&#39;&#x2F;home&#x2F;yixin&#x2F;course&#39;)import hello hello.print_hello()# 如果run.py不在&#x2F;home&#x2F;yixin&#x2F;course文件夹下，手动加入这个路径，就可以import这个路径下的hello.py # ----------------------------------------------------------------------------------------------------# 通常一个工程不可能只有一层目录结构，并且也不会一个一个path去append到sys里，常用的做法是包，一个目录及其子目录组成的一个包（可以看做一个库）。 举个例子#&quot;&quot;&quot;&#x2F;home&#x2F;yixin&#x2F;course├── __init__.py├── __init__.pyc├── m1│   ├── b.py│   ├── b.pyc│   ├── __init__.py│   ├── __init__.pyc│   └── m1_1│       ├── a.py│       ├── a.pyc│       ├── __init__.py│       └── __init__.pyc└── m2    ├── __init__.py    └── run.py&quot;&quot;&quot;","tags":["Python"]},{"title":"Python学习资料","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"https://edu.csdn.net/course/detail/25411\n复制粘贴在浏览器打开\n好几个小节，目录可选\nhttps://blog.csdn.net/weixin_44888486/article/details/102902402\n上面针对 Python 基础的内容总结\n包含环境的搭建及安装步骤\n环境安装：\npython 及 pycharm 安装包，已经上传了\n根据自己的电脑系统选择下载就好了哈\n链接: https://pan.baidu.com/s/1tYITGogujLZxm3C-W8SlzQ\n提取码: n2p2\nhttps://pan.baidu.com/s/1G9-2Tv8wSbsikTvs7QzGcg     Mac\nPython 的安装：https://blog.csdn.net/weixin_43495473/article/details/103559812\nPycharm 的安装：https://blog.csdn.net/weixin_43495473/article/details/103560198\n网盘里是安装包，下面是安装步骤\nPython 零基础入门\n从游戏开始的 “0 基础 Python 学习之路”【5-27】\n观看链接：https://live.csdn.net/room/CSDNedu/NgQZAWBq\nPython 爬虫\nPython 分布式爬虫 + 数据分析实战【5-26】\n观看链接：https://live.csdn.net/room/CSDNedu/YceylATu\nPython 自动化\nPython 自动化办公【6-17】\n观看链接：https://live.csdn.net/room/CSDNedu/w7Ifsyx5\nPython 数据分析\nPython 量化分析预测股灾拐点【6-5】\n观看链接：https://live.csdn.net/room/CSDNedu/VNqpTJ0d\n数据分析师必备的的软硬技能【6-16】\n观看链接：https://live.csdn.net/room/CSDNedu/Vc9QDqAH\n提升 Python 数据处理速度四种方式【6-23】\n观看链接：https://live.csdn.net/room/CSDNedu/TN5hZHwn\n从数据专员到行业 “叫兽”，必备经历【6-12】\n观看链接：https://live.csdn.net/room/CSDNedu/fZUy43xw\n用 40 行 Python 代码实现抖音 AI 换脸【5-29】\n观看链接：https://live.csdn.net/room/CSDNedu/A9jwFMBm\n用 2 个小时写一个 CSDN【6-10】\n观看链接：https://live.csdn.net/room/CSDNedu/BrqBSfMn\n0 基础快速上手推荐系统【6-22】\n观看链接：https://live.csdn.net/room/CSDNedu/5BDkcYfI\n实战：CSDN 站内搜索技术关键词\n观看链接：https://live.csdn.net/room/CSDNedu/rq27wEHR\n文档资料链接:\n https://pan.baidu.com/s/1HtKPV44xsTAq0L69GqkVzA\n提取码: jhpv\n","tags":["Python"]},{"title":"VMWare Esxi 的安装","url":"/2021/05/02/simpread-VMware-ESXi%20%E7%9A%84%E5%AE%89%E8%A3%85_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"密码账号:USERID/PASSW0RD密码的 0 是数字零\n\n\n  选择 ESXI 的镜像，挂载成功。\n\n\n然后重新启动，选择驱动引导：\n在合适的时候按 F1，出现如下界面\n\n按空格选择设置 IP。之后就可以访问了。\n","tags":["VMware"]},{"title":"VMWare vCenter Server 的安装","url":"/2021/05/02/simpread-VMWare%20vCenter%20Server%20%E7%9A%84%E5%AE%89%E8%A3%85_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"从 ESXI 中，删除 Vcenter 虚拟机本身，然后全部进行重装一遍。熟悉流程2020/7/22\n具体虚拟机进入操作系统的密码\n\n","tags":["VMware"]},{"title":"VMWare VSAN 的安装","url":"/2021/05/02/simpread-VSAN%20%E7%9A%84%E5%AE%89%E8%A3%85_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"\n本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net\n\n将 VCenter 安装在任何一台主机上（192.168.30.2，192.168.30.3，192.168.30.4）这周（7 月 28 号）教我了 VSAN 的知识，交我一个任务作业。他给我了 3 个 XCC 地址，有 3 台装了 ESXI 的主机，让我装 VSAN。跟以往不同的地方是，这次让我把 Vcenter 装在这三台主机中的其一，主机里边。以往都是装在主机外的，用来管理主机。就遇到这个问题。\n2020 年 0802\n刚开始找不到 VSAN，6.5 有 html5 和 flash 两种访问方式，html5 在 6.5 中功能不全。\n\n","tags":["VMware"]},{"title":"Vim","url":"/2021/05/02/simpread-Vim_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"按 [i] 键可以进入到编辑状态，显示 insert 字眼 OK。\n直接按 esc 退出编辑状态，然后输入 ：wq !  保存退出\n：wq ！ 保存后退出\n：w        表示保存不退出\n：q !      表示退出不 保存 \n： ！      表示强制退出忙，或者按 ctrl + z 强制退出也可！\n","tags":["Linux"]},{"title":"Windows 内核和 Linux 内核谁更复杂","url":"/2021/05/04/simpread-Windows%20%E5%86%85%E6%A0%B8%E5%92%8C%20Linux%20%E5%86%85%E6%A0%B8%E8%B0%81%E6%9B%B4%E5%A4%8D%E6%9D%82_/","content":"两个系统的内核结构不一样，没什么可比性，都有各自的优势。\nLinux 内核和 Windows 内核有什么区别？\n内核什么是内核呢？\n计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，如果每个应用都要和这些硬件设备对接通信协议，那这样太累了，所以这个中间人就由内核来负责，让内核作为应用连接硬件设备的桥梁，应用程序只需关心与内核交互，不用关心硬件的细节。\n\n内核有哪些能力呢？\n现代操作系统，内核一般会提供 4 个基本能力：\n\n  管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；\n  管理内存，决定内存的分配和回收，也就是内存管理的能力；\n  管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；\n  提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。\n\n内核是怎么工作的？\n内核具有很高的权限，可以控制 cpu、内存、硬盘等硬件，而应用程序具有的权限很小，因此大多数操作系统，把内存分成了两个区域：\n\n  内核空间，这个内存空间只有内核程序可以访问；\n  用户空间，这个内存空间专门给应用程序使用；\n\n用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在用户态执行，而当程序使内核空间时，程序则在内核态执行。\n应用程序如果需要进入内核空间，就需要通过系统调用，下面来看看系统调用的过程：\n\n内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。\nLinux 的设计Linux 的开山始祖是来自一位名叫 Linus Torvalds 的芬兰小伙子，他在 1991 年用 C 语言写出了第一版的 Linux 操作系统，那年他 22 岁。\n完成第一版 Linux 后，Linux Torvalds 就在网络上发布了 Linux 内核的源代码，每个人都可以免费下载和使用。\nLinux 内核设计的理念主要有这几个点：\n\n  _MutiTask_，多任务\n  _SMP_，对称多处理\n  _ELF_，可执行文件链接格式\n  _Monolithic Kernel_，宏内核\n\nMutiTaskMutiTask 的意思是多任务，代表着 Linux 是一个多任务的操作系统。\n多任务意味着可以有多个任务同时执行，这里的「同时」可以是并发或并行：\n\n  对于单核 CPU 时，可以让每个任务执行一小段时间，时间到就切换另外一个任务，从宏观角度看，一段时间内执行了多个任务，这被称为并发。\n  对于多核 CPU 时，多个任务可以同时被不同核心的 CPU 同时执行，这被称为并行。\n\nSMPSMP 的意思是对称多处理，代表着每个 CPU 的地位是相等的，对资源的使用权限也是相同的，多个 CPU 共享同一个内存，每个 CPU 都可以访问完整的内存和硬件资源。\n这个特点决定了 Linux 操作系统不会有某个 CPU 单独服务应用程序或内核程序，而是每个程序都可以被分配到任意一个 CPU 上被执行。\nELFELF 的意思是可执行文件链接格式，它是 Linux 操作系统中可执行文件的存储格式，你可以从下图看到它的结构：\n\nELF 把文件分成了一个个分段，每一个段都有自己的作用，具体每个段的作用这里我就不详细说明了，感兴趣的同学可以去看《程序员的自我修养——链接、装载和库》这本书。\n另外，ELF 文件有两种索引，Program header table 中记录了「运行时」所需的段，而 Section header table 记录了二进制文件中各个「段的首地址」。\n那 ELF 文件怎么生成的呢？\n我们编写的代码，首先通过「编译器」编译成汇编代码，接着通过「汇编器」变成目标代码，也就是目标文件，最后通过「链接器」把多个目标文件以及调用的各种函数库链接起来，形成一个可执行文件，也就是 ELF 文件。\n那 ELF 文件是怎么被执行的呢？\n执行 ELF 文件的时候，会通过「装载器」把 ELF 文件装载到内存里，CPU 读取内存中的指令和数据，于是程序就被执行起来了。\nMonolithic KernelMonolithic Kernel 的意思是宏内核，Linux 内核架构就是宏内核，意味着 Linux 的内核是一个完整的可执行程序，且拥有最高的权限。\n宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。\n不过，Linux 也实现了动态加载内核模块的功能，例如大部分设备驱动是以可加载模块的形式存在的，与内核其他模块解藕，让驱动开发和驱动加载更为方便、灵活。\n\n与宏内核相反的是微内核，微内核架构的内核只保留最基本的能力，比如进程调度、虚拟机内存、中断等，把一些应用放到了用户空间，比如驱动程序、文件系统等。这样服务与服务之间是隔离的，单个服务出现故障或者完全攻击，也不会导致整个操作系统挂掉，提高了操作系统的稳定性和可靠性。\n微内核内核功能少，可移植性高，相比宏内核有一点不好的地方在于，由于驱动程序不在内核中，而且驱动程序一般会频繁调用底层能力的，于是驱动和硬件设备交互就需要频繁切换到内核态，这样会带来性能损耗。华为的鸿蒙操作系统的内核架构就是微内核。\n还有一种内核叫混合类型内核，它的架构有点像微内核，内核里面会有一个最小版本的内核，然后其他模块会在这个基础上搭建，然后实现的时候会跟宏内核类似，也就是把整个内核做成一个完整的程序，大部分服务都在内核中，这就像是宏内核的方式包裹着一个微内核。\nWindows 设计当今 Windows 7、Windows 10 使用的内核叫 Windows NT，NT 全称叫 New Technology。\n下图是 Windows NT 的结构图片：\n\nWindows 和 Linux 一样，同样支持 MutiTask 和 SMP，但不同的是，Window 的内核设计是混合型内核，在上图你可以看到内核中有一个 MicroKernel 模块，这个就是最小版本的内核，而整个内核实现是一个完整的程序，含有非常多模块。\nWindows 的可执行文件的格式与 Linux 也不同，所以这两个系统的可执行文件是不可以在对方上运行的。\nWindows 的可执行文件格式叫 PE，称为可移植执行文件，扩展名通常是.exe、.dll、.sys等。\nPE 的结构你可以从下图中看到，它与 ELF 结构有一点相似。\n\n总结对于内核的架构一般有这三种类型：\n\n  宏内核，包含多个模块，整个内核像一个完整的程序；\n  微内核，有一个最小版本的内核，一些模块和服务则由用户态管理；\n  混合内核，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；\n\nLinux 的内核设计是采用了宏内核，Window 的内核设计则是采用了混合内核。\n这两个操作系统的可执行文件格式也不一样， Linux 可执行文件格式叫作 ELF，Windows 可执行文件格式叫作 PE。\n参考资料\n\n https://en.wikipedia.org/wiki/Monolithic_kernel\n https://en.wikipedia.org/wiki/Executable_and_Linkable_Format\n https://en.wikipedia.org/wiki/Windows_NT\n\n","tags":["Linux"]},{"title":"VSAN6.7 的安装","url":"/2021/05/02/simpread-VSAN6.7%20%E7%9A%84%E5%AE%89%E8%A3%85_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"\n图 1\n\n 图 2\n 图 3\n 图 4\n 图 5\n 图 6\n 图 7\n 图 8\n 图 9\n 图 10\n 图 11\n 图 12\n 图 13\n 图 14\n 图 15\n\n选择要安装在哪个主机上。\n\n 图 16\n 图 17\n\n注意，可以选择安装在包含目标主机的新 VSAN 群集上\n\n 图 18\n 图 19\n\n这是因为，因为之前的磁盘上面已经有 VSAN 的信息了，得去 ESXI 后台把这些磁盘的分区删了\n\n 图 20\n\n点击了按照容量降序\n\n 图 21\n\n从上面往下面弄，右键删除磁盘分区，下面三个不用管就行了。只弄上边 8 个，也就是 6 个 HDD 和 2 个 960g 的 SSD.\n\n 图 22\n 图 23\n\n其他两台也要这么做一下。像这种就是需要删除的。\n\n 图 24\n\n擦除后是这个样子的。\n\n 图 25\n\n 然后重新进入 Vcenter 安装第 8 步，发现有磁盘可选。\n\n 图 26\n\n检查一下，是不是八块硬盘。这里只会显示 30.11 这台机器（Vcenter 是装在 192.168.30.11 的）\n\n 图 27\n 图 28\n\n这个时候注意，需要设置一下 VM network VLAN ，在 30.11（装 VC 的主机）主机的后台，\n\n​\n图 29\n 图 30\n\n其他地方不用管，刷新一下就 OK。\n\n 图 31\n 图 32\n 图 33\n 图 34\n 图 35\n 图 36\n 图 37\n 图 38\n 图 39\n\n完了就会发现浏览器里边没有 “不安全” 的字样了。\n\n 图 40\n\n目前准备把其他的主机也加载进来。\n\n 图 41\n\n加完三台主机后发现一点问题，30.11 机器报错。其他 VSAN 网络不可用。\n\n 图 42\n","tags":["VMware"]},{"title":"go语言学习","url":"/2021/05/02/simpread-go%20%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"第二天这里加了命令行参数，他是以输出的形式输出了命令行参数。\n[C:\\Users\\mengyx3\\AppData\\Local\\Temp\\go-build833694214\\b001\\exe\\hello_world.exe 是二进制的命令， chao 是命令行参数了。\n\npackage mainimport (   “fmt”   “os”)func main() {   fmt.Println(os.Args)   fmt.Println(“Hello World”)   os.Exit(-1)}\n运行程序，我们看到命令行参数被放在了 hello world 的后面。\n编写测试程序\n\n 源码文件以_test 结尾：xxx_test . go\n 测试方法名以 Test 开头：func TestXXX(t *testing.T) {…}\n\n斐波那契数列\n也可以改写成\n还可以改写成\n刚刚都是用的 fmt.Print 来输出的，其实在单元测试可以用 t.Log 来输出。\nGo 语言里交换变量的值写法简洁，可以在一句赋值语句里边 对多个变量进行赋值。\n位运算\n位运算结果这里，应该是三个 true , 也就是 true true true 。而不是 true false true ?\n当前播放：05 | 变量，常量以及与其他语言的差异\n刚刚上面是 a:=7 0111     我们换成 a:=1 0001\n第三天\n 数据类型和指针，不支持隐性的数据类型转换。需要显性数据类型转换。\n\n Go 语言可以支持指针类型，但是不支持指针运算。\n\n Go 的字符串是值类型，默认初始化零值是空字符串，而不是空。\n\n\n第四天用 == 比较数组\n\n 相同维数且含有相同个数元素的数组才可以比较\n\n 每个元素都相同才相等。\n\n 按位置零\n\n\n第五天\n 条件和循环\n\n","tags":["golang"]},{"title":"交付技能培养过程","url":"/2021/05/02/simpread-%E4%BA%A4%E4%BB%98%E6%8A%80%E8%83%BD%E5%9F%B9%E5%85%BB%E8%BF%87%E7%A8%8B_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"交付技能培养过程从 2020 年 6 月正式入职联想，刚开始在 PS 东区交付组，方向为专家服务。后面换了方向。记录一下前辈对于我，在专家服务方向的培养历程。\n2020/7/7 讲解虚拟化的整体架构，如何安装虚拟机。进行测试环境的虚拟机安装实验。\n2020/7/14 回顾虚拟化整体架构，虚拟化网络架构巩固，讲解 / 实操 ESXi 安装，vcenter 安装（手册学习）\n2020/7/21 回顾 VMware ESXi/vCenter 安装步骤，虚拟化网络架构。\n2020/7/22 进行 VMware 集群配置讲解 –HA/DRS/EVC / 标准交换机 / 分布式交换机 / SSO 设置 / License 设置 / NTP 配置 / vCenter 系统管理。\n2020/7/28 回顾 VMware 网络架构，集群配置。\n2020/7/29 讲解 vSAN 原理和部署过程，布置作业，整体部署一套 VMware 环境。\n2020/8/11 回顾整个 VMware 的内容。\n2020/8/13 讲解微软 AD 的架构，包括 domain controller，DNS，DHCP。\n","tags":["学习"]},{"title":"从0开始装VSAN","url":"/2021/05/02/simpread-%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85%20VSAN%20%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2_vsan%20%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","content":"\n请务必格式化好全部的硬盘，否则可能会出现配置好了但是不能使用的问题。  \n安装 VCSA 可能会卡 80% 参考网上解决。（有可能实际上是等待不够久，并不会出现进度条不会动的情况）  \n注意好安装环境的物理网络情况，确保过程中的通信。  \nEVC 开启的话选择最新的 CPU 微架构\n\nPartition1 - install ESXi进入 xcc 选择 ESXi 镜像，挂载，重启。根据 installer 提示完成 ESXi 安装（在本次实验环境下\nPartition2 - deploy VCSA onto new vSAN cluster打开安装镜像，选择对应的安装程序，在选择 datastore 的时候选择安装在一个新的 vSAN 群集里，剩下的按照需求配置好\nParition3 - 修理剩下的错误\n\n  将其余的 vSAN 主机添加到群集中。\n  在每个主机上配置专用的 vSAN vmkernel。\n  将磁盘从其他主机添加到 vSAN 磁盘组。\n  一切正常运行后，确保运行了 vSAN Health Check，并且不要忽略任何错误！\n\nUPGRADING TO VCENTER 7.0 VIA CLI将 vSAN 群集从一个 vCenter Server 移至另一个 vCenter Server (2151610)\n如果 vCenter Server 虚拟机属于同一群集，如何启用 EVC（1013111）\n","tags":["VMware"]},{"title":"优秀科学论文","url":"/2021/05/02/simpread-%E4%BC%98%E7%A7%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%96%87%E7%AB%A0%E6%B1%87%E9%9B%86_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"看到几篇不错的文章。这里做一个记录。\n\n 云计算简史（完整版）\n 图解：网络硬件的发展史\n 为 Navicat 正名，Navicat 完全使用手册（下）\n\n","tags":["论文"]},{"title":"TCP_IP，必知必会10问","url":"/2021/11/16/simpread-%E5%85%B3%E4%BA%8E%20TCP_IP%EF%BC%8C%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%2010%20%E4%B8%AA%E9%97%AE%E9%A2%98/","content":"\n本文整理了一些 TCP/IP 协议簇中需要必知必会的十大问题，既是面试高频问题，又是程序员必备基础素养。\n\n\n一、TCP/IP 模型TCP/IP 协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是 Internet 的核心协议。\n基于 TCP/IP 的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示 TCP/IP 模型与 OSI 模型各层的对照关系。\n\nTCP/IP 协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有 http，ftp, 等等我们熟悉的协议。而第二层则是传输层，著名的 TCP 和 UDP 协议就在这个层次。第三层是网络层，IP 协议就在这里，它负责对数据加上 IP 地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行 CRC 编码，为最后的数据传输做准备。\n\n上图清楚地表示了 TCP/IP 协议中每个层的作用，而 TCP/IP 协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。\n\n上图以 HTTP 协议为例，具体说明。\n二、数据链路层物理层负责 0、1 比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将 0、1 序列划分为数据帧从一个节点传输到临近的另一个节点, 这些节点是通过 MAC 来唯一标识的 (MAC, 物理地址，一个主机会有一个 MAC 地址)。  \n\n\n  封装成帧: 把网络层数据报加头和尾，封装成帧, 帧头中包括源 MAC 地址和目的 MAC 地址。\n  透明传输: 零比特填充、转义字符。\n  可靠传输: 在出错率很低的链路上很少用，但是无线链路 WLAN 会保证可靠传输。\n  差错检测 (CRC): 接收者检测错误, 如果发现差错，丢弃该帧。\n\n三、网络层1. IP 协议\nIP 协议是 TCP/IP 协议的核心，所有的 TCP，UDP，IMCP，IGMP 的数据都以 IP 数据格式传输。要注意的是，IP 不是可靠的协议，这是说，IP 协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP 或 UDP 要做的事情。\n1.1 IP 地址\n在数据链路层中我们一般通过 MAC 地址来识别不同的节点，而在 IP 层我们也要有一个类似的地址标识，这就是 IP 地址。\n32 位 IP 地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。\nA 类 IP 地址: 0.0.0.0127.0.0.0B 类 IP 地址: 128.0.0.1191.255.0.0C 类 IP 地址: 192.168.0.0~239.255.255.0\n1.2 IP 协议头\n\n这里只介绍: 八位的 TTL 字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个 IP 数据包每穿过一个路由器，该数据包的 TTL 数值就会减少 1，当该数据包的 TTL 成为零，它就会被自动抛弃。\n这个字段的最大值也就是 255，也就是说一个协议包也就在路由器里面穿行 255 次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是 32 或者是 64。\n2. ARP 及 RARP 协议\nARP 是根据 IP 地址获取 MAC 地址的一种协议。\nARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个 IP 对应的是哪个主机的哪个接口，当主机要发送一个 IP 包的时候，会首先查一下自己的 ARP 高速缓存（就是一个 IP-MAC 地址对应表缓存）。\n如果查询的 IP－MAC 值对不存在，那么主机就向网络发送一个 ARP 协议广播包，这个广播包里面就有待查询的 IP 地址，而直接收到这份广播的包的所有主机都会查询自己的 IP 地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的 MAC 地址的 ARP 包传送给发送 ARP 广播的主机。\n而广播主机拿到 ARP 包后会更新自己的 ARP 缓存（就是存放 IP-MAC 对应表的地方）。发送广播的主机就会用新的 ARP 缓存数据准备好数据链路层的的数据包发送工作。\nRARP 协议的工作与此相反，不做赘述。\n3. ICMP 协议\nIP 协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是 ICMP(网络控制报文) 协议。ICMP 不是高层协议，而是 IP 层的协议。\n当传送 IP 数据包发生错误。比如主机不可达，路由不可达等等，ICMP 协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在 IP 层以上的协议是可能做到安全的原因。\n四、pingping 可以说是 ICMP 的最著名的应用，是 TCP/IP 协议的一部分。利用 “ping” 命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。\n例如：当我们某一个网站上不去的时候。通常会 ping 一下这个网站。ping 会回显出一些有用的信息。一般的信息如下:\n\nping 这个单词源自声纳定位，而这个程序的作用也确实如此，它利用 ICMP 协议包来侦测另一个主机是否可达。原理是用类型码为 0 的 ICMP 发请 求，受到请求的主机则用类型码为 8 的 ICMP 回应。\nping 程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping 给出来了传送的时间和 TTL 的数据。\n五、TracerouteTraceroute 是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。\nTraceroute 的原理是非常非常的有意思，它收到到目的主机的 IP 后，首先给目的主机发送一个 TTL=1 的 UDP 数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减 1，而 TTL 变为 0 以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。主机收到这个数据报以后再发一个 TTL=2 的 UDP 数据报给目的主机，然后刺激第二个路由器给主机发 ICMP 数据 报。如此往复直到到达目的主机。这样，traceroute 就拿到了所有的路由器 IP。\n\n六、TCP/UDPTCP/UDP 都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。\n\n面向报文\n面向报文的传输方式是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则 IP 层需要分片，降低效率。若太短，会是 IP 太小。\n面向字节流\n面向字节流的话，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。\n关于拥塞控制，流量控制，是 TCP 的重点，后面讲解。\nTCP 和 UDP 协议的一些应用\n\n什么时候应该使用 TCP？\n当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。\n什么时候应该使用 UDP？\n当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。\n七、DNSDNS（Domain Name System，域名系统），因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。通过主机名，最终得到该主机名对应的 IP 地址的过程叫做域名解析（或主机名解析）。DNS 协议运行在 UDP 协议之上，使用端口号 53。\n八、TCP 连接的建立与终止1. 三次握手\nTCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。\n\n第一次握手： 建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务器的确认；\n第二次握手： 服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number+1)；同时，自己自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态；\n第三次握手： 客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。\n为什么要三次握手？\n为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\n具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”\n2. 四次挥手\n当客户端和服务器通过三次握手建立了 TCP 连接以后，当数据传送完毕，肯定是要断开 TCP 连接的啊。那对于 TCP 的断开连接，这里就有了神秘的 “四次分手”。\n\n第一次分手： 主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；\n第二次分手： 主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我 “同意” 你的关闭请求；\n第三次分手： 主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；\n第四次分手： 主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。\n为什么要四次分手？\nTCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机 1 发出 FIN 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2，它的数据已经全部发送完毕了；但是，这个时候主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 ACK 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 FIN 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。\n为什么要等待 2MSL？\nMSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。\n原因有二：\n\n  保证 TCP 协议的全双工连接能够可靠关闭\n  保证这次连接的重复数据段从网络中消失\n\n第一点：如果主机 1 直接 CLOSED 了，那么由于 IP 协议的不可靠性或者是其它网络原因，导致主机 2 没有收到主机 1 最后回复的 ACK。那么主机 2 就会在超时之后继续发送 FIN，此时由于主机 1 已经 CLOSED 了，就找不到与重发的 FIN 对应的连接。所以，主机 1 不是直接进入 CLOSED，而是要保持 TIME_WAIT，当再次收到 FIN 的时候，能够保证对方收到 ACK，最后正确的关闭连接。\n第二点：如果主机 1 直接 CLOSED，然后又再向主机 2 发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机 2，由于新连接和老连接的端口号是一样的，TCP 协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以 TCP 连接还要在 TIME_WAIT 状态等待 2 倍 MSL，这样可以保证本次连接的所有数据都从网络中消失。\n九、TCP 流量控制如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。\n利用滑动窗口机制可以很方便地在 TCP 连接上实现对发送方的流量控制。\n设 A 向 B 发送数据。在连接建立时，B 告诉了 A：“我的接收窗口是 rwnd = 400”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP 的窗口单位是字节，不是报文段。假设每一个报文段为 100 字节长，而数据报文段序号的初始值设为 1。大写 ACK 表示首部中的确认位 ACK，小写 ack 表示确认字段的值 ack。\n\n从图中可以看出，B 进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机 B 重新发出一个新的窗口值为止。B 向 A 发送的三个报文段都设置了 ACK = 1 ，只有在 ACK=1 时确认号字段才有意义。\nTCP 为每一个连接设有一个持续计时器 (persistence timer)。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携 1 字节的数据），那么收到这个报文段的一方就重新设置持续计时器。\n十、TCP 拥塞控制1. 慢开始和拥塞避免\n发送方维持一个拥塞窗口 cwnd (congestion window) 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。\n发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。\n慢开始算法：\n当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。\n因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。\n通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个 MSS 的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。\n\n每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间 RTT。不过 “传输轮次” 更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。\n另，慢开始的 “慢” 并不是指 cwnd 的增长速率慢，而是指在 TCP 开始发送报文段时先设置 cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大 cwnd。\n为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量。慢开始门限 ssthresh 的用法如下：\n\n  当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。\n  当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。\n  当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。\n\n拥塞避免\n让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍。这样拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。\n\n无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送 方窗口值的一半（但不能小于 2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。\n这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。\n如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。\n\n2. 快重传和快恢复\n快重传\n快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。\n\n接收方收到了 M1 和 M2 后都分别发出了确认。现在假定接收方没有收到 M3 但接着收到了 M4。\n显然，接收方不能确认 M4，因为 M4 是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对 M2 的确认。\n但按照快重传算法的规定，接收方应及时发送对 M2 的重复确认，这样做可以让 发送方及早知道报文段 M3 没有到达接收方。发送方接着发送了 M5 和 M6。接收方收到这两个报文后，也还要再次发出对 M2 的重复确认。这样，发送方共收到了 接收方的四个对 M2 的确认，其中后三个都是重复确认。\n快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段 M3，而不必 继续等待 M3 设置的重传计时器到期。\n由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约 20%。\n快恢复\n与快重传配合使用的还有快恢复算法，其过程有以下两个要点：\n\n  当发送方连续收到三个重复确认，就执行 “乘法减小” 算法，把慢开始门限 ssthresh 减半。\n  与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口 cwnd 现在不设置为 1），而是把 cwnd 值设置为 慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。\n\n\n","tags":["计算机网络"]},{"title":"交换机二三层转发原理","url":"/2021/11/16/simpread-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%BA%8C%E4%B8%89%E5%B1%82%E8%BD%AC%E5%8F%91%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"二层转发原理交换机有多个网络端口，它通过识别数据帧的目标 MAC 地址，根据 MAC 地址表决定从哪个端口发送数据。MAC 地址表不需要在交换机上手工设置，而是可以自动生成的。\n交换机是如何添加、更新、删除 MAC 地址表条目的？  \n在初始状态下，交换机的 MAC 地址表是空的，不包含任何条目。当交换机的某个端口接收到一个数据帧时，它就会将这个数据帧的源 MAC 地址、接收数据帧的端口号作为一个条目保存在自己的 MAC 地址表中，同时在接收到这个数据帧时重置这个条目的老化计时器时间。这就是交换机自动添加 MAC 地址表条目的方式。\n\n在新增这一条 MAC 地址条目后，如果交换机再次从同一个端口收到相同 MAC 地址为源 MAC 地址的数据帧时，交换机就会更新这个条目的老化计时器，确保活跃的的条目不会老化。但是如果在老化时间内都没收到匹配这个条目的数据帧，交换机就会将这个老化的条目从自己的 MAC 地址表中删除。\n\n还可以手动在交换机的 MAC 地址表中添加静态条目。静态添加的 MAC 地址条目优先动态学习的条目进行转发，而且静态条目没有老化时间，会一直保存在交换机的 MAC 地址表中。\n如何使用 MAC 地址表条目进行转发？  \n当交换机的某个端口收到一个单播数据帧时，它会查看这个数据帧的二层头部信息，并进行两个操作。一个操作是根据源 MAC 地址和端口信息添加或更新 MAC 地址表。另一个操作是查看数据帧的目的 MAC 地址，并根据数据帧的目的 MAC 地址查找自己的 MAC 地址表。在查找 MAC 地址表后，交换机会根据查找结果对数据帧进行处理，这里有 3 中情况：\n\n 交换机没有在 MAC 地址表中找到这个数据帧的目的 MAC 地址，因此交换机不知道自己的端口是否有连接这个 MAC 地址的设备。于是，交换机将这个数据帧从除了接收端口之外的所有端口泛洪出去。\n\n\n\n 交换机的 MAC 地址表中有这个数据帧的目的 MAC 地址，且对应端口不是接收到这个数据帧的端口，交换机知道目的设备连接在哪个端口上，因此交换机会根据 MAC 地址表中的条目将数据帧从对应端口单播转发出去，而其它与交换机相连的设备则不会收到这个数据帧。\n\n\n\n 交换机的 MAC 地址表中有这个数据帧的目的 MAC 地址，且对应端口就是接收到这个数据帧的端口。这种情况下，交换机会认为数据帧的目的地址就在这个端口所连接的范围内，因此目的设备应该已经收到数据帧。这个数据帧与其它端口的设备无关，不会将数据帧从其它端口转发出去。于是，交换机会丢弃数据帧。\n\n\n单播：主机一对一的发送数据。单播地址是主机的 MAC 地址。 广播：向局域网内所有设备发送数据。只有全 1 的 MAC 地址为广播 MAC 地址，即 FF-FF-FF-FF-FF-FF 。 泛洪：将某个端口收到的数据从除该端口之外的所有端口发送出去。泛洪操作广播的是普通数据帧而不是广播帧。\n\n三层转发原理路由器有多个端口，分别连接不同的数据链路。它通过识别目的 IP 地址的网络号，再根据路由表进行转发，路由表中有匹配的路由条目才会转发，无匹配的路由条目则直接丢弃。路由条目既可以手动设置静态路由，也可以通过路由协议自动生成动态路由。\n路由器如何进行三层转发？  \n当一台路由器收到一个数据包时，会执行如下步骤：\n\n 对数据包进行解封装。\n\n通过解封装，查看网络层头部信息的目的 IP 地址。\n\n 在路由表中查找匹配的路由条目。\n\n查找匹配的路由条目，就需要将数据包的目的 IP 地址与各个路由条目的网段地址先进行二进制与（ AND ）运算，再将运算结果与路由条目的网段地址进行比较，若一致则该条目与目的 IP 地址相匹配。最后，与所有路由条目完成运算和比较，可得到一条或多条相匹配的路由条目。也可能没有匹配的路由条目，那么丢弃数据包。\n\n\n 从多个匹配项中选择掩码最长的路由条目。\n\n如果路由表中有多条路由条目都匹配数据包的目的 IP 地址，则路由器会选择掩码长度最长的路由条目，这种匹配方式称为最长匹配原则。\n例如：10.1.3.10 的网络地址与 10.1.3.0/16 和 10.1.3.0/24 两项都匹配，这时应该选择匹配度最长的 10.1.3.0/24 。\n\n\n 将数据包按照相应路由条目进行转发。\n\n路由条目中包含下一跳和出接口。当路由器找到相应的路由条目后，它就会根据对应的下一跳和出接口，将数据包从出接口发送数据给下一跳设备。\n\nARP只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报文。但是在进行实际通信时，还要知道每个 IP 地址所对应的 MAC 地址。\n地址解析协议，简称 ARP 协议。是根据目的设备的 IP 地址来查询对应 MAC 地址的协议。\nARP 的工作原理当主机 A 向同一个网段内的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。\n\n\n ARP 请求：主机 A 以主机 C 的 IP 地址为目的 IP 地址，以广播 MAC 地址为目的 MAC 地址，在同网段内发送这个广播报文，这个报文就叫 ARP 请求报文。\n\n二层交换机不查看 IP 地址，根据目的 MAC 地址将报文除接收端口外的所有端口发送。\n\n\n ARP 响应：主机 C 发现目的 IP 地址是自己的 IP 地址，于是主机 C 以自己 MAC 地址和 IP 地址作为源 MAC 地址和源 IP 地址，以主机 A 的 MAC 地址和 IP 地址作为目的 MAC 地址和目的 IP 地址，发送响应报文给主机 A ，这个报文就叫 ARP 响应报文。其它主机收到主机 A 的 ARP 请求报文，因为目的 IP 地址不是自己的 IP 地址，因此不会进行响应。\n\n当主机 A 在发送 ARP 广播请求报文时，二层交换机已经有主机 A 的 MAC 地址表条目。当收到主机 C 发送的单播 ARP 响应报文时，二层交换机将报文从相应端口发送出去。并将主机 C 的 MAC 地址和对应端口记录到 MAC 地址表中。\n\n\n 更新 ARP 缓存表：主机 A 收到 ARP 响应报文后，将主机 C 的 IP 地址和 MAC 地址记录到 ARP 缓存表中。下次再向主机 C 发送数据时，直接将缓存的目的 MAC 地址进行封装。\n\n\n当主机 A 向不同网段的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。\n\n\n 主机 A 使用主机 C 的 IP 地址查询 ARP ，ARP 发现主机 C 不在同一个网段，需要通过默认网关（即默认路由的下一跳地址），但是没有网关 MAC 地址；\n\n\n\n 主机 A 先将发送给主机 C 的数据放入缓存中，然后发送 ARP 请求报文，主机 A 以网关 IP 地址为目的 IP 地址发送 ARP 广播请求报文；\n\n\n\n 路由器收到 ARP 广播请求报文后，将主机 A 的 MAC 地址和对应端口添加到自己的 MAC 表中，然后查看目的 IP 地址发现是请求自己的 MAC 地址，于是单播发送 ARP 响应报文；\n\n\n\n 主机 A 收到 ARP 响应报文后，将发送给主机 C 的数据封装网关 MAC 地址为目的 MAC 地址进行发送；\n\n\n\n 路由器收到报文后，查看目的 IP 地址，是发送给主机 C 的，于是查询路由表从相应端口发送数据。由于没有主机 C 的 MAC 地址，路由器发送 ARP 请求报文，源 MAC 地址和源 IP 地址替换为发送端口的 MAC 地址和 IP 地址；\n\n\n\n 主机 C 收到 ARP 请求报文后，添加路由器的端口和 MAC 地址到 MAC 地址表，单播发送 ARP 响应报文；\n\n\n\n 路由器收到主机 C 的 MAC 地址后，将其添加到 MAC 地址表中。将主机 A 发送给主机 C 的报文重新封装，以自己的 MAC 地址为源 MAC 地址，以主机 C 的 MAC 地址为目的 MAC 地址，发送给主机 C ；\n\n\n\n 主机 C 收到主机 A 发送的数据，发送过程结束。\n\n当主机 C 向主机 A 发送回复报文时，同主机 A 向主机 C 发送数据的步骤一致。\n小耸​\nPC1 ————————- 三层交换机 ———————–PC2　192.168.1.2　　192.168.1.1　　192.168.2.1　　192.168.2.2简述 PC1 ping PC2 的完整过程，含报文流程，以及 PC1、PC2、交换机各自的行为。[答:]#1 PC 1 首先检查出目的 IP 地址 192.168.2.2（PC 2）与自己不在同一网段，因此它发出请求网关地址 192.168.1.1(即是交换机的三层接口) 对应 MAC 的 ARP 请求；\n#2 SWITCH 收到 PC1 的 ARP 请求后，检查请求报文发现被请求 IP 是自己的三层接口 IP，因此发送 ARP 应答并将自己的三层接口 MAC（MACS）包含在其中。同时它还会把 PC 1 的 IP 地址与 MAC 地址对应（192.168.1.2&lt;==&gt;MACPC1）关系记录到自己的 ARP 表项中去（因为 ARP 请求报文中包含了发送者的 IP 和 MAC）；\n#3 PC 1 得到网关的 ARP 应答后，组装 ICMP 请求报文并发送，报文的目的 MAC＝MAC S、源 MAC＝MAC PC 1、源 IP＝192.168.1.2、目的 IP＝192.168.2.2；\n#4 SWITCH 收到报文后，首先根据报文的源 MAC+VID（即 VLAN ID）更新 MAC 地址表。然后，根据报文的目的 MAC＋VID 查找 MAC 地址表，发现匹配了自己三层接口 MAC 的表项。这里说明一下，三层交换机为 VLAN 配置三层接口 IP 后，会在交换芯片的 MAC 地址表中添加三层接口 MAC＋VID 的表项，并且为表项的三层转发标志 (Route 标志) 置位。当报文的目的 MAC 匹配这样的表项以后，说明需要作三层转发，于是继续查找交换芯片的三层表项；\n#5 交换芯片根据报文的目的 IP 去查找其三层表项，因为交换机当前路由表只有192.168.1.1/32192.168.1.2/32192.168.2.1/32192.168.1.0/24192.168.2.0/24所以 ping request 报文命中 192.168.2.0/24 转发出口是交换机 CPU\n#6 CPU 根据报文的目的 IP 去查找其软件路由表，发现匹配了一个直连网段（PC 2 对应的网段），于是继续查找其软件 ARP 表，仍然查找失败。然后 SWITCH 会在目的网段对应的 VLAN 的所有端口发送请求地址 192.168.2.2 对应 MAC 的 ARP 请求；\n#7 PC2 收到 SWITCH 发送的 ARP 请求后，检查发现被请求 IP 是自己的 IP，因此发送 ARP 应答并将自己的 MAC（MAC PC2）包含在其中。同时，将 SWITCH 的 IP 与 MAC 的对应关系（192.168.2.1&lt;==&gt;MACS）记录到自己的 ARP 表中去；\n#8 SWITCH 收到 PC 2 的 ARP 应答后，将其 IP 和 MAC 对应关系（192.168.2.2&lt;==&gt;MACPC 2）记录到自己的 ARP 表中去，并将 PC 1 的 ICMP 请求报文发送给 PC 2，报文的目的 MAC 修改为 PC 2 的 MAC（MAC PC2），源 MAC 修改为自己的 MAC（MACS）。同时，在交换芯片的三层表项中根据刚得到的三层转发信息添加表项（内容包括 IP、MAC、出口 VLAN、出端口），这样后续的 PC 1 发往 PC2 的报文就可以通过该硬件三层表项直接转发了；\n#9 PC 2 收到 SWITCH 转发过来的 ICMP 请求报文以后，回应 ICMP 应答给 PC1。ICMP 应答报文的转发过程与前面类似，只是由于 SWITCH 在之前已经得到 PC1 的 IP 和 MAC 对应关系了，也同时在交换芯片中添加了相关三层表项，因此这个报文直接由交换芯片硬件转发给 PC 1；\n#10 这样，后续的往返报文都经过查 MAC 表 =&gt; 查三层转发表的过程由交换芯片直接进行硬件转发了。\n上面就是简单的三层交换的过程了。\n二层交换就比三层简单多了，同一个 IP 网段内的主机互 ping，如果不知道对方的 MAC 地址，就通过 ARP 协议泛洪，得到了对方的 MAC 地址以后，再发出 ICMP 报文，就可以 ping 通了。\nsir long\n你可以参考下这个小结，个人认为总结得还是比较到位的。\n首先二层转发是基于 MAC 地址转发，三层转发基于 IP 地址转发，但是这并不意味着仅仅依靠 IP 地址就能转发，三层转发是建立在二层的基础上的，而仅仅依靠 MAC 地址是能够转发的。另外，由于二三层转发基于 MAC 地址、IP 地址、FDB 表（MAC 地址学习、更新、老化、删除等）、ARP 表、路由表、三层转发表、VLAN 端口类型（Access、Trunk、Hybrid）、VLAN 帧格式、ARP 报文格式等需要对此有基本的熟知。以下图为例，总结一下交换机中，基于 VLAN 的二三层转发原理。\n\n一、基本概念术语：①MAC 地址：48bit 的硬件地址，单播地址格式为首字节最低位为 1，多播地址格式为首字节最低位为 0，广播地址为全 1（即 FF：FF：FF：FF：FF：FF）。②FDB 表（FordWarding DateBase）：即 MAC 地址映射表，有 MAC 地址、端口、VLAN ID 等信息。③ARP 表：用于记录 IP 和 MAC 映射关系的表。④三层转发表：即基于硬件三层转发的包含目的 IP 地址、VLAN ID、端口和下一跳 MAC 地址等的关系表。⑤路由表：包含默认路由、RIP 等动态路由的路由路径信息的记录表。⑥VLAN 端口：主要是 Access 一般是用于连接主机，其发出的数据帧不带 tag 标签；还有就是 Trunk 用于可连接不同交换机的主干链路，其上发出的数据帧可能会带 tag 标签，用以识别不同 VLAN，如果没带则采用默认的 VLAN （PVID）\n假设最开始所有 PC 和交换机没有任何表项存在（ARP 缓存、FDB 缓存、三层转发表缓存等），且端口均为 Access 模式。\n二、二层转发（同一 VLAN 中主机通信）：以上图中 PC_A ping PC_B 为例来详细分析整个过程。①PC_A（192.168.10.1/24） 要 ping PC_B(192.168.10.2/24)，首先要去检查目标 IP 地址和自己的 IP 地址是否在同一个网段中，经过 IP 和子网掩码进行与运算，得知 PC_A 和 PC_B 属于语同一网段 192.168.10.0 网段。因此进行下一步：ARP 表项查询。②根据目标 IP：192.168.10.2 作为索引，在 ARP 表中查找对应的 MAC 地址，由于 ARP 表最开始是空的，所以没有找到对应 MAC，因此 PC_A 需要发送一个 ARP 广播报文在 VLAN 1 中请求 PC_B（192.168.10.2）的 MAC 地址，PC 封装的 ARP 报文主要内容为（opcode 操作码字段为 0X01 代表这是一个 ARP 请求报文，目标 MAC 由于不知道因此填充为 0，其余包含以太帧头部具体如下图所示）\n\n关于 ARP 报文各个字段的含义，用 wireshark 抓一个 ARP 包来查看，如下所示：\n\n③当交换机从 a 端口收到 PC_A 发出的报文，解析以太头部后发现目标 MAC 是 FF：FF：FF：FF：FF：FF，则知其是一个广播帧，解析源 MAC：MA，由于 FDB 表当前空空如也，因此先将 port a&lt;-&gt;MA&lt;-&gt;VLAN 1 等信息缓存到 FDB 表中。之后根据端口为 Access 模式，加上一个 VLAN tag（主要包含优先级和 VLAN ID=1），使其成为一个 802.1Q 的带有 VLAN tag 的以太帧，在交换机内部开始进行交换。④端口检测后发现 b、c、d 三个端口（其实还有一个 VLAN 接口，暂不提及）归属于 VLAN 1，因此将 tag 剥离并从这三个端口转发出去。⑤当 PC_C、PC_D 收到该广播帧解析内容发现目标 IP 不是自己则丢弃该数据帧，而 PC_B 发现目标 IP 就是自己，则先将 PC_A 的 192.168.10.1&lt;-&gt;MA 的映射信息更新到本地 ARP 表中。然后封装一个 ARP 回应的单播报文，内容主要为：源 IP：192.168.10.2，目标 IP：192.168.10.1，源 MAC：MB，目标 MAC：MA。发送出去，经端口 b 到达交换机。⑥交换机收到来自端口 b 的报文，解析头部获得源 MAC，则先将 port b&lt;-&gt;MB&lt;-&gt;VLAN 1 缓存到 FDB 表中去，由于 FDB 表中已经有了 PC_A 的 MAC 地址缓存，因此根据 ARP 回复报文数据帧头部的目标 MAC 将报文从端口 a 转发出去（该步中当然也存在入口数据帧 tag 的添加与出口数据帧 tag 剥离的操作）。⑦PC_A 接收到从端口 a 发出的 ARP 报文后，解析以太头部进行目标 MAC 匹配判断，匹配后解析报文内容，发现源 IP&lt;-&gt; 源 MAC 的对应关系，因此先缓存 192.168.10.2&lt;-&gt;MB，到 ARP 表中，之后有了 PC_B 的 MAC 地址接可以封装 icmp 报文进行 ping 的后续操作了。⑧交换机收到来自 PC_A 和 PC_B 的 icmp request 与 icmp reply 报文，由于之前有缓存 FDB 表项，因此之后只会更新对应表项的老化标志，长时间没有这俩源 MAC 的报文到交换机则会删除对应表项。\n三、三层转发（跨越不同 VLAN 的主机通信）：以上，以一台交换机上的同一个 VLAN 内的不同主机通信为例，描述了的是二层转发的基本过程，包括 ARP 表查询、ARP 请求、交换机 MAC 地址查询、FDB 表缓存、端口类型检查、VLAN tag 添加与剥离、目标主机 ARP 回复等步骤。而三层交换基本步骤差不多。以 VLAN 1 的 PC_A（192.168.10.1，MA）和 VLAN 2 的 PC_E（192.168.20.1，ME）相互 ping 为例分析（假设 VLAN 1 的网关为 VLAN 1 interface 的 IP：192.168.10.254，VLAN 2 的网关为 VLAN 2 interface 的 IP 为 192.168.20.254），以下过程也有加 VLAN tag 和剥离 VLAN tag 的过程，但与二层基本一致，因此不再赘述：\n①当 PC_A（192.168.10.1/24）要 ping PC_E（192.168.20.1/24）时，依然是检查目标 IP 是不是和自己在同一个网段，发现不在同一网段（一个在 10.0 网段一个在 20.0 网段），则需要经过网关（这里是交换机三层接口）来转发，因此 PC_A 在自己的 ARP 表中寻找网关对应的 MAC 地址，如果有则直接将报文封装为：目标 MAC 为网关 MAC，源 MAC 为 MA，发送端 IP 为 192.168.10.1，接收端 IP 为 192.168.20.1。②由于第一次 PC_A 的 ARP 缓存中不存在网关的 MAC 地址。则先向 VLAN 1 内广播发送一个 ARP 请求，请求网关 192.168.10.254 的 MAC 地址，封装为源 MAC 为 MA，目标 MAC 不可知则为全 0，源 IP 为 192.168.10.1，目标 IP 为 192.168.10.254，到链路层封装的头部为，源 MAC 为 MA，目标 MAC 为全 F 即广播包，“帧类型” 字段则填上 ARP 的协议号 0x0806。③交换机 SW1 收到 PC_A 发送的报文，二层解析头部检查为广播包，则从 VLAN 1 的除源端口外的各个端口转发出去，另外也转发一份到 VLAN 1 的三层接口，由于 PC_A 之前给 PC_B 发送过报文，SW 1 有 PC_A 的 FDB 缓存，则检查匹配后更新老化标志位。此外将 PC_A 的 IP、MAC、对应 port、VLAN ID 等信息记录到交换机的三层转发表中。④VLAN 1 其他主机收到请求对象不是自己的 ARP 请求，丢弃该广播报文，而 SW 1 的三层接口解析到目标 IP 是自己，则封装一个源 MAC 是交换机 VLAN 1 interface 的 MAC，源 IP 是 192.168.10.254，目标 IP 是 192.168.10.1，目标 MAC 是 MA 的 ARP 应答报文，再经过以太头部封装，添加 ARP 单播报文头部，目标 MAC 为 MA。交换机二层收到自三层的报文，解析数据帧头部，根据目标 MAC 地址 MA 在 FDB 表中查找到其出端口是 port a，为 ACCESS 端口，则剥掉 tag（之前请求报文进入 port a 之后会被加上 tag，以致能够区分识别出 VLAN 1 的其他端口与 VLAN 1 interface）转发给 PC_A。⑤PC_A 收到网关的 MAC 地址，则将发给 PC_E 的报文修改目标 MAC 为 VLAN 1 interface 即网关的 MAC 地址，而目标 IP 依旧是 PC_E 的 IP：192.168.20.1，然后封装以太头部以单播形式发送出去。⑥SW 1 在收到这个数据包后，因为 “目的 MAC 地址” 为交换机自己 VLAN 接口的 MAC 地址，而且 “目的 IP 地址” 和“源 IP 地址”不在同一网段，所以直接提交到三层，根据包中的 “目的 IP 地址”(PC_E 的 IP 地址) 在三层硬件转发表中查看有无对应表项，因为是第一次通信，所以结果是查找失败，于是将数据包再转送到 CPU 去进行软件路由处理。⑦ CPU 同样会根据包中的 “目的 IP 地址” 去查找其软件路由表，发现匹配了一个直连网段(PC_E 对应的网段)，于是继续查在 ARP 表中查找对应的 MAC 地址项。同样是由于是第一次查找，所以仍然查找失败。如果在 ARP 表中找到了对应的 MAC 地址，则数据可以直接由软件路由表转发了。⑧如果没查找到则以 PC_E 的目标 IP 为请求对象，在其所在 VLAN 2 的目标网段内发送 ARP 请求广播（目标 MAC 为全 0，目标 IP 为 192.168.20.1，源 MAC 为 VLAN 2 interface 对应 MAC，源 IP 为 VLAN 2 interface 对应 IP，192.168.20.254），PC_E 则先缓存网关的 ARP 表项，然后以 ARP 单播形式回复自己的 MAC 地址 ME 给网关 192.168.20.254，SW 1 的 CPU 则根据回复的报文更新记三层转发表项，记录到 PC_E 的 IP、MAC、出端口、VLAN ID 等信息，此时三层转发表中有了 PC_A 和 PC_E 的转发表项。另外缓存 PC_E 的 ARP 表项与 FDB 表项目。⑨三层交换机的 CPU 根据获取到的目标主机 MAC 和现有的直连路由信息将 PC_A 发来的数据包转发给 PC_E，这就是一次单方向的三层转发过程，其中也大量涉及到了二层转发（PC_A 在 VLAN 1 内广播请求网关 MAC，交换机 CPU 控制在 VLAN2 内广播请求 PC_E 的 MAC 等）。⑩当 PC_E 回复 PC_A 报文时，与 PC_A 步骤相同，只是在 PC_E 上已经存在了网关 ARP 表项、交换机上已经存在了到 PC_A 的三层转发表项、FDB 表项等，所以会更简单些。另外由于三层转发表项的存在，因此 PC_E 回复 PC_A 的报文会直接根据三层转发表进行硬件转发，而不是 CPU 路由软件转发，效率会更快。\n","tags":["计算机网络"]},{"title":"新年期望","url":"/2021/05/02/simpread-%E6%96%B0%E5%B9%B4%E6%9C%9F%E6%9C%9B_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"\n本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net\n\n1， 云原生开发 ： K8S， Docker , DevOps , Jenkins， Prometheus ，Rancher\n2， 微服务架构:    SpringBoot，微服务。\n3， 开发 ：           Vue，Golang , Python 高阶\n4， infra ：          计算机网络（CCNA，IP 规划)\n5,    项目经理：    PMO， PMP\n2021.02.26\n","tags":["学习"]},{"title":"全面讲解 Vlan、三层交换机、网关、DNS、子网掩码、MAC 地址等网络知识","url":"/2021/11/16/simpread-%E5%85%A8%E9%9D%A2%E8%AE%B2%E8%A7%A3%20Vlan%E3%80%81%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%20%E5%9C%B0%E5%9D%80%E7%AD%89%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%EF%BC%8C%E5%80%BC%E5%BE%97%E6%94%B6%E8%97%8F%E5%AD%A6%E4%B9%A0%EF%BC%81/","content":"我们现在做的弱电工程，经常用到网络知识，比如 vlan、三层交换机、网关、DNS、子网掩码、MAC 地址等方面的知识，作为从业人员，我们对这些知识了解并熟知的。\n一、什么是 VLAN\nVLAN 中文是 “虚拟局域网”。LAN 可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN 所指的 LAN 特指使用路由器分割的网络——也就是广播域。\n听上面的概念，肯定有不少朋友是一头雾水的，什么是虚拟局域网？好好的，为什么要划分 vlan？\n这里举个例：通俗的了解\n一所高中，新学期高一招了 800 个学生，这 800 个学生，如果放在一个班里，那肯定是管理不过来，面对 800 个人，老师看了也头疼，这边在授课，那边完全听不到，老师布置什么任务，也会有一些传达不到，老师要是想找某个学生的信息，要从 800 份信息中去找，极其麻烦，浪费时间；\n而实际中，也是一样，电脑 A 要想要与电脑 B 通信，于是电脑 A 就需要发送 arp 请求，而网络中电脑众多，最终 ARP 请求会被转发到同一网络中的所有电脑，才能找到电脑 B，如此一来，为了找到电脑 B，消耗了网络整体的带宽，收到广播信息的计算机还要消耗一部分 CPU 时间来对它进行处理。造成了网络带宽和 CPU 运算能力的大量无谓消耗。\n那么怎么办呢？\n学校就针对这 800 个学生，分成了 10 个班，每个班 80 人，分别命名为高一（1）班，高一（2）班、、、、高一（10）班，每个人都会获得一个班级编号。\n1101 表示一班 01 号学生。\n1102 表示一班 02 号学生。\n1201 表示 2 班 01 号学生。\n同一个班的学生编号尾数不同，其它的都相同。\n那么这样老师再管理起来就轻松多了，可以把一班这 80 人管理的妥妥的，隔壁 2 班与 3 班乱成一锅粥也不管一班的事，我就要这一班 80 人好好上课就行。\n这就是 vlan，每个班就相当于一个 vlan，而每个班名称，就相当于 vlan 的名称，而每个学生的编号就是 ip 地址；同班同学（同一个 vlan 的 ip），因为同一个教室，朝夕相处，且可以相互通信，不同班的同学，若不做其它工作，很难往来通信。\n所以同一个 vlan 间，可以相互通信；不同 vlan，若不做配置，不能相互通信。\n那么不同 vlan 如何通通信呢？就需要单臂路由与三层交换机。\n二、单臂路由与三层交换机\n我们知道要实现不同 vlan 间通信，就必须需要有路由功能，不同 VLAN 之间相互通信的两种方式（单臂路由、三层交换机）。\n什么是单臂路由？\n单臂路由的实现方式，其实就是普通二层交换机加路由器，从而实现不同 vlan 间的可以互相通信。\n\n那什么是三层交换机呢？\n对于小型的网络，单臂路由可以应付，但随着 VLAN 之间流量的不断增加，很可能导致路由器成为整个网络的瓶颈，出现掉包、或者通信堵塞。\n为了解决上述问题，三层交换机应运而生。三层交换机，本质上就是 “带有路由功能的（二层）交换机”。路由属于 OSI 参照模型中第三层网络层的功能，因此带有第三层路由功能的交换机才被称为 “三层交换机”。\n关于三层交换机的内部结构，可以参照下面的简图。\n\n在一台本体内，分别设置了交换机模块和路由器模块；而内置的路由模块与交换模块相同，使用 ASIC 硬件处理路由。因此，与传统的路由器相比，可以实现高速路由。并且，路由与交换模块是汇聚链接的，由于是内部连接，可以确保相当大的带宽，所以对于正规的项目，需要使用三层交换机来实现网网络间的通信。\n三、什么是网关\n在了解了 vlan 与三层交换机后，能不能通信，还需要看网关是否正确。\n什么是网关\n网关 (Gateway) 又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。\n如何来理解网关\n大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道 “关口”，这道关口就是网关。顾名思义，网关(Gateway) 就是一个网络连接到另一个网络的“关口”。\n按照不同的分类标准，网关也有很多种。TCP/IP 协议里的网关是最常用的，在这里我们所讲的 “网关” 均指 TCP/IP 协议下的网关。\n网关的 ip 地址\n那么网关到底是什么呢？\n网关实质上是一个网络通向其他网络的 IP 地址，网关在网段内的可用 ip 中选一个，不过，一般用的是第 1 个和最后一个。\n例如\n比如有网络 A 和网络 B，\n网络 A：的 IP 地址范围为 “192.168.1.1~192. 168.1.254”，子网掩 255.255.255.0；\n如果需要与其它网段通信，那么它的网关可以设置为 192.168.1.1，当然也可以设置为网段内其它的一个 ip 地址。\n网络 B：的 IP 地址范为 “192.168.2.1~192.168.2.254”，子网掩码 255.255.255.0。\n如果需要与其它网段通信，那么它的网关可以设置为 192.168.2.1，当然也可以设置为网段内其它的一个 ip 地址。\n\n网关是如何实现通信？\n在没有路由器的情况下，不同的两个网络之间是不能进行 TCP/IP 通信的，即使是两个网络连接在同一台交换机 (或集线器) 上，TCP/IP 协议也会根据子网掩码 (255.255.255.0) 判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。\n如果网络 A 中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络 B 的网关，网络 B 的网关再转发给网络 B 的某个主机 (如附图所示)。网络 B 向网络 A 转发数据包的过程。\n所以说，只有设置好网关的 IP 地址，TCP/IP 协议才能实现不同网络之间的相互通信。\n什么是默认网关？\n　　如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。\n四、什么是 DNS\nDNS 是域名解析服务器（Domain Name System），是把网址变成 IP 地址的服务器。\nDNS 说白了是把域名翻译成 IP 地址用的，这里面举个例子，大家就很容易清楚了。\n例如我们在浏览器里面输入 http://www.baidu.com 的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这台服务器的 IP 地址，我们不知道 IP 地址是多少，那么就需要主机问 DNS 服务器，DNS 服务器就自动帮我们把 http://www.baidu.com 这个域名翻译成了 IP 地址 61.135.169.105。然后写到了数据包的目的 IP 地址里面就可以进行通信。\n就跟我们写信一样，你得写个收信人的地址邮局才能给你发送吧，你给国外写信，你写中文地址邮局不认识，需要这个一个人帮你翻译成英语。这就是 DNS 的作用，所以你的在本地连接里面写 DNS 才可以正常浏览网页，如果不设置 DNS，是无法正常访问网页的。\n五、MAC 地址\n讲到 MAC 地址，就不得不提 ip 地址，这里顺便把 ip 地址也说下。\nIP 与 MAC\n虽然现在已经 ipv6 了，但我们基本用的大多数还是 ipv4 协议，所谓 ip 就是你电脑整个网络的编号。其他电脑想访问电脑就得需要这个编号。但是这个编号很多情况下是一直在变化的。唯一不变的是你的 MAC 地址：物理地址。\nMAC 是网络中用来标识网卡设备的唯一网络地址。由相关硬件制造商统一分配，每台电脑的 MAC 地址都是唯一的。\n做个比喻，你经常搬家，你没搬一次家都有一个地址，XX 小区 XX 单元 XX 号，这个就是 IP。但是你的名字不变，这个就是 MAC，不同的是我们的 MAC 不允许重名。\n\n我们的 IP 分为两个部分：如上图分为网络部分和主机部分。网络部分好比就是你在 XX 省 XX 市 XX 镇，这个是国家固定下来了的。但是 XX 小区 XX 单元 XX 号是开发商自己定的。两个编号加起来就是你的 ip 了。不同的是在现实中两个编号的长度是固定的，在网络上 A、B、C、D 的 ip 地址却是变化的，这个在前天有详细讲到。\n六、子网掩码\n子网掩码是为了区分网络位和主机位，上面我们说到过，一个 ip 地址是由网络部分和主机部分。正如一个人的名字由姓与名组成。\n那么我们可以把 IP 地址比作一个人的名字，那么子网掩码就像是一份名单，可以快速的知道那些人同姓，那些人不同姓，把同姓的人分在一组，让他们之前可以互相交流。\n举个例子\n有一个网段是 192.168.1.0-192.1.254，这个网段就像一个村子一样，就称它为安防村，此这网段有个 ip 地址是 192.168.1.1，我们就叫他安防一，另外一个人叫安防二，它的 ip 地址为 192.168.1.2，我们一看他们，就知道他们是同村的。\n另外有一个网段，是 192.168.0.0——192.168.255.254，我们叫它安村，村里有个同样有两个 ip 地址为 92.168.1.1 与 192.168.1.2，也叫安防一，安防二，那么问题来了？这个时候，如何区分他们是属于那个村的？\n这个时候就需要子网掩码了来判断他们是属于那个网段的，需要把安防一、安防二带到村里去认下，就知道他们是属于那个村了，安防村的网段是 255.255.255.0，安村的网段是 255.255.0.0。\n网络中也会出现类似于 “同名”“同姓” 的 ip 地址，如何区分他们到底是属于那个网段，就需要依靠子网掩码了。\n","tags":["计算机网络"]},{"title":"好看的几个CSDN背景图","url":"/2021/05/02/simpread-%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%87%A0%E4%B8%AA%20CSDN%20%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BE_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2_csdn%20%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BE/","content":"以下是比较好看的  CSDN 背景图\n保存一下\nhttps://blog.csdn.net/qq_36650546\nhttps://blog.csdn.net/weixin_54225634https://blog.csdn.net/weixin_45157820\nhttps://blog.csdn.net/eastmount?spm=1000.2115.3001.4128\n","tags":["喜欢"]},{"title":"深度学习有哪些好玩且易于实现的论文？","url":"/2021/11/12/simpread-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%8E%A9%E7%9A%84%E4%B8%94%E6%98%93%E4%BA%8E%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%AE%BA%E6%96%87%EF%BC%9F%2020211114/","content":"\nGitHub 上发现了一个不错的项目，收集了中国科学技术大学课程资源，主要包括了计算机学院，也包括经管、经济、物理、数学等相关课程的 repo，甚至包含了人文社科类的。目前该项目已收获了 13716 个 Star，4221 个 Fork。课程的结构大致如下：\nhttps://ustc-resource.github.io/USTC-Course/\n有很多\nMachine Learning solutions in AWS Marketplace\n亚马逊的机器学习的博客\nAWS Marketplace\n2019/10/25 再次更新\nLearn Python - Free Interactive Python Tutorial\n优达学城，乔治亚理工学院的课程\n优达学城课程分类_在线视频课程 - 优达学城 (Udacity) 官网\n关于软件和镜像下载源，大家可以看看我这篇回答。管清华和中科大的朋友要的。 清华，中科大，计算机学院下载资源\n2019/10/17 更新 ，基于大家对我的喜爱，我就放两本很好的电子书的链接在上边。深度学习的哦。如果你们给我点赞多一点，或者转发，我会放更多的资料在上边。\nDeep LearningNeural networks and deep learning\n—————————————- 我是分割线 —————————————— 有很多！今天来强答一波。祭出我的月光宝盒来。各位小哥哥，小姐姐，看完记得点个赞哦 (´-ω-`)。还有机器学习大礼包，含 tensorflow 书籍和李航统计学习法，以及斯坦福的课件，大小 400 多 M，有需要的小宝贝私聊我就好。！(上传百度网盘链接，居然涉及违法违规～)\n1. 网站 https://paperswithcode.com/sota\n\n2. 网站 https://github.com/zziz/pwc/blob/master/README.md#—- ，是这个样子的，和上边差不多。\n\n3. 还有视频，讲神经网络的，附 YouTube 链接 https://www.youtube.com/watch?v=aircAruvnKk\n\n4. 以及_DeepLearning-500-questions，_https://github.com/scutan90/DeepLearning-500-questions 深度学习 500 问，以问答形式对常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题进行阐述，以帮助自己及有需要的读者。\n\n5. 以及莫烦小哥的 python https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/\n\n6. 这个是思科的，Welcome to Deep Learning NLP documentation!\n\n7. 这网站非常硬核，讲的清楚，而且很干净漂亮。还有 python 跟 R 的内容代码https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/\n\n\n\n还有一个开放的社区，会定期讨论大家最近在看什么文章，机器学习相关的项目。前两天还让我投票，说是发起了请愿书，让大家呼吁不要去美国开 AI 的国际会议。https://www.reddit.com/r/MachineLearning/\n\n\n\n还有中科大的这个教程，从人工智能到区块链应有尽有\n\n\n给大家放上几本好书，推荐！\n\n","tags":["学习"]},{"title":"-秒懂二层交换机16个问题","url":"/2023/01/31/simpread-%E7%A7%92%E6%87%82%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%2016%20%E4%B8%AA%E9%97%AE%E9%A2%98%20__%20%20%20%20%20%20%20%20_%20%20%20%20%20%20%20%20Yixin%20blog/","content":"\nHexo Theme Keep\n\n1、什么是中继器？中继器（ repeater ）是一种信号增强设备，运行在 OSI 参考模型的_第一层_。它的功能仅仅是将信号重新输出，延迟网络的传输距离，不进行其它的数据控制，也无法识别数据链路层的 MAC 地址和网络层的 IP 地址。\n\n2、什么是网桥？网桥（ bridge ）是具有两个端口的_二层_网络设备，可隔离冲突域。作用相当于 OSI 模型中的数据链路层，能够根据 MAC 地址进行数据转发。只能连接同构网络 (同一网段)，不能连接异构网络（不同网段）。\n\n3、什么是集线器？集线器（ hub ）是工作在_物理层_、具有信号放大功能、以它为中心的网络设备。即一个多端口的中继器，以集线器为中心，连接多个节点。广播方式发送数据，也就是说，当它要发送数据时，会发送到与集线器相连的所有节点。\n\n由于集线器没有控制功能，因此所有终端共享带宽，同一时刻只能一个终端发送数据，多个终端同时发送数据就会产生冲突。这时，集线器、连接线缆以及连接在集线器上的终端设备构成了一个冲突域。于是采用 CSMA/CD 方式决定终端能否发送数据。\n4、什么是交换机？集线器是从接收方收到的数据，会转发给所有非发送方端口，也就是简单的通过复制电气信号来实现发送。\n但是交换机是通过学习连接的每个终端的 MAC 地址，将数据发送给对应的目的终端上，避免将数据发送到无关端口，提供网络利用率。这里说的交换机都是_二层_交换机。\n\n如果是没有学习到的 MAC 地址，或者想跟网段内所有终端进行通信，交换机会使用广播方式，将数据帧进行泛洪。\n5、交换机如何学习 MAC 地址？交换机通过数据帧的源 MAC 地址，学习到交换机端口和 MAC 地址的对应关系，并记录到交换机的 MAC 地址表中。\n主机 A 向主机 D 发送数据：A 发送数据帧，数据帧的源 MAC 地址是 11:11:11:11:11:11 ，目的 MAC 地址是 44:44:44:44:44:44 。交换机端口 1 收到数据帧，记录源 MAC 地址和端口的对应到 MAC 地址表项。交换机不知道目的 MAC 地址在哪个端口，于是将数据帧进行泛洪，即转发到除端口 1 之外的所有端口。B 和 C 发现目的 MAC 地址不是自己，将丢弃数据帧。\n\nD 发现是发送给自己的数据帧，于是发送应答数据帧，源 MAC 地址是 44:44:44:44:44:44 ，目的 MAC 地址是 11:11:11:11:11:11 。交换机端口 4 收到数据帧，记录 D 的 MAC 地址表项。于是交换机知道了主机 A 和主机 D 的 MAC 地址信息，之后会根据 MAC 地址表进行转发。交换机通过同样的方式，可以学习到主机 B 和主机 C 的 MAC 地址。\n\n6、对比集线器，交换机有哪些优点？\n7、以太网数据帧有哪些类型？\n8、交换机如何转发数据帧？交换机收到数据帧后，会有三种处理方法：_直通转发_、_碎片隔离_和_存储转发_。\n\n  直通转发\n\n直通转发是交换机只读取数据帧的前 14 个字节就进行转发。由于读取的数据量固定，发送方和接收方的速度需要一致，导致无法桥接不同速率的以太网。另外，只读取前 14 个字节，会跳过了 FCS 域，因此无法检测并丢弃 CRC 校验错误的数据帧。\n\n\n  碎片隔离\n\n碎片隔离是读取数据帧的前 64 个字节就进行转发，可以防止转发小于 64 字节的残帧。但是如果出现 CRC 错误，还是会转发数据帧。也无法桥接不同速率的以太网。\n\n\n  存储转发\n\n存在转发会读取数据帧全部内容再进行转发。这样就可以识别残帧和 CRC 校验错误帧，并将它们丢弃。交换机还能对数据帧进行缓存，因此可以桥接不同速率的以太网。\n\n9、单工和双工通信有什么区别？\n10、交换机的处理能力的指标是什么？交换机的处理能力也叫做背板容量或交换机容量。容量单位是 bit/s（比特每秒），值越大，说明交换机在单位时间内传输的数据越多。\n当交换机的所有端口的总带宽小于交换机的容量时，交换结构为非阻塞，即带宽充裕，没有等待处理的情况。反之，当所有端口总带宽超过交换机的容量时，叫做交换机结构过载。\n交换机是千兆端口时，处理能力达到端口数 × 2 × 1Gbit/s 的数值，就是非阻塞。其中 × 2 表示上行和下行都是 1Gbit/s 的全双工通信。假如交换机有 24 个端口，背板容量到达 24 × 2 × 1G = 48Gbit/s ，就是非阻塞。\n11、根据功能分类，交换机有几种类型？交换机按照功能可以分为_二层交换机_和_三层交换机_。\n\n  二层交换机\n\n没有 IP 路由功能、仅处理数据链路层的交换机叫做二层交换机。二层交换机根据不同的功能而不同。\n\n\n  三层交换机\n\n带有 IP 路由功能的交换机叫做三层交换机。\n12、根据外形分类，交换机有几种类型？根据外形，交换机可分为_桌面式交换机_、_箱式交换机_和_机框式交换机_。\n\n  桌面式交换机\n\n桌面式交换机是指放在桌面上使用的交换机。它体积不大，只能连接几台网络设备，通常用于家庭网络中，主要有 3 端口、5 端口、8 端口和 16 端口的产品。\n桌面式交换机通常不安装风扇，采用无风扇设计，运行噪声小。\n\n  箱式交换机\n\n箱式交换机通常高度是 1U 或 2U ，可以安装在 19 英寸的机柜内。通常采用金属外壳、内置电源，并配置冷却风扇。下行有 24 千兆网口或 48 千兆网口，上行有 2 万兆光口或 4 万兆光口的配置较多。下行使用 RJ-45 的网线接口，上行使用 SFP+ 槽进行连接。\n主要作为企业中作为接入交换机使用，支持电源冗余。\n\n  框式交换机\n\n框式交换机是指在机框内组合多个接口模块的交换机。可以根据需要选择端口数量和不同类型的接口模块，扩展性好，端口数量多。\n在机框中可以添加电源、风扇等组成部分，再插入管理模块和接口模块。接口模块和管理模块叫做线卡。机框上总线的主板叫做背板，可以插入线卡。\n13、根据用途分类，交换机有几种类型？根据交换机在网络中的位置和用途，可分为三类：核心交换机（核心层）、汇聚交换机（汇聚层）和接入交换机（接入层）。\n\n14、交换机有几种端口类型？选择交换机时，需要根据实际的使用需求，以及具体的端口类型、端口数量和设备性能等参数，决定购买哪款交换机。\n千兆以太网端口大部分交换机都配置了 RJ-45 的千兆以太网接口，连接千兆接口要使用增强型 5 类双绞线。通过自适应功能，还可以连接百兆接口。\n光纤端口箱式交换机会配置光纤端口，主要是用于连接上行链路。为了连接万兆以太网的上行链路，通常会搭载 SFP+ 接口。\n框式交换机中，一般会配置多个千兆以太网 SFP 或万兆以太网 SFP+ 接口的接口卡。\nPoE 端口接入交换机还会配 PoE 端口。Poe 端口使用网线连接 IP 电话或无线 AP ，并通过网线对设备进行供电。\n为了让 IP 电话或无线 AP 无需外接电源也能接入网络，通过一根网线给设备供电的技术就是 PoE 技术。PoE 技术有简化布线、节省人工成本，管理方便，使用灵活，安全等优点，得到广泛的应用。\nPoE 技术作为 IEEE 802.af 在 2003 年完成了标准化工作，这个技术还用于网络摄像头、POS 终端等连接以太网的硬件设备。\n\n  PoE（ IEEE 802.3af ） **PoE+（ IEEE 802.3at ）PoE++**（ IEEE 802.3bt ）\n\nPoE 的供电标准是 IEEE 802.3af ，最大能提供 15.4W 的功率，可以为 IP 电话、无线 AP 等终端设备供电。 PoE+ 是 PoE 的增强版，供电标准是 IEEE 802.3at ，最大能提供 30W 的功率，可以为视频电话、 摄像机等终端设备供电。 PoE++ 是 PoE+ 的增强版，供电标准是 IEEE 802.3bt ，最大能够提供 60W 的功率，能够满足更多的终端功率需求，可以为基站、室外热感摄像机等终端设备提供更大功率的供电。\n\n支持 PoE 功能的交换机，会说明每个端口最大支持 ×× W ，设备最大供电 ×× W 等电能信息，可以算出交换机最多可接入的 PoE 设备数量。\n\n上行链路端口接入交换机和汇聚交换机要集中下行连接的所有设备流量，并将流量传输到上行的网关或核心交换机中，向网关、核心交换机传输流量的端口叫做上行链路端口，反向就叫做下行链路端口。在箱式交换机中一般会配置 2~4 个万兆上行链路端口。\n\n下行链路端口通常下行链路是 RJ-45 的接口，也有使用光纤接口的。一台交换机或一块板块，能提供 24 或 48 个接口。\n\n交换机堆叠通过堆叠线缆可以把多台交换机连接起来，成为逻辑上的一台交换机。\n15、交换机有哪些功能？交换机的完整功能说明，可以查看官网的产品文档，里面进行了详细的描述。\nMAC 地址数MAC 地址数是指一台交换机最大可以学习到的 MAC 地址表数量。\n生成树功能为了避免二层环路，我们使用生成树协议（ STP ），让交换机知道对方的存在，具体做法是在交换机之间交换 BPDU 数据帧。详情可看《图解 STP 》和《图解 RSTP 和 MSTP 》。\n链路聚合链路聚合是将交换机的多条线路汇聚成一条逻辑线路在网络中使用。有多个称呼：端口聚合、链路捆绑、绑定等。\n如果不使用链路聚合功能，直接将交换机的多个物理端口连接起来，可能会导致网络环路。如果使用生成树协议，又会避开某些链路，导致只有一条物理链路可用。如果使用链路聚合，把几条物理链路聚合成一条逻辑链路，即使某一条物理链路断开，由于逻辑线路还有其它物理链路在维持，因此通信也不会中断，到达线路冗余的效果。\nVLAN将广播域分割成一个个逻辑网段的功能叫做 VLAN 。\n端口镜像将某个端口接收和发送的数据帧复制到镜像端口的功能叫做端口镜像，被复制的源端口叫做监控端口。\n为了分析网络故障或检测网络中的流量，交换机会将收到的数据帧复制一份并转发到网络分析设备或流量监控设备中。\nQoS 优先级队列QoS 是 Quality of Service 的缩写，也叫做服务质量。当数据通过网络设备时，根据通信种类控制通信优先级和带宽的功能。通常是将声音、视频等数据定义为高优先级，高优先数据优先处理，保障这类数据的稳定和低延迟。\n除了交换机在二层进行的 QoS 控制外，还有路由器和三层交换机的三层（ IP ）的 QoS 控制，以及 TCP 进行的四层的 QoS 控制。\nIEEE 802.1p 标准完成了对二层的 QoS 优先级控制的标准化工作。通过 3bit 长度的优先级控制信息，定义了从 0 到 7 的 8 个优先级，即 CoS 值（服务等级值），交换机会优先转发值大的数据帧。\nMAC 地址过滤为了网络安全，只让指定的设备接入网络。二层交换机提供了以数据帧的头部信息进行过滤的功能。具体过程是，先设置一个过滤条件，比如目的 MAC 地址、源 MAC 地址等，满足条件的数据帧通过，阻断不满足条件的数据帧。\n考虑到伪造 MAC 地址的情况发生，还可以跟 802.1X 一起使用。三层交换机或路由器可以根据 IP 头部信息完成 IP 通信过滤的功能。\n基于端口的认证在交换机中，只有通过认证的客户端才能使用有线端口。这个功能由 IEEE 802.1X 完成标准化，对接入 LAN 的客户端进行认证的机制。\n当 PC 连接交换机时，认证过程启动。根据发送方的 MAC 地址信息进行客户端识别，通过用户名、口令或证书等认证信息进行用户认证。对于没有认证的客户端发来的数据帧，交换机只接收包含认证信息的数据帧，其余的全部丢弃。对于认证失败的客户端发来的数据帧，交换机就直接丢弃不会进行转发。\n\n要使用基于端口的认证功能，客户端的电脑和交换机都要支持 802.1X 认证功能，缺一不可。\n802.1X 认证中使用 PPP 的扩展协议 EAP ，通过 EAPOL 协议封装 EAP 认证消息，然后在 LAN 中进行传输。认证结束之前，客户端电脑只能进行 EAPOL 通信。\n\n网络管理远程管理、监控和配置网络设备可以使用 SNMP 协议。SNMP 协议可以对整个网络结构内的交换机和其它网络设备进行集中统一的管理。\n被 SNMP 管理的网络设备叫做 Agent ，管理网络的设备叫做 Manager 。\n16、交换机的架构是由什么组成？交换机的基本架构是由 RJ-45 接口、PHY 、MAC 等模块的 NIC 和管理由 NIC 收发帧缓存、转发表的软件组成，通过查看转发表信息，在 NIC 之间进行数据帧交互。\n\n","tags":["计算机网络"]},{"title":"-联想 XC 服务器命名规范","url":"/2021/05/02/simpread-%E8%81%94%E6%83%B3%20XC%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"\n","tags":["学习"]},{"title":"静态IP 动态IP 浮动IP 虚拟IP 区别是什么？","url":"/2021/11/16/simpread-%E9%9D%99%E6%80%81%20ip%20%E5%8A%A8%E6%80%81%20ip%20%E6%B5%AE%E5%8A%A8%20ip%20%E8%99%9A%E6%8B%9F%20ip%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"static ip 就是固定分配的 ip，需要手工管理，非常麻烦。为了减少麻烦，人们发明了 dhcp 协议，来自动为电脑分配 ip，这就是 dynamic ip。floating ip 跟 dynamic ip 有点像，参考各公有云厂商的弹性 ip。\n但不论 static ip、dynamic ip 还是 floating ip，一个 ip 只能分配给一台电脑。\n在有些情况（比如高可用场景）下我们需要多台电脑共用一个 ip，也就是说一个 ip 「属于」多台电脑。那怎么实现呢？是给两台电脑设置同一个 ip 吗？显然不是，因为为产生 ip 冲突。这就需要 virtual ip。\n比如我们有两台服务器 AAA 和 BBB，它们的 IP 分别是 10.0.0.1 和 10.0.0.2。它们功能相同，提供相同的服务。\n理论上大家可以直接能过 10.0.0.1 或者 10.0.0.2 来访问 AAA 或 BBB 的服务。但如果某一台机器宕机，就没法访问了。要解决这个问题就需要 virtual ip。\n\n首先，我们从 AAA 和 BBB 中选一个作主，另一个作备。然后要求它们互相探测，确保对方都在线。然后给 AAA 和 BBB 同时「分配」一个 virtual ip 10.0.0.100。其他主机需要通过 10.0.0.100 来访问 AAA 或 BBB 提供的服务。\n一般来说，其他主机要访问 10.0.0.100 需要通过 ARP 获取对应的 MAC 地址。如果 AAA 和 BBB 同时应答 ARP 请求，就会产生冲突。因为 10.0.0.100 是 virtual ip，所以，只有主服务器 AAA 才能应答。BBB 收到 ARP 请求后发现 AAA 还活着，就自动闭嘴。\n\n之后所有访问 10.0.0.100 这个 virtual ip 的请求都会发到 AAA。\n如果 AAA 出现故障呢？这个时候其他主机发现 10.0.0.100 不通了，于是发出新的 ARP 请求\n\n同时，BBB 也探测不到 AAA，它知道自己的高光时刻来到了，于是 BBB 大声响应 ARP 请求说「向我开炮」。\n\n总结下来，virtual ip 就是多主机设置相同 ip，但只有一台主机可以在特定条件下响应 arp 请求。\n","tags":["计算机网络"]},{"title":"计网基础知识","url":"/2021/11/16/simpread-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%AA%E9%9A%BE%EF%BC%9F%E4%BA%86%E8%A7%A3%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/","content":"计算机网络、计算机操作系统这两个 “兄弟” 是所有开发岗位都需要 “结拜” 的，不管你是 Java、C++ 还是测试。对于后端开发的童鞋来说，计算机网络的重要性不亚于语言基础，毕竟平时开发经常会和网络打交道，比如：抓个包等等。所以对这一块知识点的准备还是要抱着敬畏之心，不要放过任何一个漏网之题。下面分享下我的学习过程：\n\n看书：对于计算机比较基础的模块，我都是比较推荐找一本经典的书籍来好好学习下，不可以只看面经就去面试了。我一共看了两本书：汤小丹的《计算机操作系统》和《图解 HTTP》。《计算机操作系统》是教科书，所以知识点相对比较基础，覆盖范围也比较广，非科班的学生还是很有必要看一看的。《图解 HTTP》这本书用很多插图将一些知识点讲的通俗易懂，看起来也很快，还是比较推荐的。\n\n做笔记：计算机网络的知识点还是比较多的，需要看书的时候做好笔记，方便复习。而且做笔记的时候可以就这个知识点去百度下，看看有没有自己遗漏的点，再给补充进来。在这里说下，我为什么一直强调做笔记？好处 1：做笔记是第 1 次你对书中的知识点的回顾，加深记忆；好处 2：而且如果你是发表在公关社区的肯定要保证最大限度的正确性，就需要再去看看这个知识点，核对下自己是否有理解偏差和遗漏等，这样就完成了知识点的深挖；好处 3：正在到面试复习的时候，你是不太可能重新看一本书的，那么笔记就显得很重要了，自己做的笔记，复习起来很快，而且最好在笔记里能有一些自己区别于面经的理解。\n\n看面经：经常刷一刷牛客，看看对于计算机网络，面试官们都是怎么问的？很多问题你可能会，但是不懂面试官的问法，也会回答不上来；问到的题目自己是否准备了？而且对于计算机网络和计算机操作系统会因为公司和岗位的不同而有所侧重的，多看看面经就会发现还是有一点规律的，但是这都不是绝对的，最后还要看面你的面试官的喜好。\n\n\n1、谈下你对五层网络协议体系结构的理解？学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。\n\n  1. 应用层\n\n应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。\n\n  2. 运输层\n\n运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的” 是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。\n由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。\n\n  3. 网络层\n\n在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。\n\n  4. 数据链路层\n\n数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。\n在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。\n\n  5. 物理层\n\n在物理层上所传送的数据单位是比特。物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流” 表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。\n2、简单说下每一层对应的网络协议有哪些？计算机五层网络体系中涉及的协议非常多，下面就常用的做了列举：\n\n3、ARP 协议的工作原理？网络层的 ARP 协议完成了 IP 地址与物理地址的映射。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。\n此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。\n4、谈下你对 IP 地址分类的理解？IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。\n每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：\nA 类地址：以 0 开头，第一个字节范围：0~127；\nB 类地址：以 10 开头，第一个字节范围：128~191；\nC 类地址：以 110 开头，第一个字节范围：192~223；\nD 类地址：以 1110 开头，第一个字节范围为 224~239；\nE 类地址：以 1111 开头，保留地址\n5、TCP 的主要特点是什么？\nTCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；\n\n每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；\n\nTCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；\n\nTCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；\n\n面向字节流。TCP 中的 “流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流” 的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。\n\n\n6、UDP 的主要特点是什么？\nUDP 是无连接的；\n\nUDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；\n\nUDP 是面向报文的；\n\nUDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；\n\nUDP 支持一对一、一对多、多对一和多对多的交互通信；\n\nUDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。\n\n\n7、TCP 和 UDP 的区别？TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。\nUDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等。\n8、TCP 和 UDP 分别对应的常见应用层协议有哪些？\n  1. TCP 对应的应用层协议\n\nFTP：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。\nTelnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是 - 纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。\nSMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置 - 中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。\nPOP3：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是 163 邮箱就没有必要先进入网易网站，再进入自己的邮 - 箱来收信）。\nHTTP：从 Web 服务器传输超文本到本地浏览器的传送协议。\n\n  2. UDP 对应的应用层协议\n\nDNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。\nSNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。\nTFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。\n9、详细说下 TCP 三次握手的过程？\n  1. 三次握手\n\nTCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。\n\n最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。\n一开始，B 的 TCP 服务器进程首先创建传输控制块 TCB，准备接受客户端进程的连接请求。然后服务端进程就处于 LISTEN(监听) 状态，等待客户端的连接请求。如有，立即作出响应。\n第一次握手：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。\n第二次握手：B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。\n第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。\n10、为什么两次握手不可以呢？为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就误认为 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。\n对于上面这种情况，如果不进行第三次握手，B 发出确认后就认为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。\n如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。\n11、为什么不需要四次握手？有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？\n我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。\n12、Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。\nSYN 是 TCP / IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符，在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误]）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。\n13、传了 SYN，为什么还要传 ACK？双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。\n14、详细说下 TCP 四次挥手的过程？据传输结束后，通信的双方都可以释放连接。现在 A 和 B 都处于 ESTABLISHED 状态。\n​\n\n第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待 1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。\n第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加 1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待 2) 状态，等待 B 发出的连接释放报文段。\n第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认) 状态，等待 A 的确认。\n第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。\n15、为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？\n为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。\n\n防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。\n\n\n16、为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。\n17、保活计时器的作用？除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。\n服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。\n18、TCP 协议是如何保证可靠传输的？\n数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；\n\n对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；\n\n丢弃重复数据：对于重复数据，能够丢弃重复数据；\n\n应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；\n\n超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；\n\n流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。\n\n\n19、谈谈你对停止等待协议的理解？停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。\n20、谈谈你对 ARQ 协议的理解？\n  自动重传请求 ARQ 协议\n\n停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。\n\n  连续 ARQ 协议\n\n连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\n21、谈谈你对滑动窗口的了解？TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。\nTCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。\n22、谈下你对流量控制的理解？TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n23、谈下你对 TCP 拥塞控制的理解？使用了哪些算法？拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。\n拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。\n为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 (cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。\nTCP 的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。\n\n  慢开始：\n\n慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。\n\n  拥塞避免：\n\n拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。\n\n  快重传与快恢复：\n\n在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。\n没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。\n有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。\n24、什么是粘包？在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。\n\nTCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；\n\n从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。\n\n\n基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。\n接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。\n25、TCP 黏包是怎么产生的？\n  发送方产生粘包\n\n采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。\n\n  接收方产生粘包\n\n接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）\n26、怎么解决拆包和粘包？分包机制一般有两个通用的解决方法：\n\n特殊字符控制；\n\n在包头首都添加数据包的长度。\n\n\n如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。\ntips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。\n27、你对 HTTP 状态码有了解吗？\n  1XX 信息\n\n\n100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。\n\n\n  2XX 成功\n\n\n200 OK\n\n204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。\n\n206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。\n\n\n\n  3XX 重定向\n\n\n301 Moved Permanently ：永久性重定向；\n\n302 Found ：临时性重定向；\n\n303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。\n\n304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。\n\n307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。\n\n\n\n  4XX 客户端错误\n\n\n400 Bad Request ：请求报文中存在语法错误。\n\n401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。\n\n403 Forbidden ：请求被拒绝。\n\n404 Not Found\n\n\n\n  5XX 服务器错误\n\n\n500 Internal Server Error ：服务器正在执行请求时发生错误；\n\n503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n\n28、HTTP 状态码 301 和 302 代表的是什么？有什么区别？301，302 都是 HTTP 状态的编码，都代表着某个 URL 发生了转移。\n\n  区别：\n\n301 redirect: 301 代表永久性转移（Permanently Moved）\n302 redirect: 302 代表暂时性转移（Temporarily Moved）\n29、forward 和 redirect 的区别？Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。\n直接转发方式（Forward）：客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。\n间接转发方式（Redirect）：实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。\n\n  举个通俗的例子：　\n\n直接转发就相当于：“A 找 B 借钱，B 说没有，B 去找 C 借，借到借不到都会把消息传递给 A”；\n间接转发就相当于：”A 找 B 借钱，B 说没有，让 A 去找 C 借”。\n30、HTTP 方法有哪些？客户端发送的 请求报文 第一行为请求行，包含了方法字段。\n\nGET：获取资源，当前网络中绝大部分使用的都是 GET；\n\nHEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；\n\nPOST：传输实体主体\n\nPUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。\n\nPATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。\n\nOPTIONS：查询指定的 URL 支持的方法；\n\nCONNECT：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\n\nTRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。\n\n\n31、说下 GET 和 POST 的区别？GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。\n本质区别：GET 只是一次 HTTP 请求，POST 先发请求头再发请求体，实际上是两次请求。\n\n从功能上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；\n\n从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；\n\n从请求参数形式上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母 / 数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串 (如果是空格，转换为 +，如果是中文 / 其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的 请求体 中；\n\n就安全性而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；\n\n从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。\n\n\n32、在浏览器中输入 URL 地址到显示主页的过程？\nDNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析 (此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；\n\nTCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；\n\n发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；\n\n服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；\n\n浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。\n\n连接结束。\n\n\n33、DNS 的解析过程？\n主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文 (即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。\n\n本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。\n\n\n34、谈谈你对域名缓存的了解？为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。\n由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。\n不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。\n35、谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。\n而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码\nConnection:keep-alive\n\n在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。\nKeep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\n36、谈下 HTTP 1.0 和 1.1、1.2 的主要变化？\n  HTTP1.1 的主要变化：\n\n\nHTTP1.0 经过多年发展，在 1.1 提出了改进。首先是提出了长连接，HTTP 可以在一次 TCP 连接中不断发送请求。\n\n然后 HTTP1.1 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，post 请求默认就是这样做的。\n\nHTTP1.1 的 host 字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。\n\n\n\n  HTTP2.0 的主要变化：\n\n\nHTTP2.0 支持多路复用，同一个连接可以并发处理多个请求，方法是把 HTTP 数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP 请求顺序到达；\n\nHTTP2.0 支持服务端推送，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；\n\nHTTP2.0 压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少；\n\nHTTP2.0 适用于 HTTPS 场景，因为其在 HTTP 和 TCP 中间加了一层 SSL 层。\n\n\n37、HTTPS 的工作过程？\n客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；\n\n服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；\n\n客户端收到网站的证书之后要做下面的事情：\n\n\n\n  3.1 验证证书的合法性；\n  3.2 果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；\n  3.3 用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。\n\n\n服务器接收到客户端传送来的信息，要做下面的事情：\n\n\n  4.1 用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致；\n  4.2 使用密钥加密消息；\n\n\n如果计算法 hash 值一致，握手成功。\n\n38、HTTP 和 HTTPS 的区别？\n开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；\n\n资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；\n\n端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；\n\n安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。\n\n\n39、HTTPS 的优缺点？\n  优点：\n\n\n使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\nHTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；\n\nHTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。\n\n\n\n  缺点：\n\n\nHTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；\n\nHTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；\n\nSSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；\n\nSSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；\n\nHTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。\n\n\n40、什么是数字签名？为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。\n41、什么是数字证书？对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。\n42、什么是对称加密和非对称加密？对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。\n非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。\n由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。\n","tags":["计算机网络"]},{"title":"精选链接","url":"/2023/01/31/%E9%87%8D%E8%A6%81%E9%93%BE%E6%8E%A5/","content":"中国科学技术大学开源镜像资源：http://mirrors.ustc.edu.cn/\n清华大学开源镜像： https://mirrors.tuna.tsinghua.edu.cn/\n各种版本的git:  https://npm.taobao.org/mirrors/git-for-windows/\n人工智能还能最新论文和代码：  https://paperswithcode.com/sota\n各种版本JDK:   https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html\n在线将Excel换成MarkDown：https://tableconvert.com/excel-to-markdown\nC++教程    ：https://hackingcpp.com/\n莫凡Python：  https://mofanpy.com/\n英特尔® 至强® 可扩展处理器 - 查看全新一代至强处理器：\nhttps://www.intel.cn/content/www/cn/zh/products/details/processors/xeon/scalable.html\n！！英特尔® 产品规格对比 至强处理器！！：https://ark.intel.com/content/www/cn/zh/ark/compare.html?productIds=192478,192447,193394,193381\n英特尔工具和实用程序：https://www.intel.cn/content/www/cn/zh/support/topics/utility-tools.html\nVMware常用软件ISO下载汇总（2021年3月更新） – 丁辉博客：https://www.dinghui.org/vmware-iso-download.html\n固件和驱动相关：https://datacentersupport.lenovo.com/cn/zh/\nLenovo硬件信息：https://lenovopress.com/#sort=relevance\n联想ThinkSystem机器安装2008R2详细教程 - 猫先生的日常点滴：https://www.mr-mao.cn/archives/thinksystem-2008.html\n服务器配置的网站和工具： https://dcsc.lenovo.com/#/\n英特尔CPU EVC矩阵（VMware增强的vMotion兼容性） :   https://www.virten.net/2013/04/intel-cpu-evc-matrix/\nvMotion兼容性（EVC）处理器支持:     https://kb.vmware.com/s/article/1003212\nvmware 中EVC是做什么用的？能起到什么样的效果？_百度知道：   https://zhidao.baidu.com/question/426142671976251772.html\nCreating a vSAN Cluster without a vCenter Server | MrVSAN：  https://www.mrvsan.com/creating-vsan-cluster-without-vcenter-server/\nMSDN原版之家：https://msdn.pe8.com/win11.html\nMSDN老版：http://www.msdn1.cn/index.html\nMSDN新版：http://xin.msdn1.cn/\n","tags":["学习"]},{"title":"演示如何确定英特尔 ® 处理器的数量","url":"/2021/11/08/%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E8%8B%B1%E7%89%B9%E5%B0%94%20%C2%AE%20%E5%A4%84%E7%90%86%E5%99%A8/","content":"\n\n\nDocumentation\nContent Type Identify My Product\nArticle ID 000006059\nThere are different options to get the name and the number of the Intel® Processors. \nThe methods below apply on all Intel® processors such as Intel® Core™, Intel® Xeon®, Intel® Pentium®, Intel® Celeron®, and Intel Atom® processors. \nOption 1: Operating SystemWindows*\n Press on the Windows key  on your keyboard and start typing System, choose System Information which will show Processor information with the name, number, and speed of the processor.\nIf the Windows key is not available on your keyboard, using your mouse, go to the Windows icon located on the bottom-left corner of your screen, right-click, and choose System. Look up the processor’s name and number in the Processor information. The examples below show the case when choosing System Information and System.  \n\nLinux*Type the following command\nlscpu | grep “Model name”\nSee examples:\n\n\nMAC OSType the following command in the terminal app\nsysctl -a | grep machdep.cpu.brand_string\nSee an example:\n\nOption 2: Packaging BoxIf you bought an Intel® Boxed Processor, the information about the number of the processor along with other information like the batch number (FPO) and the serial number (ATPO) are listed on the packaging box.\n\nOption 3: Markings on the ProcessorsThe name and number of the Intel® Processor is listed on the top of the processor. See the example below.\n\nWatch this video to see how to identify your Intel® Processor name and number.\nIdentify the Generation for your Intel® Core™ Processors\nYou can also identify the generation of the processor if your processor is Intel® Core™. The generation of the processor is the first number after i9, i7, i5, or i3.\nHere are some examples:\n\n  Intel® Core™ Processor i7-10710U Processor is 10th generation because the number 10 is listed after i7.\n  Intel® Core™ Processor i9-9900 Processor is 9th generation because the number 9 is listed after i9.\n  Intel® Core™ Processor i7-9850H Processor is 9th generation because the number 9 is listed after i7.\n  Intel® Core™ Processor i5-8600 Processor is 8th generation because the number 8 is listed after i5.\n  Intel® Core™ Processor i3-7350K Processor is 7th generation because the number 7 is listed after i3.\n  Intel® Core™ Processor i5-6400T Processor is 6th generation because the number 6 is listed after i5.\n\n\nClose Window\n","tags":["VMware"]},{"title":"为松江医院开两台虚拟机","url":"/2021/05/02/simpread-%E4%B8%BA%E6%9D%BE%E6%B1%9F%E5%8C%BB%E9%99%A2%E5%BC%80%E9%80%9A%E4%B8%A4%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%20Windows%20Server%202016_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"需求：\n服务部署计划&nbsp;Windows 操作系统配置编号项目数量（台）操作系统说明&nbsp;1Zookeeper、ElasticSearch、分析服务、规则维护、前置审方（应用）1Windiws注册中心、应用等&nbsp;CPU：3.2GHz * 4 核以上内存：内存 32GB 及以上 ，DDR4 RDIMM硬盘：容量 500G 及以上，SAS 硬盘通讯端口：双端口千兆以太网2数据库集群1Windiws数据库服务&nbsp;合计2　　&nbsp;\n\n\n\n 图 3\n\n\n\n\n\n服务不可用，估计啥服务宕了。\n\n\n\n 查看 Vcenter 报错日志\n\n\n\n\n 只是网卡开通了 DHCP，但是网络中没有 DHCP 服务器。IP 目前为回环地址。\n\n\n\n网关：192.168.5.1(通常)，只要不练外网可以不写。 随便我的，也可以是 192.168.5.254.\n网关就是一个边界。\n\n\n注册中心和应用 \n\n\n开启远程桌面\n https://jingyan.baidu.com/article/154b463136661728ca8f4125.html\n或如下\n\n\n\n安装 VMware tools\n\n","tags":["VMware"]},{"title":"联想SR630服务器","url":"/2021/11/12/simpread-%E8%81%94%E6%83%B3%20SR630%20%E6%9C%8D%E5%8A%A1%E5%99%A8_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"\n \n \n \n \n \n \n\n","tags":["服务器"]}]