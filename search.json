[{"title":"Linux的学习","url":"/2021/05/04/Linux/","content":"Linux学习： https://www.shiyanlou.com/courses/1 http://linuxcommand.org/tlcl.php http://www.imooc.com/read/39 https://fanzhongwei.com/linux/shadowsocks.html\n","tags":["Linux"]},{"title":"important-link","url":"/2021/11/07/important-link/","content":"link:\nVMware不同版本的对比：https://www.vmware.com/products/vsphere.htmlVMware iso lenovo OEM下载地址：https://vmware.lenovo.com/content/custom_iso/VMware版本KB：https://kb.vmware.com/s/article/2143838 （vcenter）https://kb.vmware.com/s/article/2143832（ESXi）VMware vcenter下载：需要vmware官网账号联想机型兼容性查询：https://lenovopress.com/osigVMware兼容性列表查询：http://partnerweb.vmware.com/comp_guide2/search.php?action=base&amp;deviceCategory=ioLenovo固件下载地址：https://datacentersupport.lenovo.com/cn/en/\n","tags":["VMware"]},{"title":"K8S学习","url":"/2021/05/04/k8s-%E7%BA%AA%E6%B3%BD/","content":"以下是我个人对学习 k8s 的意见，很多资料都涉及网络（自行解决）和英文（google翻译）：\n\n仅以 k8s 官方文档作为参考手册，尽量不看中文博客（具有局限性和滞后性，多数都有错误）官方文档： https://kubernetes.io/docs/home/\n\n（初步了解它能做什么）先了解基本概念，然后动手实践\n  建议用官方的 tutorial 做实践内容：https://kubernetes.io/docs/tutorials/  建议用本地环境做实践环境，可以用 Minikube 或者 Kind, 我建议用kind：https://github.com/kubernetes-sigs/kind  建议把 https://www.katacoda.com/ 的实验做一遍\n\n进一步了解Kubernetes的架构、理念及组件\n  3.1 部署方案（下面都是针对on-premise方案，如果能用 cloud，建议优先考虑cloud）：   只建议用官方文档推荐的方案\n\n\nhttps://kubernetes.io/docs/setup/production-environment/\n多数情况下我都建议用 kubeadm 做部署         \n\n  如果有兴趣可以看 https://github.com/kelseyhightower/kubernetes-the-hard-way，可以深入理解 k8s 的组件及组件关系大规模部署交付建议考虑 kubespray\n 3.2 较为系统的了解 k8s 的 concepts、glossary，这些在官方文档中都有，建议自行查找（用于练习文档查阅能力，k8s的CKA认证就是开卷考试，所有内容都可以在官方文档中找到参考）\n\n 3.3 继续多做练习，比如官网的 tasks\n\n\n了解 K8S 的生态，包括 CRI、CNI、CSI、可观测性等，建议通过 CNCF 全景图找感兴趣的部分，具体情况可以找我沟通。 https://landscape.cncf.io/\n\n多看k8s 博客（https://kubernetes.io/blog/）及cncf博客（ https://www.cncf.io/blog/ ），都是大厂分享理念和实践\n\n\n","tags":["K8S"]},{"title":"Python Day0","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day0%EF%BC%882021.2.23%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"今天玲姐带我们学习 Python，启动。\n讲明了学习的计划与方法，并且分享了相关的文件。\n建了微信群众，从此每天写点代码，进行 Python 学习。\n玲姐:1.gitlab 地址是 gitlab.vthink.cloud没有注册过的，先注册一下，注册完成后，我会拉到 SRE group，然后就可以下载代码了2. learning-python 库的地址是：http://gitlab.vthink.cloud/sre/learning-python.git  \n \nAnaconda:  https://www.anaconda.com/products/individual https://www.anaconda.com/products/individual \nPycharm:  https://www.jetbrains.com/pycharm/download/#section=windows https://www.jetbrains.com/pycharm/download/#section=windows\n配置好了编辑器与 Gitlab 仓库\n建立了 SRE group，用 git 提交代码。\n\n其实以前学过 Python，但是都是皮毛。这次趁着有人带，想好好学习一下。\n\n","tags":["Python"]},{"title":"Python Day2","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day2%EF%BC%882021.2.25%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"# 标准数据类型import math &quot;&quot;&quot;Number(数字)String(字符串)List(列表)Tuple(元组)Set(集合)Dictionary(字典)可变数据（3个）：List(列表)，Dictionary(字典)，Set(集合)代码风格整理： Ctrl + Alt +l&quot;&quot;&quot; a, b, c, d &#x3D; 20, 5.5, True, 4 + 3j print(type(a)), print(type(b)), print(type(c)), print(type(d))# # ------------------------------------------------------------------------## # 此外还可以用 isinstance 来判断：# a &#x3D; 111# isinstance(a, int)## # isinstance 和 type 的区别在于：# &#39;&#39;&#39;# type()不会认为子类是一种父类类型。# isinstance()会认为子类是一种父类类型。# &#39;&#39;&#39;### class A:#     pass### class B(A):#     pass### isinstance(A(), A)## type(A()) &#x3D;&#x3D; A## isinstance(B(), A)## type(B()) &#x3D;&#x3D; A# ------------------------------------------------------------------------# # 数值运算： 5 + 4  # 加法 4.3 - 2  # 减法\n\n\n\n","tags":["Python"]},{"title":"Python Day1","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day1%EF%BC%882021.2.24%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"# 试试变量x &#x3D; 3print(x) 幸运数 &#x3D; 1997 print(幸运数) name &#x3D; &#39;yixin&#39;print(name) # 试试基本的数据类型# 整数（int) 浮点型（float） 字符串（str) 布尔值（bool) # 1, 空（NoneTypesome &#x3D; Noneprint(type(some)) # 2, 布尔型（bool)some &#x3D; Trueprint(type(some)) # 3,整形（int）some &#x3D; 12345print(type(some)) # 4,浮点型（float）some &#x3D; 12.345print(type(some)) # 字符串（str）some &#x3D; &#39;abc&#39;print(type(some)) print(type(8)) counter &#x3D; 100  # 整型变量miles &#x3D; 1000.0  # 浮点型变量name &#x3D; &quot;runoob&quot;  # 字符串 print(counter)print(miles)print(name)  x &#x3D; 3y &#x3D; 5x,y &#x3D; y,x print(x,y) # 字符串的特性# 1,Python中单引号和双引号使用完全相同m &#x3D; &#39;abc&#39;n &#x3D; &quot;abc&quot;q &#x3D; (m &#x3D;&#x3D; n)print(q) # 2,使用三引号 （&#39;&#39;&#39;或 &#39;&#39;&#39;）some &#x3D; &#39;&#39;&#39; abc def gbk lll&#39;&#39;&#39;print(some) # 3，转义符’\\‘some &#x3D; &#39;abc\\n def&#39;print(some) # 4,自然字符串，通过在字符串前加r或者R，可以忽略转义符some &#x3D; r&#39;abc\\n def&#39;print(some) # 5，python 允许处理unicode字符串，加前缀u或者U \n\n\n\n","tags":["Python"]},{"title":"Python Day3","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day3%EF%BC%882021.2.26%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"# Python的数据结构有三种:列表、元组和字典  # 列表（list）# 初始化：[],[1,3,7],[&#39;a&#39;,&#39;c&#39;],[1,&#39;s&#39;,&#39;des&#39;,256]等# 1，增加：append(value),extend(list2),insert(i,value) mylist &#x3D; [1, 3, 7]mylist.append(&#39;a&#39;)mylist.insert(2, &#39;fff&#39;)print(mylist) newList &#x3D; [&#39;abc&#39;, &#39;kkk&#39;, 123]mylist.extend(newList)print(mylist) # 2,删除：pop([i]）,remove（value）# i 可以是负数# i 超出范围会报out of range错误# remove只会移除第一个遇到的值# pop 有返回值，remove没有 mylist &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]a &#x3D; mylist.pop()print(a)print(mylist)b &#x3D; mylist.pop(2)print(b)print(mylist)c &#x3D; mylist.pop(-1)print(c)print(mylist)newList &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]k &#x3D; newList.remove(&#39;b&#39;)print(k)print(newList) # 3.查询:index(value, [start, [stop]])　　# ---返回列表中第一个出现的值为value的索引，如果没有，则异常 ValueError mylist &#x3D; [1, 2, 5]a &#x3D; mylist.index(2)print(a)&#39;b &#x3D; mylist.index(3)  # 此处会报错，返回以下信息&#39; # Traceback (most recent call last):#   File &quot;C:&#x2F;Users&#x2F;mengyx3&#x2F;Desktop&#x2F;Python learning&#x2F;learning-python&#x2F;mengyixin&#x2F;day3.py&quot;, line 44, in &lt;module&gt;#     b &#x3D; mylist.index(3)# ValueError: 3 is not in list &quot;&quot;&quot;4.修改:list没有直接修改对应元素的方法，   只能先找到目标元素所在位置，然后直接赋值&quot;&quot;&quot; mylist &#x3D; [&#39;a&#39;, &#39;k&#39;, &#39;m&#39;]myIndex &#x3D; mylist.index(&#39;k&#39;)mylist[myIndex] &#x3D; &#39;fff&#39;print(mylist) # 5.排序:sort() mylist &#x3D; [6, 23, 7, 39, 1, 90]mylist.sort()print(mylist) # 6.反转：reverse() mylist &#x3D; [&#39;f&#39;, &#39;m&#39;, &#39;a&#39;, &#39;z&#39;]mylist.reverse()print(mylist) # 清空：clear() mylist &#x3D; [1, 2, 4]mylist.clear()print(mylist) \n\n\n","tags":["Python"]},{"title":"Python Day4","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day4%EF%BC%882021.3.1%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"# 字典（dict）# 　定义:键值对集合## 　　初始化:&#123;&#125;, &#123;&#39;1&#39; : &#39;abc&#39;, &#39;2&#39; : &#39;def&#39;&#125;## 　　1.增加:单个数据直接赋值 #    update(dict2)　　---把dict2的元素加入到dict中去，键字重复时会覆盖dict中的键值 myd &#x3D; &#123;&#125; myd[&#39;1&#39;] &#x3D; &#39;one&#39; print(myd) myd1 &#x3D; &#123;1: &#39;one&#39;, 2: &#39;two&#39;&#125;myd2 &#x3D; &#123;1: &#39;one&#39;, 3: &#39;three&#39;&#125;myd1.update(myd2)print(myd1) #     2,删除:pop(key, [default])　　---若字典中key键存在，删除并返回dict[key]，若不存在，且未给出default值，引发KeyError异常## 　　　　　popitem()　　---删除任意键值对，并返回该键值对，如果字典为空，则产生异常KeyError## 　　　　　clear()  ---略 myd &#x3D; &#123;1: &quot;one&quot;, 2: &quot;two&quot;, 3: &quot;there&quot;&#125;item &#x3D; myd.pop(1)print(item)print(myd)newItem &#x3D; myd.popitem()print(newItem) print(myd) #     3,查询：get(key,[default])　　---返回字典dict中键key对应值，如果字典中不存在此键，则返回default 的值(default默认值为None)## 　　　　　　items()　　---返回一个包含字典中(键, 值)对元组的列表## 　　　　　　keys()　　---返回一个包含字典中所有键的列表## 　　　　　　values()　　---返回一个包含字典中所有值的列表#myd &#x3D; &#123;1: &quot;one&quot;, 2: &quot;two&quot;, 3: &quot;there&quot;&#125;print(myd.get(2)) print(myd.items()) print(myd.keys())print(myd.values())\n\n\n","tags":["Python"]},{"title":"Python Day5","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day5%EF%BC%882021.3.2%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"集合\nbasket &#x3D; &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;&#125;print(basket)  # 这里演示的是去重功能&#123;&#39;orange&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;&#125;&#39;orange&#39; in basket  # 快速判断元素是否在集合内True&#39;crabgrass&#39; in basketFalse # 下面展示两个集合间的运算. a &#x3D; set(&#39;abracadabra&#39;)b &#x3D; set(&#39;alacazam&#39;)a&#123;&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125;a - b  # 集合a中包含而集合b中不包含的元素&#123;&#39;r&#39;, &#39;d&#39;, &#39;b&#39;&#125;a | b  # 集合a或b中包含的所有元素&#123;&#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;&#125;a &amp; b  # 集合a和b中都包含了的元素&#123;&#39;a&#39;, &#39;c&#39;&#125;a ^ b  # 不同时包含于a和b的元素&#123;&#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;&#125;","tags":["Python"]},{"title":"Python Day6","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day6%EF%BC%882021.3.3%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"函数\n# 函数# 函数是可重复调用的代码段，能提高代码的复用率。 # 无参数def print_hello():    print (&quot;hello&quot;)  print_hello()  # 带参数def print_str(s):    print(s)    return s * 2  print_str(&quot;fuck&quot;)  # 带默认参数def print_default(s&#x3D;&quot;hello&quot;):    print(s)  print_default()print_default(&quot;default&quot;)  # 不定长参数def print_args(s, *arg):    print(s)    for a in arg:        print(a)    return  print_args(&quot;hello&quot;)print_args(&quot;hello&quot;, &quot;world&quot;, &quot;1&quot;)  # 参数次序可以变def print_two(a, b):    print(a, b)  print_two(a&#x3D;&quot;a&quot;, b&#x3D;&quot;b&quot;)print_two(b&#x3D;&quot;b&quot;, a&#x3D;&quot;a&quot;)","tags":["Python"]},{"title":"Python Day7","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%20-Day7%EF%BC%882021.3.4%EF%BC%89_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"集合# 模块# 通常来说，比较正规的工程不会把所有代码放在一个py文件里，我们会把代码拆成各个模块，分别调用。对python来说，拆成各个模块可以看做拆成各个py文件。  # 搜索路径# 通常来说，同文件夹下的py文件可以直接import。 def print_hello():    print(&quot;hello&quot;)  # 我们把这个保存至hello.pyimport hello hello.print_hello() # 在run.py里import，然后调用print_hello() 目录结构# .....&#x2F; hello.pyrun.py # hello.py和run.py在同一目录下，可以直接import 如果在不同路径下，可以在sys.path里手动加入你想import的路径 import sys sys.path.append(&#39;&#x2F;home&#x2F;yixin&#x2F;course&#39;)import hello hello.print_hello()# 如果run.py不在&#x2F;home&#x2F;yixin&#x2F;course文件夹下，手动加入这个路径，就可以import这个路径下的hello.py # ----------------------------------------------------------------------------------------------------# 通常一个工程不可能只有一层目录结构，并且也不会一个一个path去append到sys里，常用的做法是包，一个目录及其子目录组成的一个包（可以看做一个库）。 举个例子#&quot;&quot;&quot;&#x2F;home&#x2F;yixin&#x2F;course├── __init__.py├── __init__.pyc├── m1│   ├── b.py│   ├── b.pyc│   ├── __init__.py│   ├── __init__.pyc│   └── m1_1│       ├── a.py│       ├── a.pyc│       ├── __init__.py│       └── __init__.pyc└── m2    ├── __init__.py    └── run.py&quot;&quot;&quot;","tags":["Python"]},{"title":"Python学习资料","url":"/2021/05/02/simpread-Python%20%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"https://edu.csdn.net/course/detail/25411\n复制粘贴在浏览器打开\n好几个小节，目录可选\nhttps://blog.csdn.net/weixin_44888486/article/details/102902402\n上面针对 Python 基础的内容总结\n包含环境的搭建及安装步骤\n环境安装：\npython 及 pycharm 安装包，已经上传了\n根据自己的电脑系统选择下载就好了哈\n链接: https://pan.baidu.com/s/1tYITGogujLZxm3C-W8SlzQ\n提取码: n2p2\nhttps://pan.baidu.com/s/1G9-2Tv8wSbsikTvs7QzGcg     Mac\nPython 的安装：https://blog.csdn.net/weixin_43495473/article/details/103559812\nPycharm 的安装：https://blog.csdn.net/weixin_43495473/article/details/103560198\n网盘里是安装包，下面是安装步骤\nPython 零基础入门\n从游戏开始的 “0 基础 Python 学习之路”【5-27】\n观看链接：https://live.csdn.net/room/CSDNedu/NgQZAWBq\nPython 爬虫\nPython 分布式爬虫 + 数据分析实战【5-26】\n观看链接：https://live.csdn.net/room/CSDNedu/YceylATu\nPython 自动化\nPython 自动化办公【6-17】\n观看链接：https://live.csdn.net/room/CSDNedu/w7Ifsyx5\nPython 数据分析\nPython 量化分析预测股灾拐点【6-5】\n观看链接：https://live.csdn.net/room/CSDNedu/VNqpTJ0d\n数据分析师必备的的软硬技能【6-16】\n观看链接：https://live.csdn.net/room/CSDNedu/Vc9QDqAH\n提升 Python 数据处理速度四种方式【6-23】\n观看链接：https://live.csdn.net/room/CSDNedu/TN5hZHwn\n从数据专员到行业 “叫兽”，必备经历【6-12】\n观看链接：https://live.csdn.net/room/CSDNedu/fZUy43xw\n用 40 行 Python 代码实现抖音 AI 换脸【5-29】\n观看链接：https://live.csdn.net/room/CSDNedu/A9jwFMBm\n用 2 个小时写一个 CSDN【6-10】\n观看链接：https://live.csdn.net/room/CSDNedu/BrqBSfMn\n0 基础快速上手推荐系统【6-22】\n观看链接：https://live.csdn.net/room/CSDNedu/5BDkcYfI\n实战：CSDN 站内搜索技术关键词\n观看链接：https://live.csdn.net/room/CSDNedu/rq27wEHR\n文档资料链接:\n https://pan.baidu.com/s/1HtKPV44xsTAq0L69GqkVzA\n提取码: jhpv\n","tags":["Python"]},{"title":"VMWare vCenter Server 的安装","url":"/2021/05/02/simpread-VMWare%20vCenter%20Server%20%E7%9A%84%E5%AE%89%E8%A3%85_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"从 ESXI 中，删除 Vcenter 虚拟机本身，然后全部进行重装一遍。熟悉流程2020/7/22\n具体虚拟机进入操作系统的密码\n\n","tags":["VMware"]},{"title":"VMWare Esxi 的安装","url":"/2021/05/02/simpread-VMware-ESXi%20%E7%9A%84%E5%AE%89%E8%A3%85_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"密码账号:USERID/PASSW0RD密码的 0 是数字零\n\n\n  选择 ESXI 的镜像，挂载成功。\n\n\n然后重新启动，选择驱动引导：\n在合适的时候按 F1，出现如下界面\n\n按空格选择设置 IP。之后就可以访问了。\n","tags":["VMware"]},{"title":"VMWare VSAN 的安装","url":"/2021/05/02/simpread-VSAN%20%E7%9A%84%E5%AE%89%E8%A3%85_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"\n本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net\n\n将 VCenter 安装在任何一台主机上（192.168.30.2，192.168.30.3，192.168.30.4）这周（7 月 28 号）教我了 VSAN 的知识，交我一个任务作业。他给我了 3 个 XCC 地址，有 3 台装了 ESXI 的主机，让我装 VSAN。跟以往不同的地方是，这次让我把 Vcenter 装在这三台主机中的其一，主机里边。以往都是装在主机外的，用来管理主机。就遇到这个问题。\n2020 年 0802\n刚开始找不到 VSAN，6.5 有 html5 和 flash 两种访问方式，html5 在 6.5 中功能不全。\n\n","tags":["VMware"]},{"title":"Vim","url":"/2021/05/02/simpread-Vim_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"按 [i] 键可以进入到编辑状态，显示 insert 字眼 OK。\n直接按 esc 退出编辑状态，然后输入 ：wq !  保存退出\n：wq ！ 保存后退出\n：w        表示保存不退出\n：q !      表示退出不 保存 \n： ！      表示强制退出忙，或者按 ctrl + z 强制退出也可！\n","tags":["Linux"]},{"title":"VSAN6.7 的安装","url":"/2021/05/02/simpread-VSAN6.7%20%E7%9A%84%E5%AE%89%E8%A3%85_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"\n图 1\n\n 图 2\n 图 3\n 图 4\n 图 5\n 图 6\n 图 7\n 图 8\n 图 9\n 图 10\n 图 11\n 图 12\n 图 13\n 图 14\n 图 15\n\n选择要安装在哪个主机上。\n\n 图 16\n 图 17\n\n注意，可以选择安装在包含目标主机的新 VSAN 群集上\n\n 图 18\n 图 19\n\n这是因为，因为之前的磁盘上面已经有 VSAN 的信息了，得去 ESXI 后台把这些磁盘的分区删了\n\n 图 20\n\n点击了按照容量降序\n\n 图 21\n\n从上面往下面弄，右键删除磁盘分区，下面三个不用管就行了。只弄上边 8 个，也就是 6 个 HDD 和 2 个 960g 的 SSD.\n\n 图 22\n 图 23\n\n其他两台也要这么做一下。像这种就是需要删除的。\n\n 图 24\n\n擦除后是这个样子的。\n\n 图 25\n\n 然后重新进入 Vcenter 安装第 8 步，发现有磁盘可选。\n\n 图 26\n\n检查一下，是不是八块硬盘。这里只会显示 30.11 这台机器（Vcenter 是装在 192.168.30.11 的）\n\n 图 27\n 图 28\n\n这个时候注意，需要设置一下 VM network VLAN ，在 30.11（装 VC 的主机）主机的后台，\n\n​\n图 29\n 图 30\n\n其他地方不用管，刷新一下就 OK。\n\n 图 31\n 图 32\n 图 33\n 图 34\n 图 35\n 图 36\n 图 37\n 图 38\n 图 39\n\n完了就会发现浏览器里边没有 “不安全” 的字样了。\n\n 图 40\n\n目前准备把其他的主机也加载进来。\n\n 图 41\n\n加完三台主机后发现一点问题，30.11 机器报错。其他 VSAN 网络不可用。\n\n 图 42\n","tags":["VMware"]},{"title":"go语言学习","url":"/2021/05/02/simpread-go%20%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"第二天这里加了命令行参数，他是以输出的形式输出了命令行参数。\n[C:\\Users\\mengyx3\\AppData\\Local\\Temp\\go-build833694214\\b001\\exe\\hello_world.exe 是二进制的命令， chao 是命令行参数了。\n\npackage mainimport (   “fmt”   “os”)func main() {   fmt.Println(os.Args)   fmt.Println(“Hello World”)   os.Exit(-1)}\n运行程序，我们看到命令行参数被放在了 hello world 的后面。\n编写测试程序\n\n 源码文件以_test 结尾：xxx_test . go\n 测试方法名以 Test 开头：func TestXXX(t *testing.T) {…}\n\n斐波那契数列\n也可以改写成\n还可以改写成\n刚刚都是用的 fmt.Print 来输出的，其实在单元测试可以用 t.Log 来输出。\nGo 语言里交换变量的值写法简洁，可以在一句赋值语句里边 对多个变量进行赋值。\n位运算\n位运算结果这里，应该是三个 true , 也就是 true true true 。而不是 true false true ?\n当前播放：05 | 变量，常量以及与其他语言的差异\n刚刚上面是 a:=7 0111     我们换成 a:=1 0001\n第三天\n 数据类型和指针，不支持隐性的数据类型转换。需要显性数据类型转换。\n\n Go 语言可以支持指针类型，但是不支持指针运算。\n\n Go 的字符串是值类型，默认初始化零值是空字符串，而不是空。\n\n\n第四天用 == 比较数组\n\n 相同维数且含有相同个数元素的数组才可以比较\n\n 每个元素都相同才相等。\n\n 按位置零\n\n\n第五天\n 条件和循环\n\n","tags":["golang"]},{"title":"Windows 内核和 Linux 内核谁更复杂","url":"/2021/05/04/simpread-Windows%20%E5%86%85%E6%A0%B8%E5%92%8C%20Linux%20%E5%86%85%E6%A0%B8%E8%B0%81%E6%9B%B4%E5%A4%8D%E6%9D%82_/","content":"两个系统的内核结构不一样，没什么可比性，都有各自的优势。\nLinux 内核和 Windows 内核有什么区别？\n内核什么是内核呢？\n计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，如果每个应用都要和这些硬件设备对接通信协议，那这样太累了，所以这个中间人就由内核来负责，让内核作为应用连接硬件设备的桥梁，应用程序只需关心与内核交互，不用关心硬件的细节。\n\n内核有哪些能力呢？\n现代操作系统，内核一般会提供 4 个基本能力：\n\n  管理进程、线程，决定哪个进程、线程使用 CPU，也就是进程调度的能力；\n  管理内存，决定内存的分配和回收，也就是内存管理的能力；\n  管理硬件设备，为进程与硬件设备之间提供通信能力，也就是硬件通信能力；\n  提供系统调用，如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。\n\n内核是怎么工作的？\n内核具有很高的权限，可以控制 cpu、内存、硬盘等硬件，而应用程序具有的权限很小，因此大多数操作系统，把内存分成了两个区域：\n\n  内核空间，这个内存空间只有内核程序可以访问；\n  用户空间，这个内存空间专门给应用程序使用；\n\n用户空间的代码只能访问一个局部的内存空间，而内核空间的代码可以访问所有内存空间。因此，当程序使用用户空间时，我们常说该程序在用户态执行，而当程序使内核空间时，程序则在内核态执行。\n应用程序如果需要进入内核空间，就需要通过系统调用，下面来看看系统调用的过程：\n\n内核程序执行在内核态，用户程序执行在用户态。当应用程序使用系统调用时，会产生一个中断。发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。\nLinux 的设计Linux 的开山始祖是来自一位名叫 Linus Torvalds 的芬兰小伙子，他在 1991 年用 C 语言写出了第一版的 Linux 操作系统，那年他 22 岁。\n完成第一版 Linux 后，Linux Torvalds 就在网络上发布了 Linux 内核的源代码，每个人都可以免费下载和使用。\nLinux 内核设计的理念主要有这几个点：\n\n  _MutiTask_，多任务\n  _SMP_，对称多处理\n  _ELF_，可执行文件链接格式\n  _Monolithic Kernel_，宏内核\n\nMutiTaskMutiTask 的意思是多任务，代表着 Linux 是一个多任务的操作系统。\n多任务意味着可以有多个任务同时执行，这里的「同时」可以是并发或并行：\n\n  对于单核 CPU 时，可以让每个任务执行一小段时间，时间到就切换另外一个任务，从宏观角度看，一段时间内执行了多个任务，这被称为并发。\n  对于多核 CPU 时，多个任务可以同时被不同核心的 CPU 同时执行，这被称为并行。\n\nSMPSMP 的意思是对称多处理，代表着每个 CPU 的地位是相等的，对资源的使用权限也是相同的，多个 CPU 共享同一个内存，每个 CPU 都可以访问完整的内存和硬件资源。\n这个特点决定了 Linux 操作系统不会有某个 CPU 单独服务应用程序或内核程序，而是每个程序都可以被分配到任意一个 CPU 上被执行。\nELFELF 的意思是可执行文件链接格式，它是 Linux 操作系统中可执行文件的存储格式，你可以从下图看到它的结构：\n\nELF 把文件分成了一个个分段，每一个段都有自己的作用，具体每个段的作用这里我就不详细说明了，感兴趣的同学可以去看《程序员的自我修养——链接、装载和库》这本书。\n另外，ELF 文件有两种索引，Program header table 中记录了「运行时」所需的段，而 Section header table 记录了二进制文件中各个「段的首地址」。\n那 ELF 文件怎么生成的呢？\n我们编写的代码，首先通过「编译器」编译成汇编代码，接着通过「汇编器」变成目标代码，也就是目标文件，最后通过「链接器」把多个目标文件以及调用的各种函数库链接起来，形成一个可执行文件，也就是 ELF 文件。\n那 ELF 文件是怎么被执行的呢？\n执行 ELF 文件的时候，会通过「装载器」把 ELF 文件装载到内存里，CPU 读取内存中的指令和数据，于是程序就被执行起来了。\nMonolithic KernelMonolithic Kernel 的意思是宏内核，Linux 内核架构就是宏内核，意味着 Linux 的内核是一个完整的可执行程序，且拥有最高的权限。\n宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。\n不过，Linux 也实现了动态加载内核模块的功能，例如大部分设备驱动是以可加载模块的形式存在的，与内核其他模块解藕，让驱动开发和驱动加载更为方便、灵活。\n\n与宏内核相反的是微内核，微内核架构的内核只保留最基本的能力，比如进程调度、虚拟机内存、中断等，把一些应用放到了用户空间，比如驱动程序、文件系统等。这样服务与服务之间是隔离的，单个服务出现故障或者完全攻击，也不会导致整个操作系统挂掉，提高了操作系统的稳定性和可靠性。\n微内核内核功能少，可移植性高，相比宏内核有一点不好的地方在于，由于驱动程序不在内核中，而且驱动程序一般会频繁调用底层能力的，于是驱动和硬件设备交互就需要频繁切换到内核态，这样会带来性能损耗。华为的鸿蒙操作系统的内核架构就是微内核。\n还有一种内核叫混合类型内核，它的架构有点像微内核，内核里面会有一个最小版本的内核，然后其他模块会在这个基础上搭建，然后实现的时候会跟宏内核类似，也就是把整个内核做成一个完整的程序，大部分服务都在内核中，这就像是宏内核的方式包裹着一个微内核。\nWindows 设计当今 Windows 7、Windows 10 使用的内核叫 Windows NT，NT 全称叫 New Technology。\n下图是 Windows NT 的结构图片：\n\nWindows 和 Linux 一样，同样支持 MutiTask 和 SMP，但不同的是，Window 的内核设计是混合型内核，在上图你可以看到内核中有一个 MicroKernel 模块，这个就是最小版本的内核，而整个内核实现是一个完整的程序，含有非常多模块。\nWindows 的可执行文件的格式与 Linux 也不同，所以这两个系统的可执行文件是不可以在对方上运行的。\nWindows 的可执行文件格式叫 PE，称为可移植执行文件，扩展名通常是.exe、.dll、.sys等。\nPE 的结构你可以从下图中看到，它与 ELF 结构有一点相似。\n\n总结对于内核的架构一般有这三种类型：\n\n  宏内核，包含多个模块，整个内核像一个完整的程序；\n  微内核，有一个最小版本的内核，一些模块和服务则由用户态管理；\n  混合内核，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序；\n\nLinux 的内核设计是采用了宏内核，Window 的内核设计则是采用了混合内核。\n这两个操作系统的可执行文件格式也不一样， Linux 可执行文件格式叫作 ELF，Windows 可执行文件格式叫作 PE。\n参考资料\n\n https://en.wikipedia.org/wiki/Monolithic_kernel\n https://en.wikipedia.org/wiki/Executable_and_Linkable_Format\n https://en.wikipedia.org/wiki/Windows_NT\n\n","tags":["Linux"]},{"title":"交付技能培养过程","url":"/2021/05/02/simpread-%E4%BA%A4%E4%BB%98%E6%8A%80%E8%83%BD%E5%9F%B9%E5%85%BB%E8%BF%87%E7%A8%8B_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"交付技能培养过程从 2020 年 6 月正式入职联想，刚开始在 PS 东区交付组，方向为专家服务。后面换了方向。记录一下前辈对于我，在专家服务方向的培养历程。\n2020/7/7 讲解虚拟化的整体架构，如何安装虚拟机。进行测试环境的虚拟机安装实验。\n2020/7/14 回顾虚拟化整体架构，虚拟化网络架构巩固，讲解 / 实操 ESXi 安装，vcenter 安装（手册学习）\n2020/7/21 回顾 VMware ESXi/vCenter 安装步骤，虚拟化网络架构。\n2020/7/22 进行 VMware 集群配置讲解 –HA/DRS/EVC / 标准交换机 / 分布式交换机 / SSO 设置 / License 设置 / NTP 配置 / vCenter 系统管理。\n2020/7/28 回顾 VMware 网络架构，集群配置。\n2020/7/29 讲解 vSAN 原理和部署过程，布置作业，整体部署一套 VMware 环境。\n2020/8/11 回顾整个 VMware 的内容。\n2020/8/13 讲解微软 AD 的架构，包括 domain controller，DNS，DHCP。\n","tags":["学习"]},{"title":"交换机二三层转发原理","url":"/2021/11/16/simpread-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%BA%8C%E4%B8%89%E5%B1%82%E8%BD%AC%E5%8F%91%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"二层转发原理交换机有多个网络端口，它通过识别数据帧的目标 MAC 地址，根据 MAC 地址表决定从哪个端口发送数据。MAC 地址表不需要在交换机上手工设置，而是可以自动生成的。\n交换机是如何添加、更新、删除 MAC 地址表条目的？  \n在初始状态下，交换机的 MAC 地址表是空的，不包含任何条目。当交换机的某个端口接收到一个数据帧时，它就会将这个数据帧的源 MAC 地址、接收数据帧的端口号作为一个条目保存在自己的 MAC 地址表中，同时在接收到这个数据帧时重置这个条目的老化计时器时间。这就是交换机自动添加 MAC 地址表条目的方式。\n\n在新增这一条 MAC 地址条目后，如果交换机再次从同一个端口收到相同 MAC 地址为源 MAC 地址的数据帧时，交换机就会更新这个条目的老化计时器，确保活跃的的条目不会老化。但是如果在老化时间内都没收到匹配这个条目的数据帧，交换机就会将这个老化的条目从自己的 MAC 地址表中删除。\n\n还可以手动在交换机的 MAC 地址表中添加静态条目。静态添加的 MAC 地址条目优先动态学习的条目进行转发，而且静态条目没有老化时间，会一直保存在交换机的 MAC 地址表中。\n如何使用 MAC 地址表条目进行转发？  \n当交换机的某个端口收到一个单播数据帧时，它会查看这个数据帧的二层头部信息，并进行两个操作。一个操作是根据源 MAC 地址和端口信息添加或更新 MAC 地址表。另一个操作是查看数据帧的目的 MAC 地址，并根据数据帧的目的 MAC 地址查找自己的 MAC 地址表。在查找 MAC 地址表后，交换机会根据查找结果对数据帧进行处理，这里有 3 中情况：\n\n 交换机没有在 MAC 地址表中找到这个数据帧的目的 MAC 地址，因此交换机不知道自己的端口是否有连接这个 MAC 地址的设备。于是，交换机将这个数据帧从除了接收端口之外的所有端口泛洪出去。\n\n\n\n 交换机的 MAC 地址表中有这个数据帧的目的 MAC 地址，且对应端口不是接收到这个数据帧的端口，交换机知道目的设备连接在哪个端口上，因此交换机会根据 MAC 地址表中的条目将数据帧从对应端口单播转发出去，而其它与交换机相连的设备则不会收到这个数据帧。\n\n\n\n 交换机的 MAC 地址表中有这个数据帧的目的 MAC 地址，且对应端口就是接收到这个数据帧的端口。这种情况下，交换机会认为数据帧的目的地址就在这个端口所连接的范围内，因此目的设备应该已经收到数据帧。这个数据帧与其它端口的设备无关，不会将数据帧从其它端口转发出去。于是，交换机会丢弃数据帧。\n\n\n单播：主机一对一的发送数据。单播地址是主机的 MAC 地址。 广播：向局域网内所有设备发送数据。只有全 1 的 MAC 地址为广播 MAC 地址，即 FF-FF-FF-FF-FF-FF 。 泛洪：将某个端口收到的数据从除该端口之外的所有端口发送出去。泛洪操作广播的是普通数据帧而不是广播帧。\n\n三层转发原理路由器有多个端口，分别连接不同的数据链路。它通过识别目的 IP 地址的网络号，再根据路由表进行转发，路由表中有匹配的路由条目才会转发，无匹配的路由条目则直接丢弃。路由条目既可以手动设置静态路由，也可以通过路由协议自动生成动态路由。\n路由器如何进行三层转发？  \n当一台路由器收到一个数据包时，会执行如下步骤：\n\n 对数据包进行解封装。\n\n通过解封装，查看网络层头部信息的目的 IP 地址。\n\n 在路由表中查找匹配的路由条目。\n\n查找匹配的路由条目，就需要将数据包的目的 IP 地址与各个路由条目的网段地址先进行二进制与（ AND ）运算，再将运算结果与路由条目的网段地址进行比较，若一致则该条目与目的 IP 地址相匹配。最后，与所有路由条目完成运算和比较，可得到一条或多条相匹配的路由条目。也可能没有匹配的路由条目，那么丢弃数据包。\n\n\n 从多个匹配项中选择掩码最长的路由条目。\n\n如果路由表中有多条路由条目都匹配数据包的目的 IP 地址，则路由器会选择掩码长度最长的路由条目，这种匹配方式称为最长匹配原则。\n例如：10.1.3.10 的网络地址与 10.1.3.0/16 和 10.1.3.0/24 两项都匹配，这时应该选择匹配度最长的 10.1.3.0/24 。\n\n\n 将数据包按照相应路由条目进行转发。\n\n路由条目中包含下一跳和出接口。当路由器找到相应的路由条目后，它就会根据对应的下一跳和出接口，将数据包从出接口发送数据给下一跳设备。\n\nARP只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报文。但是在进行实际通信时，还要知道每个 IP 地址所对应的 MAC 地址。\n地址解析协议，简称 ARP 协议。是根据目的设备的 IP 地址来查询对应 MAC 地址的协议。\nARP 的工作原理当主机 A 向同一个网段内的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。\n\n\n ARP 请求：主机 A 以主机 C 的 IP 地址为目的 IP 地址，以广播 MAC 地址为目的 MAC 地址，在同网段内发送这个广播报文，这个报文就叫 ARP 请求报文。\n\n二层交换机不查看 IP 地址，根据目的 MAC 地址将报文除接收端口外的所有端口发送。\n\n\n ARP 响应：主机 C 发现目的 IP 地址是自己的 IP 地址，于是主机 C 以自己 MAC 地址和 IP 地址作为源 MAC 地址和源 IP 地址，以主机 A 的 MAC 地址和 IP 地址作为目的 MAC 地址和目的 IP 地址，发送响应报文给主机 A ，这个报文就叫 ARP 响应报文。其它主机收到主机 A 的 ARP 请求报文，因为目的 IP 地址不是自己的 IP 地址，因此不会进行响应。\n\n当主机 A 在发送 ARP 广播请求报文时，二层交换机已经有主机 A 的 MAC 地址表条目。当收到主机 C 发送的单播 ARP 响应报文时，二层交换机将报文从相应端口发送出去。并将主机 C 的 MAC 地址和对应端口记录到 MAC 地址表中。\n\n\n 更新 ARP 缓存表：主机 A 收到 ARP 响应报文后，将主机 C 的 IP 地址和 MAC 地址记录到 ARP 缓存表中。下次再向主机 C 发送数据时，直接将缓存的目的 MAC 地址进行封装。\n\n\n当主机 A 向不同网段的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。\n\n\n 主机 A 使用主机 C 的 IP 地址查询 ARP ，ARP 发现主机 C 不在同一个网段，需要通过默认网关（即默认路由的下一跳地址），但是没有网关 MAC 地址；\n\n\n\n 主机 A 先将发送给主机 C 的数据放入缓存中，然后发送 ARP 请求报文，主机 A 以网关 IP 地址为目的 IP 地址发送 ARP 广播请求报文；\n\n\n\n 路由器收到 ARP 广播请求报文后，将主机 A 的 MAC 地址和对应端口添加到自己的 MAC 表中，然后查看目的 IP 地址发现是请求自己的 MAC 地址，于是单播发送 ARP 响应报文；\n\n\n\n 主机 A 收到 ARP 响应报文后，将发送给主机 C 的数据封装网关 MAC 地址为目的 MAC 地址进行发送；\n\n\n\n 路由器收到报文后，查看目的 IP 地址，是发送给主机 C 的，于是查询路由表从相应端口发送数据。由于没有主机 C 的 MAC 地址，路由器发送 ARP 请求报文，源 MAC 地址和源 IP 地址替换为发送端口的 MAC 地址和 IP 地址；\n\n\n\n 主机 C 收到 ARP 请求报文后，添加路由器的端口和 MAC 地址到 MAC 地址表，单播发送 ARP 响应报文；\n\n\n\n 路由器收到主机 C 的 MAC 地址后，将其添加到 MAC 地址表中。将主机 A 发送给主机 C 的报文重新封装，以自己的 MAC 地址为源 MAC 地址，以主机 C 的 MAC 地址为目的 MAC 地址，发送给主机 C ；\n\n\n\n 主机 C 收到主机 A 发送的数据，发送过程结束。\n\n当主机 C 向主机 A 发送回复报文时，同主机 A 向主机 C 发送数据的步骤一致。\n小耸​\nPC1 ————————- 三层交换机 ———————–PC2　192.168.1.2　　192.168.1.1　　192.168.2.1　　192.168.2.2简述 PC1 ping PC2 的完整过程，含报文流程，以及 PC1、PC2、交换机各自的行为。[答:]#1 PC 1 首先检查出目的 IP 地址 192.168.2.2（PC 2）与自己不在同一网段，因此它发出请求网关地址 192.168.1.1(即是交换机的三层接口) 对应 MAC 的 ARP 请求；\n#2 SWITCH 收到 PC1 的 ARP 请求后，检查请求报文发现被请求 IP 是自己的三层接口 IP，因此发送 ARP 应答并将自己的三层接口 MAC（MACS）包含在其中。同时它还会把 PC 1 的 IP 地址与 MAC 地址对应（192.168.1.2&lt;==&gt;MACPC1）关系记录到自己的 ARP 表项中去（因为 ARP 请求报文中包含了发送者的 IP 和 MAC）；\n#3 PC 1 得到网关的 ARP 应答后，组装 ICMP 请求报文并发送，报文的目的 MAC＝MAC S、源 MAC＝MAC PC 1、源 IP＝192.168.1.2、目的 IP＝192.168.2.2；\n#4 SWITCH 收到报文后，首先根据报文的源 MAC+VID（即 VLAN ID）更新 MAC 地址表。然后，根据报文的目的 MAC＋VID 查找 MAC 地址表，发现匹配了自己三层接口 MAC 的表项。这里说明一下，三层交换机为 VLAN 配置三层接口 IP 后，会在交换芯片的 MAC 地址表中添加三层接口 MAC＋VID 的表项，并且为表项的三层转发标志 (Route 标志) 置位。当报文的目的 MAC 匹配这样的表项以后，说明需要作三层转发，于是继续查找交换芯片的三层表项；\n#5 交换芯片根据报文的目的 IP 去查找其三层表项，因为交换机当前路由表只有192.168.1.1/32192.168.1.2/32192.168.2.1/32192.168.1.0/24192.168.2.0/24所以 ping request 报文命中 192.168.2.0/24 转发出口是交换机 CPU\n#6 CPU 根据报文的目的 IP 去查找其软件路由表，发现匹配了一个直连网段（PC 2 对应的网段），于是继续查找其软件 ARP 表，仍然查找失败。然后 SWITCH 会在目的网段对应的 VLAN 的所有端口发送请求地址 192.168.2.2 对应 MAC 的 ARP 请求；\n#7 PC2 收到 SWITCH 发送的 ARP 请求后，检查发现被请求 IP 是自己的 IP，因此发送 ARP 应答并将自己的 MAC（MAC PC2）包含在其中。同时，将 SWITCH 的 IP 与 MAC 的对应关系（192.168.2.1&lt;==&gt;MACS）记录到自己的 ARP 表中去；\n#8 SWITCH 收到 PC 2 的 ARP 应答后，将其 IP 和 MAC 对应关系（192.168.2.2&lt;==&gt;MACPC 2）记录到自己的 ARP 表中去，并将 PC 1 的 ICMP 请求报文发送给 PC 2，报文的目的 MAC 修改为 PC 2 的 MAC（MAC PC2），源 MAC 修改为自己的 MAC（MACS）。同时，在交换芯片的三层表项中根据刚得到的三层转发信息添加表项（内容包括 IP、MAC、出口 VLAN、出端口），这样后续的 PC 1 发往 PC2 的报文就可以通过该硬件三层表项直接转发了；\n#9 PC 2 收到 SWITCH 转发过来的 ICMP 请求报文以后，回应 ICMP 应答给 PC1。ICMP 应答报文的转发过程与前面类似，只是由于 SWITCH 在之前已经得到 PC1 的 IP 和 MAC 对应关系了，也同时在交换芯片中添加了相关三层表项，因此这个报文直接由交换芯片硬件转发给 PC 1；\n#10 这样，后续的往返报文都经过查 MAC 表 =&gt; 查三层转发表的过程由交换芯片直接进行硬件转发了。\n上面就是简单的三层交换的过程了。\n二层交换就比三层简单多了，同一个 IP 网段内的主机互 ping，如果不知道对方的 MAC 地址，就通过 ARP 协议泛洪，得到了对方的 MAC 地址以后，再发出 ICMP 报文，就可以 ping 通了。\nsir long\n你可以参考下这个小结，个人认为总结得还是比较到位的。\n首先二层转发是基于 MAC 地址转发，三层转发基于 IP 地址转发，但是这并不意味着仅仅依靠 IP 地址就能转发，三层转发是建立在二层的基础上的，而仅仅依靠 MAC 地址是能够转发的。另外，由于二三层转发基于 MAC 地址、IP 地址、FDB 表（MAC 地址学习、更新、老化、删除等）、ARP 表、路由表、三层转发表、VLAN 端口类型（Access、Trunk、Hybrid）、VLAN 帧格式、ARP 报文格式等需要对此有基本的熟知。以下图为例，总结一下交换机中，基于 VLAN 的二三层转发原理。\n\n一、基本概念术语：①MAC 地址：48bit 的硬件地址，单播地址格式为首字节最低位为 1，多播地址格式为首字节最低位为 0，广播地址为全 1（即 FF：FF：FF：FF：FF：FF）。②FDB 表（FordWarding DateBase）：即 MAC 地址映射表，有 MAC 地址、端口、VLAN ID 等信息。③ARP 表：用于记录 IP 和 MAC 映射关系的表。④三层转发表：即基于硬件三层转发的包含目的 IP 地址、VLAN ID、端口和下一跳 MAC 地址等的关系表。⑤路由表：包含默认路由、RIP 等动态路由的路由路径信息的记录表。⑥VLAN 端口：主要是 Access 一般是用于连接主机，其发出的数据帧不带 tag 标签；还有就是 Trunk 用于可连接不同交换机的主干链路，其上发出的数据帧可能会带 tag 标签，用以识别不同 VLAN，如果没带则采用默认的 VLAN （PVID）\n假设最开始所有 PC 和交换机没有任何表项存在（ARP 缓存、FDB 缓存、三层转发表缓存等），且端口均为 Access 模式。\n二、二层转发（同一 VLAN 中主机通信）：以上图中 PC_A ping PC_B 为例来详细分析整个过程。①PC_A（192.168.10.1/24） 要 ping PC_B(192.168.10.2/24)，首先要去检查目标 IP 地址和自己的 IP 地址是否在同一个网段中，经过 IP 和子网掩码进行与运算，得知 PC_A 和 PC_B 属于语同一网段 192.168.10.0 网段。因此进行下一步：ARP 表项查询。②根据目标 IP：192.168.10.2 作为索引，在 ARP 表中查找对应的 MAC 地址，由于 ARP 表最开始是空的，所以没有找到对应 MAC，因此 PC_A 需要发送一个 ARP 广播报文在 VLAN 1 中请求 PC_B（192.168.10.2）的 MAC 地址，PC 封装的 ARP 报文主要内容为（opcode 操作码字段为 0X01 代表这是一个 ARP 请求报文，目标 MAC 由于不知道因此填充为 0，其余包含以太帧头部具体如下图所示）\n\n关于 ARP 报文各个字段的含义，用 wireshark 抓一个 ARP 包来查看，如下所示：\n\n③当交换机从 a 端口收到 PC_A 发出的报文，解析以太头部后发现目标 MAC 是 FF：FF：FF：FF：FF：FF，则知其是一个广播帧，解析源 MAC：MA，由于 FDB 表当前空空如也，因此先将 port a&lt;-&gt;MA&lt;-&gt;VLAN 1 等信息缓存到 FDB 表中。之后根据端口为 Access 模式，加上一个 VLAN tag（主要包含优先级和 VLAN ID=1），使其成为一个 802.1Q 的带有 VLAN tag 的以太帧，在交换机内部开始进行交换。④端口检测后发现 b、c、d 三个端口（其实还有一个 VLAN 接口，暂不提及）归属于 VLAN 1，因此将 tag 剥离并从这三个端口转发出去。⑤当 PC_C、PC_D 收到该广播帧解析内容发现目标 IP 不是自己则丢弃该数据帧，而 PC_B 发现目标 IP 就是自己，则先将 PC_A 的 192.168.10.1&lt;-&gt;MA 的映射信息更新到本地 ARP 表中。然后封装一个 ARP 回应的单播报文，内容主要为：源 IP：192.168.10.2，目标 IP：192.168.10.1，源 MAC：MB，目标 MAC：MA。发送出去，经端口 b 到达交换机。⑥交换机收到来自端口 b 的报文，解析头部获得源 MAC，则先将 port b&lt;-&gt;MB&lt;-&gt;VLAN 1 缓存到 FDB 表中去，由于 FDB 表中已经有了 PC_A 的 MAC 地址缓存，因此根据 ARP 回复报文数据帧头部的目标 MAC 将报文从端口 a 转发出去（该步中当然也存在入口数据帧 tag 的添加与出口数据帧 tag 剥离的操作）。⑦PC_A 接收到从端口 a 发出的 ARP 报文后，解析以太头部进行目标 MAC 匹配判断，匹配后解析报文内容，发现源 IP&lt;-&gt; 源 MAC 的对应关系，因此先缓存 192.168.10.2&lt;-&gt;MB，到 ARP 表中，之后有了 PC_B 的 MAC 地址接可以封装 icmp 报文进行 ping 的后续操作了。⑧交换机收到来自 PC_A 和 PC_B 的 icmp request 与 icmp reply 报文，由于之前有缓存 FDB 表项，因此之后只会更新对应表项的老化标志，长时间没有这俩源 MAC 的报文到交换机则会删除对应表项。\n三、三层转发（跨越不同 VLAN 的主机通信）：以上，以一台交换机上的同一个 VLAN 内的不同主机通信为例，描述了的是二层转发的基本过程，包括 ARP 表查询、ARP 请求、交换机 MAC 地址查询、FDB 表缓存、端口类型检查、VLAN tag 添加与剥离、目标主机 ARP 回复等步骤。而三层交换基本步骤差不多。以 VLAN 1 的 PC_A（192.168.10.1，MA）和 VLAN 2 的 PC_E（192.168.20.1，ME）相互 ping 为例分析（假设 VLAN 1 的网关为 VLAN 1 interface 的 IP：192.168.10.254，VLAN 2 的网关为 VLAN 2 interface 的 IP 为 192.168.20.254），以下过程也有加 VLAN tag 和剥离 VLAN tag 的过程，但与二层基本一致，因此不再赘述：\n①当 PC_A（192.168.10.1/24）要 ping PC_E（192.168.20.1/24）时，依然是检查目标 IP 是不是和自己在同一个网段，发现不在同一网段（一个在 10.0 网段一个在 20.0 网段），则需要经过网关（这里是交换机三层接口）来转发，因此 PC_A 在自己的 ARP 表中寻找网关对应的 MAC 地址，如果有则直接将报文封装为：目标 MAC 为网关 MAC，源 MAC 为 MA，发送端 IP 为 192.168.10.1，接收端 IP 为 192.168.20.1。②由于第一次 PC_A 的 ARP 缓存中不存在网关的 MAC 地址。则先向 VLAN 1 内广播发送一个 ARP 请求，请求网关 192.168.10.254 的 MAC 地址，封装为源 MAC 为 MA，目标 MAC 不可知则为全 0，源 IP 为 192.168.10.1，目标 IP 为 192.168.10.254，到链路层封装的头部为，源 MAC 为 MA，目标 MAC 为全 F 即广播包，“帧类型” 字段则填上 ARP 的协议号 0x0806。③交换机 SW1 收到 PC_A 发送的报文，二层解析头部检查为广播包，则从 VLAN 1 的除源端口外的各个端口转发出去，另外也转发一份到 VLAN 1 的三层接口，由于 PC_A 之前给 PC_B 发送过报文，SW 1 有 PC_A 的 FDB 缓存，则检查匹配后更新老化标志位。此外将 PC_A 的 IP、MAC、对应 port、VLAN ID 等信息记录到交换机的三层转发表中。④VLAN 1 其他主机收到请求对象不是自己的 ARP 请求，丢弃该广播报文，而 SW 1 的三层接口解析到目标 IP 是自己，则封装一个源 MAC 是交换机 VLAN 1 interface 的 MAC，源 IP 是 192.168.10.254，目标 IP 是 192.168.10.1，目标 MAC 是 MA 的 ARP 应答报文，再经过以太头部封装，添加 ARP 单播报文头部，目标 MAC 为 MA。交换机二层收到自三层的报文，解析数据帧头部，根据目标 MAC 地址 MA 在 FDB 表中查找到其出端口是 port a，为 ACCESS 端口，则剥掉 tag（之前请求报文进入 port a 之后会被加上 tag，以致能够区分识别出 VLAN 1 的其他端口与 VLAN 1 interface）转发给 PC_A。⑤PC_A 收到网关的 MAC 地址，则将发给 PC_E 的报文修改目标 MAC 为 VLAN 1 interface 即网关的 MAC 地址，而目标 IP 依旧是 PC_E 的 IP：192.168.20.1，然后封装以太头部以单播形式发送出去。⑥SW 1 在收到这个数据包后，因为 “目的 MAC 地址” 为交换机自己 VLAN 接口的 MAC 地址，而且 “目的 IP 地址” 和“源 IP 地址”不在同一网段，所以直接提交到三层，根据包中的 “目的 IP 地址”(PC_E 的 IP 地址) 在三层硬件转发表中查看有无对应表项，因为是第一次通信，所以结果是查找失败，于是将数据包再转送到 CPU 去进行软件路由处理。⑦ CPU 同样会根据包中的 “目的 IP 地址” 去查找其软件路由表，发现匹配了一个直连网段(PC_E 对应的网段)，于是继续查在 ARP 表中查找对应的 MAC 地址项。同样是由于是第一次查找，所以仍然查找失败。如果在 ARP 表中找到了对应的 MAC 地址，则数据可以直接由软件路由表转发了。⑧如果没查找到则以 PC_E 的目标 IP 为请求对象，在其所在 VLAN 2 的目标网段内发送 ARP 请求广播（目标 MAC 为全 0，目标 IP 为 192.168.20.1，源 MAC 为 VLAN 2 interface 对应 MAC，源 IP 为 VLAN 2 interface 对应 IP，192.168.20.254），PC_E 则先缓存网关的 ARP 表项，然后以 ARP 单播形式回复自己的 MAC 地址 ME 给网关 192.168.20.254，SW 1 的 CPU 则根据回复的报文更新记三层转发表项，记录到 PC_E 的 IP、MAC、出端口、VLAN ID 等信息，此时三层转发表中有了 PC_A 和 PC_E 的转发表项。另外缓存 PC_E 的 ARP 表项与 FDB 表项目。⑨三层交换机的 CPU 根据获取到的目标主机 MAC 和现有的直连路由信息将 PC_A 发来的数据包转发给 PC_E，这就是一次单方向的三层转发过程，其中也大量涉及到了二层转发（PC_A 在 VLAN 1 内广播请求网关 MAC，交换机 CPU 控制在 VLAN2 内广播请求 PC_E 的 MAC 等）。⑩当 PC_E 回复 PC_A 报文时，与 PC_A 步骤相同，只是在 PC_E 上已经存在了网关 ARP 表项、交换机上已经存在了到 PC_A 的三层转发表项、FDB 表项等，所以会更简单些。另外由于三层转发表项的存在，因此 PC_E 回复 PC_A 的报文会直接根据三层转发表进行硬件转发，而不是 CPU 路由软件转发，效率会更快。\n","tags":["计算机网络"]},{"title":"Linux  CentOs 网络配置","url":"/2023/01/31/CentOs%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","content":"最近对内部VMware虚拟机环境进行了配置，并且开启了一台win server2016作为跳板机，用Net路由转发实现上网。\n对于每一台CentOS 的VM网络配置如下。最终成功ping通百度，但是需要上跳板机进行SSH连接。\n\n\n\n最终实现上网：\n\n注意，前提需要进入到   network-scripts目录下。配置完后重启网络服务。\n","tags":["Linux"]},{"title":"优秀科学论文","url":"/2021/05/02/simpread-%E4%BC%98%E7%A7%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%96%87%E7%AB%A0%E6%B1%87%E9%9B%86_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"看到几篇不错的文章。这里做一个记录。\n\n 云计算简史（完整版）\n 图解：网络硬件的发展史\n 为 Navicat 正名，Navicat 完全使用手册（下）\n\n","tags":["论文"]},{"title":"全面讲解 Vlan、三层交换机、网关、DNS、子网掩码、MAC 地址等网络知识","url":"/2021/11/16/simpread-%E5%85%A8%E9%9D%A2%E8%AE%B2%E8%A7%A3%20Vlan%E3%80%81%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81%E7%BD%91%E5%85%B3%E3%80%81DNS%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E3%80%81MAC%20%E5%9C%B0%E5%9D%80%E7%AD%89%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%EF%BC%8C%E5%80%BC%E5%BE%97%E6%94%B6%E8%97%8F%E5%AD%A6%E4%B9%A0%EF%BC%81/","content":"我们现在做的弱电工程，经常用到网络知识，比如 vlan、三层交换机、网关、DNS、子网掩码、MAC 地址等方面的知识，作为从业人员，我们对这些知识了解并熟知的。\n一、什么是 VLAN\nVLAN 中文是 “虚拟局域网”。LAN 可以是由少数几台家用计算机构成的网络，也可以是数以百计的计算机构成的企业网络。VLAN 所指的 LAN 特指使用路由器分割的网络——也就是广播域。\n听上面的概念，肯定有不少朋友是一头雾水的，什么是虚拟局域网？好好的，为什么要划分 vlan？\n这里举个例：通俗的了解\n一所高中，新学期高一招了 800 个学生，这 800 个学生，如果放在一个班里，那肯定是管理不过来，面对 800 个人，老师看了也头疼，这边在授课，那边完全听不到，老师布置什么任务，也会有一些传达不到，老师要是想找某个学生的信息，要从 800 份信息中去找，极其麻烦，浪费时间；\n而实际中，也是一样，电脑 A 要想要与电脑 B 通信，于是电脑 A 就需要发送 arp 请求，而网络中电脑众多，最终 ARP 请求会被转发到同一网络中的所有电脑，才能找到电脑 B，如此一来，为了找到电脑 B，消耗了网络整体的带宽，收到广播信息的计算机还要消耗一部分 CPU 时间来对它进行处理。造成了网络带宽和 CPU 运算能力的大量无谓消耗。\n那么怎么办呢？\n学校就针对这 800 个学生，分成了 10 个班，每个班 80 人，分别命名为高一（1）班，高一（2）班、、、、高一（10）班，每个人都会获得一个班级编号。\n1101 表示一班 01 号学生。\n1102 表示一班 02 号学生。\n1201 表示 2 班 01 号学生。\n同一个班的学生编号尾数不同，其它的都相同。\n那么这样老师再管理起来就轻松多了，可以把一班这 80 人管理的妥妥的，隔壁 2 班与 3 班乱成一锅粥也不管一班的事，我就要这一班 80 人好好上课就行。\n这就是 vlan，每个班就相当于一个 vlan，而每个班名称，就相当于 vlan 的名称，而每个学生的编号就是 ip 地址；同班同学（同一个 vlan 的 ip），因为同一个教室，朝夕相处，且可以相互通信，不同班的同学，若不做其它工作，很难往来通信。\n所以同一个 vlan 间，可以相互通信；不同 vlan，若不做配置，不能相互通信。\n那么不同 vlan 如何通通信呢？就需要单臂路由与三层交换机。\n二、单臂路由与三层交换机\n我们知道要实现不同 vlan 间通信，就必须需要有路由功能，不同 VLAN 之间相互通信的两种方式（单臂路由、三层交换机）。\n什么是单臂路由？\n单臂路由的实现方式，其实就是普通二层交换机加路由器，从而实现不同 vlan 间的可以互相通信。\n\n那什么是三层交换机呢？\n对于小型的网络，单臂路由可以应付，但随着 VLAN 之间流量的不断增加，很可能导致路由器成为整个网络的瓶颈，出现掉包、或者通信堵塞。\n为了解决上述问题，三层交换机应运而生。三层交换机，本质上就是 “带有路由功能的（二层）交换机”。路由属于 OSI 参照模型中第三层网络层的功能，因此带有第三层路由功能的交换机才被称为 “三层交换机”。\n关于三层交换机的内部结构，可以参照下面的简图。\n\n在一台本体内，分别设置了交换机模块和路由器模块；而内置的路由模块与交换模块相同，使用 ASIC 硬件处理路由。因此，与传统的路由器相比，可以实现高速路由。并且，路由与交换模块是汇聚链接的，由于是内部连接，可以确保相当大的带宽，所以对于正规的项目，需要使用三层交换机来实现网网络间的通信。\n三、什么是网关\n在了解了 vlan 与三层交换机后，能不能通信，还需要看网关是否正确。\n什么是网关\n网关 (Gateway) 又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。\n如何来理解网关\n大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也必须经过一道 “关口”，这道关口就是网关。顾名思义，网关(Gateway) 就是一个网络连接到另一个网络的“关口”。\n按照不同的分类标准，网关也有很多种。TCP/IP 协议里的网关是最常用的，在这里我们所讲的 “网关” 均指 TCP/IP 协议下的网关。\n网关的 ip 地址\n那么网关到底是什么呢？\n网关实质上是一个网络通向其他网络的 IP 地址，网关在网段内的可用 ip 中选一个，不过，一般用的是第 1 个和最后一个。\n例如\n比如有网络 A 和网络 B，\n网络 A：的 IP 地址范围为 “192.168.1.1~192. 168.1.254”，子网掩 255.255.255.0；\n如果需要与其它网段通信，那么它的网关可以设置为 192.168.1.1，当然也可以设置为网段内其它的一个 ip 地址。\n网络 B：的 IP 地址范为 “192.168.2.1~192.168.2.254”，子网掩码 255.255.255.0。\n如果需要与其它网段通信，那么它的网关可以设置为 192.168.2.1，当然也可以设置为网段内其它的一个 ip 地址。\n\n网关是如何实现通信？\n在没有路由器的情况下，不同的两个网络之间是不能进行 TCP/IP 通信的，即使是两个网络连接在同一台交换机 (或集线器) 上，TCP/IP 协议也会根据子网掩码 (255.255.255.0) 判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。\n如果网络 A 中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络 B 的网关，网络 B 的网关再转发给网络 B 的某个主机 (如附图所示)。网络 B 向网络 A 转发数据包的过程。\n所以说，只有设置好网关的 IP 地址，TCP/IP 协议才能实现不同网络之间的相互通信。\n什么是默认网关？\n　　如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。\n四、什么是 DNS\nDNS 是域名解析服务器（Domain Name System），是把网址变成 IP 地址的服务器。\nDNS 说白了是把域名翻译成 IP 地址用的，这里面举个例子，大家就很容易清楚了。\n例如我们在浏览器里面输入 http://www.baidu.com 的时候，机器要跟百度这个网站进行通信，机器要往外面发送数据包，数据包里面要写百度这台服务器的 IP 地址，我们不知道 IP 地址是多少，那么就需要主机问 DNS 服务器，DNS 服务器就自动帮我们把 http://www.baidu.com 这个域名翻译成了 IP 地址 61.135.169.105。然后写到了数据包的目的 IP 地址里面就可以进行通信。\n就跟我们写信一样，你得写个收信人的地址邮局才能给你发送吧，你给国外写信，你写中文地址邮局不认识，需要这个一个人帮你翻译成英语。这就是 DNS 的作用，所以你的在本地连接里面写 DNS 才可以正常浏览网页，如果不设置 DNS，是无法正常访问网页的。\n五、MAC 地址\n讲到 MAC 地址，就不得不提 ip 地址，这里顺便把 ip 地址也说下。\nIP 与 MAC\n虽然现在已经 ipv6 了，但我们基本用的大多数还是 ipv4 协议，所谓 ip 就是你电脑整个网络的编号。其他电脑想访问电脑就得需要这个编号。但是这个编号很多情况下是一直在变化的。唯一不变的是你的 MAC 地址：物理地址。\nMAC 是网络中用来标识网卡设备的唯一网络地址。由相关硬件制造商统一分配，每台电脑的 MAC 地址都是唯一的。\n做个比喻，你经常搬家，你没搬一次家都有一个地址，XX 小区 XX 单元 XX 号，这个就是 IP。但是你的名字不变，这个就是 MAC，不同的是我们的 MAC 不允许重名。\n\n我们的 IP 分为两个部分：如上图分为网络部分和主机部分。网络部分好比就是你在 XX 省 XX 市 XX 镇，这个是国家固定下来了的。但是 XX 小区 XX 单元 XX 号是开发商自己定的。两个编号加起来就是你的 ip 了。不同的是在现实中两个编号的长度是固定的，在网络上 A、B、C、D 的 ip 地址却是变化的，这个在前天有详细讲到。\n六、子网掩码\n子网掩码是为了区分网络位和主机位，上面我们说到过，一个 ip 地址是由网络部分和主机部分。正如一个人的名字由姓与名组成。\n那么我们可以把 IP 地址比作一个人的名字，那么子网掩码就像是一份名单，可以快速的知道那些人同姓，那些人不同姓，把同姓的人分在一组，让他们之前可以互相交流。\n举个例子\n有一个网段是 192.168.1.0-192.1.254，这个网段就像一个村子一样，就称它为安防村，此这网段有个 ip 地址是 192.168.1.1，我们就叫他安防一，另外一个人叫安防二，它的 ip 地址为 192.168.1.2，我们一看他们，就知道他们是同村的。\n另外有一个网段，是 192.168.0.0——192.168.255.254，我们叫它安村，村里有个同样有两个 ip 地址为 92.168.1.1 与 192.168.1.2，也叫安防一，安防二，那么问题来了？这个时候，如何区分他们是属于那个村的？\n这个时候就需要子网掩码了来判断他们是属于那个网段的，需要把安防一、安防二带到村里去认下，就知道他们是属于那个村了，安防村的网段是 255.255.255.0，安村的网段是 255.255.0.0。\n网络中也会出现类似于 “同名”“同姓” 的 ip 地址，如何区分他们到底是属于那个网段，就需要依靠子网掩码了。\n","tags":["计算机网络"]},{"title":"从0开始装VSAN","url":"/2021/05/02/simpread-%E4%BB%8E%200%20%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85%20VSAN%20%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2_vsan%20%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","content":"\n请务必格式化好全部的硬盘，否则可能会出现配置好了但是不能使用的问题。  \n安装 VCSA 可能会卡 80% 参考网上解决。（有可能实际上是等待不够久，并不会出现进度条不会动的情况）  \n注意好安装环境的物理网络情况，确保过程中的通信。  \nEVC 开启的话选择最新的 CPU 微架构\n\nPartition1 - install ESXi进入 xcc 选择 ESXi 镜像，挂载，重启。根据 installer 提示完成 ESXi 安装（在本次实验环境下\nPartition2 - deploy VCSA onto new vSAN cluster打开安装镜像，选择对应的安装程序，在选择 datastore 的时候选择安装在一个新的 vSAN 群集里，剩下的按照需求配置好\nParition3 - 修理剩下的错误\n\n  将其余的 vSAN 主机添加到群集中。\n  在每个主机上配置专用的 vSAN vmkernel。\n  将磁盘从其他主机添加到 vSAN 磁盘组。\n  一切正常运行后，确保运行了 vSAN Health Check，并且不要忽略任何错误！\n\nUPGRADING TO VCENTER 7.0 VIA CLI将 vSAN 群集从一个 vCenter Server 移至另一个 vCenter Server (2151610)\n如果 vCenter Server 虚拟机属于同一群集，如何启用 EVC（1013111）\n","tags":["VMware"]},{"title":"TCP_IP，必知必会10问","url":"/2021/11/16/simpread-%E5%85%B3%E4%BA%8E%20TCP_IP%EF%BC%8C%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%2010%20%E4%B8%AA%E9%97%AE%E9%A2%98/","content":"\n本文整理了一些 TCP/IP 协议簇中需要必知必会的十大问题，既是面试高频问题，又是程序员必备基础素养。\n\n\n一、TCP/IP 模型TCP/IP 协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是 Internet 的核心协议。\n基于 TCP/IP 的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示 TCP/IP 模型与 OSI 模型各层的对照关系。\n\nTCP/IP 协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有 http，ftp, 等等我们熟悉的协议。而第二层则是传输层，著名的 TCP 和 UDP 协议就在这个层次。第三层是网络层，IP 协议就在这里，它负责对数据加上 IP 地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行 CRC 编码，为最后的数据传输做准备。\n\n上图清楚地表示了 TCP/IP 协议中每个层的作用，而 TCP/IP 协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。\n\n上图以 HTTP 协议为例，具体说明。\n二、数据链路层物理层负责 0、1 比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将 0、1 序列划分为数据帧从一个节点传输到临近的另一个节点, 这些节点是通过 MAC 来唯一标识的 (MAC, 物理地址，一个主机会有一个 MAC 地址)。  \n\n\n  封装成帧: 把网络层数据报加头和尾，封装成帧, 帧头中包括源 MAC 地址和目的 MAC 地址。\n  透明传输: 零比特填充、转义字符。\n  可靠传输: 在出错率很低的链路上很少用，但是无线链路 WLAN 会保证可靠传输。\n  差错检测 (CRC): 接收者检测错误, 如果发现差错，丢弃该帧。\n\n三、网络层1. IP 协议\nIP 协议是 TCP/IP 协议的核心，所有的 TCP，UDP，IMCP，IGMP 的数据都以 IP 数据格式传输。要注意的是，IP 不是可靠的协议，这是说，IP 协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP 或 UDP 要做的事情。\n1.1 IP 地址\n在数据链路层中我们一般通过 MAC 地址来识别不同的节点，而在 IP 层我们也要有一个类似的地址标识，这就是 IP 地址。\n32 位 IP 地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。\nA 类 IP 地址: 0.0.0.0127.0.0.0B 类 IP 地址: 128.0.0.1191.255.0.0C 类 IP 地址: 192.168.0.0~239.255.255.0\n1.2 IP 协议头\n\n这里只介绍: 八位的 TTL 字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个 IP 数据包每穿过一个路由器，该数据包的 TTL 数值就会减少 1，当该数据包的 TTL 成为零，它就会被自动抛弃。\n这个字段的最大值也就是 255，也就是说一个协议包也就在路由器里面穿行 255 次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是 32 或者是 64。\n2. ARP 及 RARP 协议\nARP 是根据 IP 地址获取 MAC 地址的一种协议。\nARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个 IP 对应的是哪个主机的哪个接口，当主机要发送一个 IP 包的时候，会首先查一下自己的 ARP 高速缓存（就是一个 IP-MAC 地址对应表缓存）。\n如果查询的 IP－MAC 值对不存在，那么主机就向网络发送一个 ARP 协议广播包，这个广播包里面就有待查询的 IP 地址，而直接收到这份广播的包的所有主机都会查询自己的 IP 地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的 MAC 地址的 ARP 包传送给发送 ARP 广播的主机。\n而广播主机拿到 ARP 包后会更新自己的 ARP 缓存（就是存放 IP-MAC 对应表的地方）。发送广播的主机就会用新的 ARP 缓存数据准备好数据链路层的的数据包发送工作。\nRARP 协议的工作与此相反，不做赘述。\n3. ICMP 协议\nIP 协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是 ICMP(网络控制报文) 协议。ICMP 不是高层协议，而是 IP 层的协议。\n当传送 IP 数据包发生错误。比如主机不可达，路由不可达等等，ICMP 协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在 IP 层以上的协议是可能做到安全的原因。\n四、pingping 可以说是 ICMP 的最著名的应用，是 TCP/IP 协议的一部分。利用 “ping” 命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。\n例如：当我们某一个网站上不去的时候。通常会 ping 一下这个网站。ping 会回显出一些有用的信息。一般的信息如下:\n\nping 这个单词源自声纳定位，而这个程序的作用也确实如此，它利用 ICMP 协议包来侦测另一个主机是否可达。原理是用类型码为 0 的 ICMP 发请 求，受到请求的主机则用类型码为 8 的 ICMP 回应。\nping 程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping 给出来了传送的时间和 TTL 的数据。\n五、TracerouteTraceroute 是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。\nTraceroute 的原理是非常非常的有意思，它收到到目的主机的 IP 后，首先给目的主机发送一个 TTL=1 的 UDP 数据包，而经过的第一个路由器收到这个数据包以后，就自动把 TTL 减 1，而 TTL 变为 0 以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的 ICMP 数据报给主机。主机收到这个数据报以后再发一个 TTL=2 的 UDP 数据报给目的主机，然后刺激第二个路由器给主机发 ICMP 数据 报。如此往复直到到达目的主机。这样，traceroute 就拿到了所有的路由器 IP。\n\n六、TCP/UDPTCP/UDP 都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。\n\n面向报文\n面向报文的传输方式是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则 IP 层需要分片，降低效率。若太短，会是 IP 太小。\n面向字节流\n面向字节流的话，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。\n关于拥塞控制，流量控制，是 TCP 的重点，后面讲解。\nTCP 和 UDP 协议的一些应用\n\n什么时候应该使用 TCP？\n当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。\n什么时候应该使用 UDP？\n当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。\n七、DNSDNS（Domain Name System，域名系统），因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。通过主机名，最终得到该主机名对应的 IP 地址的过程叫做域名解析（或主机名解析）。DNS 协议运行在 UDP 协议之上，使用端口号 53。\n八、TCP 连接的建立与终止1. 三次握手\nTCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。\n\n第一次握手： 建立连接。客户端发送连接请求报文段，将 SYN 位置为 1，Sequence Number 为 x；然后，客户端进入 SYN_SEND 状态，等待服务器的确认；\n第二次握手： 服务器收到 SYN 报文段。服务器收到客户端的 SYN 报文段，需要对这个 SYN 报文段进行确认，设置 Acknowledgment Number 为 x+1(Sequence Number+1)；同时，自己自己还要发送 SYN 请求信息，将 SYN 位置为 1，Sequence Number 为 y；服务器端将上述所有信息放到一个报文段（即 SYN+ACK 报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV 状态；\n第三次握手： 客户端收到服务器的 SYN+ACK 报文段。然后将 Acknowledgment Number 设置为 y+1，向服务器发送 ACK 报文段，这个报文段发送完毕以后，客户端和服务器端都进入 ESTABLISHED 状态，完成 TCP 三次握手。\n为什么要三次握手？\n为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\n具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”\n2. 四次挥手\n当客户端和服务器通过三次握手建立了 TCP 连接以后，当数据传送完毕，肯定是要断开 TCP 连接的啊。那对于 TCP 的断开连接，这里就有了神秘的 “四次分手”。\n\n第一次分手： 主机 1（可以使客户端，也可以是服务器端），设置 Sequence Number，向主机 2 发送一个 FIN 报文段；此时，主机 1 进入 FIN_WAIT_1 状态；这表示主机 1 没有数据要发送给主机 2 了；\n第二次分手： 主机 2 收到了主机 1 发送的 FIN 报文段，向主机 1 回一个 ACK 报文段，Acknowledgment Number 为 Sequence Number 加 1；主机 1 进入 FIN_WAIT_2 状态；主机 2 告诉主机 1，我 “同意” 你的关闭请求；\n第三次分手： 主机 2 向主机 1 发送 FIN 报文段，请求关闭连接，同时主机 2 进入 LAST_ACK 状态；\n第四次分手： 主机 1 收到主机 2 发送的 FIN 报文段，向主机 2 发送 ACK 报文段，然后主机 1 进入 TIME_WAIT 状态；主机 2 收到主机 1 的 ACK 报文段以后，就关闭连接；此时，主机 1 等待 2MSL 后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机 1 也可以关闭连接了。\n为什么要四次分手？\nTCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当主机 1 发出 FIN 报文段时，只是表示主机 1 已经没有数据要发送了，主机 1 告诉主机 2，它的数据已经全部发送完毕了；但是，这个时候主机 1 还是可以接受来自主机 2 的数据；当主机 2 返回 ACK 报文段时，表示它已经知道主机 1 没有数据发送了，但是主机 2 还是可以发送数据到主机 1 的；当主机 2 也发送了 FIN 报文段时，这个时候就表示主机 2 也没有数据要发送了，就会告诉主机 1，我也没有数据要发送了，之后彼此就会愉快的中断这次 TCP 连接。\n为什么要等待 2MSL？\nMSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。\n原因有二：\n\n  保证 TCP 协议的全双工连接能够可靠关闭\n  保证这次连接的重复数据段从网络中消失\n\n第一点：如果主机 1 直接 CLOSED 了，那么由于 IP 协议的不可靠性或者是其它网络原因，导致主机 2 没有收到主机 1 最后回复的 ACK。那么主机 2 就会在超时之后继续发送 FIN，此时由于主机 1 已经 CLOSED 了，就找不到与重发的 FIN 对应的连接。所以，主机 1 不是直接进入 CLOSED，而是要保持 TIME_WAIT，当再次收到 FIN 的时候，能够保证对方收到 ACK，最后正确的关闭连接。\n第二点：如果主机 1 直接 CLOSED，然后又再向主机 2 发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机 2，由于新连接和老连接的端口号是一样的，TCP 协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以 TCP 连接还要在 TIME_WAIT 状态等待 2 倍 MSL，这样可以保证本次连接的所有数据都从网络中消失。\n九、TCP 流量控制如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。\n利用滑动窗口机制可以很方便地在 TCP 连接上实现对发送方的流量控制。\n设 A 向 B 发送数据。在连接建立时，B 告诉了 A：“我的接收窗口是 rwnd = 400”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP 的窗口单位是字节，不是报文段。假设每一个报文段为 100 字节长，而数据报文段序号的初始值设为 1。大写 ACK 表示首部中的确认位 ACK，小写 ack 表示确认字段的值 ack。\n\n从图中可以看出，B 进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机 B 重新发出一个新的窗口值为止。B 向 A 发送的三个报文段都设置了 ACK = 1 ，只有在 ACK=1 时确认号字段才有意义。\nTCP 为每一个连接设有一个持续计时器 (persistence timer)。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携 1 字节的数据），那么收到这个报文段的一方就重新设置持续计时器。\n十、TCP 拥塞控制1. 慢开始和拥塞避免\n发送方维持一个拥塞窗口 cwnd (congestion window) 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。\n发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。\n慢开始算法：\n当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。\n因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。\n通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个 MSS 的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。\n\n每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间 RTT。不过 “传输轮次” 更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。\n另，慢开始的 “慢” 并不是指 cwnd 的增长速率慢，而是指在 TCP 开始发送报文段时先设置 cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大 cwnd。\n为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量。慢开始门限 ssthresh 的用法如下：\n\n  当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。\n  当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。\n  当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。\n\n拥塞避免\n让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍。这样拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。\n\n无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送 方窗口值的一半（但不能小于 2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。\n这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。\n如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。\n\n2. 快重传和快恢复\n快重传\n快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。\n\n接收方收到了 M1 和 M2 后都分别发出了确认。现在假定接收方没有收到 M3 但接着收到了 M4。\n显然，接收方不能确认 M4，因为 M4 是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对 M2 的确认。\n但按照快重传算法的规定，接收方应及时发送对 M2 的重复确认，这样做可以让 发送方及早知道报文段 M3 没有到达接收方。发送方接着发送了 M5 和 M6。接收方收到这两个报文后，也还要再次发出对 M2 的重复确认。这样，发送方共收到了 接收方的四个对 M2 的确认，其中后三个都是重复确认。\n快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段 M3，而不必 继续等待 M3 设置的重传计时器到期。\n由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约 20%。\n快恢复\n与快重传配合使用的还有快恢复算法，其过程有以下两个要点：\n\n  当发送方连续收到三个重复确认，就执行 “乘法减小” 算法，把慢开始门限 ssthresh 减半。\n  与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口 cwnd 现在不设置为 1），而是把 cwnd 值设置为 慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。\n\n\n","tags":["计算机网络"]},{"title":"关于Docker的缺点","url":"/2023/02/02/simpread-%E5%85%B3%E4%BA%8E%20docker%20%E7%9A%84%E7%BC%BA%E7%82%B9/","content":"使用 docker 时候，我惊叹发现 docker 真的是个宝藏，可以秒级开启应用，不用特别繁琐的配置什么配置，可以减轻很多这种重复性的劳动。最近我在学习 docker，然后我就在想它可不可以虚拟化 Windows 的桌面系统呢？\n通过查找资料，我发现 docker 不适合虚拟化桌面，它比较适合 linux 族，Unix 族以及应用程序的虚拟化。\n逻辑是这样的，在操作系统的概念里面，有一个内核，docker 是基于 Linux 内核，它不适用于 Windows 虚拟化，Windows 操作系统有另外一个虚拟技术 Hype-y.\n从哪里可以验证呢？在 docker hub 的网站上面，可以看一下关于 Windows 的镜像，在这里都没有收录 Windows 系列的操作系统镜像，都是一些应用程序。\nDocker Hub\n也就是说它比较适合 Linux 服务器的虚拟化，应用虚拟化。\n在桌面虚拟化的领域，其实只有几家厂商可以做到技术完全自主化，这几家厂商分别是\nCitrix 思杰 占有率46%   技术：XenServerVmware      占有率18%   技术：Vmware EXSI微软        占有率未知  技术：hyper-vRedhat      占有率未知  技术：LVM华为        占有率未知  技术：openstack\n\n在国内可能更多的听到是阿里云、腾讯云、或者华为云\n我觉得桌面虚拟化更像 IASS 这种状态，虚拟化比较浅，可能只到操作系统这一层，下面是虚拟化几个方向的示意图，这种技术之后可能还得要装一些应用软件，比如 Windows 的 IIS，linux 的 Nginx，或者是 oracle 的数据库。\n\n\ndocker 的目的主要还是用于应用容器, 而不是虚拟系统. 虽然 docker 提供了很多基础系统镜像, 但不是用来搭虚拟机用的, 只是提供一个应用的运行环境而已, 没法当作一个完整的系统. 就比如 docker 里不能运行 docker, 这是特性, 不是bug, 是设计目标与实现方案共同导致的结果.\n\ndocker核心之一就是在一个系统内核下, 运行多个不同的系统环境, docker容器启动后, 只启动了应用的进程, 不会启动其他系统进程。与虚拟机相比, 这样节约了重复启动多个系统内核的资源开销。\ndocker 跟虚拟机的使用场景不同, 要谨慎区分用途。\n\ndoker只是自身秒级启动，并不能秒级启动各种镜像。Openstack不提供底层的资源虚拟化 华为的那个叫CNA\n\n查资料的时候发现很多厂商都喜欢扯一些概念，什么 VDI、IDV、VOI、NGD，但是底层的技术实现干货很少。\n","tags":["桌面云"]},{"title":"新年期望","url":"/2021/05/02/simpread-%E6%96%B0%E5%B9%B4%E6%9C%9F%E6%9C%9B_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"\n本文由 简悦 SimpRead 转码， 原文地址 blog.csdn.net\n\n1， 云原生开发 ： K8S， Docker , DevOps , Jenkins， Prometheus ，Rancher\n2， 微服务架构:    SpringBoot，微服务。\n3， 开发 ：           Vue，Golang , Python 高阶\n4， infra ：          计算机网络（CCNA，IP 规划)\n5,    项目经理：    PMO， PMP\n2021.02.26\n","tags":["学习"]},{"title":"最前沿：Meta Learning to Learn, 到底我们要学会学习什么？","url":"/2023/02/01/simpread-%E6%9C%80%E5%89%8D%E6%B2%BF%EF%BC%9AMeta%20Learning_Learning%20to%20Learn,%20%E5%88%B0%E5%BA%95%E6%88%91%E4%BB%AC%E8%A6%81%E5%AD%A6%E4%BC%9A%E5%AD%A6%E4%B9%A0%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"1 前言\n在本文之前，智能专栏上已经有多篇介绍 Meta Learning 的文章：\nKay Ke：概要：NIPS 2017 Deep Learning for Robotics Keynote\nFlood Sung：最前沿：百家争鸣的 Meta Learning/Learning to learn\nFlood Sung：机器人革命与学会学习 Learning to Learn\nFlood Sung：学会学习 Learning to Learn：让 AI 拥有核心价值观从而实现快速学习\n那么在这篇博文中，我打算更深入的谈谈我对 Meta Learning 的理解，也算是全新的视角。\n2 到底什么是 Meta 的？\n\n我不知道是谁最先把 Meta Learning 翻译成元学习的，但从中文的角度问你 “元学习是什么？” 你要怎么回答？老实说我也是懵逼的。特意查一下元在字典中的意思，主要是有初始，根源的意思。但 Meta Learning 不是初始呀，这里的 Meta 更应该是指更高 level 的东西。Learning to Learn 这个词看起来应该更好理解，直接翻译就对了：学会学习。所以 Meta Learning 可以理解为要学习一种学习能力。但是什么是学习能力呢？如何描述？一般我们说某个学神学习能力强大概是说学神记忆力好，理解能力快之类的东西。但是什么是理解能力呢？依然非常难以描述。\n实际上这里我们遇到了和高维空间一样的问题。我们很难去想象高维空间，我们也很难去想象 meta 的东西到底是什么。更何况，还有 meta-meta，meta-meta-meta… 的东西。也许这就是大概被称为智能的东西吧。\n\n以前，我们只是不知道 Deep Learning 是怎么学的，但至少知道是在学习下棋还是学习图像识别，现在对于 Meta Learning，我们连学什么都不太清楚了。\n\n那么 Meta 到底如何定义？我们只能回归到 Machine Learning 本身来考虑这个概念。这里我给出一个我对 Meta 的定义：\n\n任何超出学习（Learning/Training）内部的东西都是 Meta 的！\n\n什么是学习内部呢？\n有两个视角，一个是深度学习技术上的学习，一般我们也称为训练，另一种是人类角度看的学习。\n2.1 深度学习技术视角的 Meta\n\n现在大家都在自嘲自己是炼金术士，我们每天调的参数就是 Meta 的，也就是在学习外部！所谓的学习就是这个训练过程，也可以说是反向传播过程。超出这个 “学习的” 都是学习外部，都是 Meta 的。\n这包含了以下这些类别：\n\n训练超参数 Hyper Parameters：包括 Learning rate，Batch Size，input size 等等目前要人为设定的参数\n神经网络的结构\n神经网络的初始化\n优化器 Optimizer 的选择。比如 SGD，Adam，RMSProp\n神经网络参数\n损失函数的定义。那么多 gan 的文章基本上就是改改损失函数。\n反向传播 Back-propagation。 对，这个也是 Meta 的，我们通过梯度下降的公式固定了参数的更新方式。神经网络傻傻只能按照这个公式来更新参数。\n\n我发现要区别是不是 Meta 的就是把 “学习” 当做一个小孩，你叫他怎么做怎么做的东西都是 Meta 的。那么所谓的 “学习” 就是沿着你设定的方向实际移动的过程，比如梯度下降中参数实际变化过程叫学习。而学会学习就是使用神经网络自己去构造上面的任意设定。\n也因此，我们可以把目前 meta learning 的一些研究工作排排坐了。比如说\n[1611.01578] Neural Architecture Search with Reinforcement Learning\n这就属于神经网络结构的，很明显。\n[1703.03400] Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks\nMAML 就属于参数的初始化。\n[1606.04474] Learning to learn by gradient descent by gradient descent\n这篇则是构造一个神经网络的优化器来替代 Adam，SGD。\nMeta-Critic Networks for Sample Efficient Learning\n这篇则是考虑学习一个更好的 loss。\n还有\nOptimization as a Model for Few-Shot Learning\n这篇则既学习一个好的初始化，也学习网络的更新。\n那么看到这里大家显然就可以看出来了，我们可以切入其中的某一个角度来做文章。\n这里面可能最最困难的就是直接取代反向传播。如果能用一个神经网络来代替目前的反向传播，那就牛大了。\n2.2 人类视角下的 Meta：Meta Knowledge\n\n说完深度学习技术角度的 Meta，我们再来看看人类视角下的 Meta。所谓人类视角下的 Meta，就是从真正的学习知识的角度来看什么是 Meta 的。\n比如说目前 Reinforcement Learning 上一个大量被用来测试的实验是 3D Maze Navigation。让 agent 去导航到一个目标。实验中，目标要不断变化。这意味着要使 Agent 在下一个 episode 中快速的找到目标，需要 Agent 在每一次 episode 中不断的获取 Maze 的结构和目标的位置，从而在新的 episode 能够直接去寻找的这个目标。那么，从 Meta Learning 的角度看，Maze 的结构和目标的位置就是所谓的 Meta 知识。那么这种知识在 RL 下只使用 state,action 的数据是无法得知的，还需要 reward 才能在顶层进行判断。因此，meta RL 的基本思想非常简单，就是在输入增加上一次的 reward，或者用之前的（state,action,reward）来推断 Meta 知识。虽然说 Meta-RL 是通用的，按照原作者的意思，是学习一个 rl 算法，但是在具体的比如这里的 3d navigation 问题上，推断目标位置和记忆 Maze 形状是最主要的。\n而在监督学习上，Meta 知识又完全不一样了。人类很神奇的天生具备 meta 知识不用学。比如人视觉具有的 one shot learning 能力。看一个新东西就能分辨。这个实际上是天然的具备比较不同视觉物体相似情况的能力。再有比如视觉跟踪，之前大家都只是把它当做一个计算机视觉的问题在看待，但是实际上视觉跟踪是人类的一种 Meta 能力，也是不用学的，就直接可以跟踪任何新的没见到的物体。如果有人看到一个全新的东西眼球就不会转了，那么这个世界的规律大概就不一样了。\n从一定程度上说，Meta Learning 的本意就是要学习 Meta Knowledge。Meta knowledge 可以具体如视觉的跟踪比较，也可以抽象的就是某一个学习算法。但是，显而易见的，越具体的东西越容易去研究，越抽象的东西就越难去学习。\n这里举最新的一篇 Robot Learning 的文章为例，来自 Fei-Fei Li：\nhttps://arxiv.org/abs/1710.01813\n这篇文章采用 Neural Program Induction 这个很酷的方法来做 few shot imitation learning，取得了很不错的效果。但是，我们要深究一下原理，实际上这篇文章是把一个机器人的 manipulation 通过人为的方式分解成多步动作，神经网络只需要学习如何组成这些动作，然后执行。这一定程度上大幅度简化了问题的难度。为了实现 few shot imitation learning，则让神经网络能够 meta 的根据已有的 demo 去构建动作的顺序。所以，这里的 meta 知识就是去组织动作。这个在人为的分解下变得简单了。如果没有人为分解，要求神经网络自己去发现步骤，并组织这些步骤，难度就大太多了。\nMeta knowledge 又天然的和 Hierarchical Reinforcement Learning（HRL）联系起来。我们知道 HRL 最难的部分就是去自主的学习一个好的 Hierarchy，好的 Option。但是实际上仅靠单一任务是很难做的，因为没有对比，就是我们人也不知道哪些是顶层的，哪些是底层的。但是 Meta Learning 的设定则提供了这样的实现机会。我们可以通过多个类似的任务来学习一个 meta knowledge，这个 meta knowledge 就是 hierarchy，就是高层的知识。在 OpenAI 之前很火的高中生的那篇 paper 中对这个进行了验证并取得了不错的效果：\nhttps://arxiv.org/abs/1710.09767\n3 未来的 Meta Learning 将会如何发展？\n\n2018 年马上就要到来了，这里也大胆预测一下 Meta Learning 未来的发展。可以说，当前的 Meta Learning 和 2015 年的 Deep Reinforcement Learning 非常像，刚刚起步，开始有一些很酷的应用效果（特别是 Pieter Abbeel 团队的 One shot Visual Imitation Learning 工作），目前的工作也就是几十篇文章。因此，明年，Meta Learning 必将会有一波爆发，将体现在以下两个大的方面：\n（1）理论算法研究。目前的 Meta Learning 还是百花齐放的情况，当然从我们前面对 Meta 的分析可以看到 Meta 不同角度可以看到完全不同的东西。因此，接下来还会有很多工作会基于不同的视角提出不同的算法。我们依然期待一个大一统的框架。然而目前的情况是越视角单一，越可能做的效果好，毕竟视角的选择等价于人类的知识赋予，约等于简化了神经网络的学习难度。完全通用的 Meta Learning 比如 MAML 这种要打败专门设计的算法会有难度，这其实也给了大家很多机会（现在 Chelsea Finn 在 MAML 上疯狂的灌）\n（2）具体应用研究。目前监督学习主要是 image recognition。这显然是很局限的。Meta Learning，或者 few shot learning 可以应用到视觉语音等各种方面。因此，新的应用研究也是很值得做的。从今年 few shot visual recognition 研究中已经可以看到迹象，小实验像 omniglot 这种已经基本解决，开始向 large scale 的数据发起进攻。从这里也看出 few shot learning 开始从很不可能变成可能了。然后另一块很重要的当然是 Robot Learning 了。本来研究 Meta Learning 就不是为了区区的视觉图像，而是机器人的快速学习，这个有很强的现实意义，是大幅度推进机器人革命的关键一步。因此，明年如果没有超越 MAML 的算法出现，会是难以想象的。更强的 few shot imitation learning 感觉会彻底的改变 imitation learning 这个领域。然后 HRL 结合 Meta Learning 也是必然的趋势，高中生那篇文章还是稍显简单了，更通用更强大的 Meta HRL 算法恐怕也要问世，而这显然可以应用在星际 2 上，所以 DeepMind 不研究也不行呀。\n","tags":["论文"]},{"title":"怎么理解TCP的面向连接和UDP的无连接","url":"/2023/01/30/simpread-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%20TCP%20%E7%9A%84%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E5%92%8C%20UDP%20%E7%9A%84%E6%97%A0%E8%BF%9E%E6%8E%A5%EF%BC%88%E4%B8%8D%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%EF%BC%89%EF%BC%9F/","content":"\n初始传输层前面说过，传输层的作用是建立应用程序间的端到端连接，为数据传输提供可靠或不可靠的通信服务。传输层有两个重要协议，分别是 TCP 和 UDP。TCP 是面向连接的可靠传输协议，UDP 是无连接的不可靠传输协议。\n\n一个 IP 地址可以标识一台主机，IP 报文头部有一个字段，用来标识上层协议类型。根据这个字段的协议号，来识别 IP 传输的数据是 TCP 还是 UDP 。IP 用协议号 6 标识 TCP ，用协议号 17 标识 UDP 。但一台主机可能同时有多个程序，传输层的 TCP 和 UDP ，为了识别上一层的应用程序类型，使用端口号来识别具体的程序，从而使这些程序可以复用网络通道。\n\n二层的帧通信和三层的包通信都是无连接的、不可靠的通信方式，**四层的 TCP 却是一种可靠的通信方式**。如果帧在传输中丢失，通信双方的二层功能模块发现不了；如果包在传输中丢失，通信双方的三层功能模块发现不了。燃鹅，一个 TCP 段丢失了，TCP 模块一定能够发现。一个 TCP 段的丢失，意味着一个 IP 包的丢失，因为 TCP 段是封装在 IP 包里的；同理，一个 IP 包的丢失，意味着一个帧的丢失。因此，二层和三层通信的不可靠性在 TCP 这里得到补偿。\n\n应用程序其实就是 TCP/IP 的应用协议，应用协议大多以客户端 / 服务端的形式运行。客户端（ Client ，使用服务的一方。）是请求的发起端。而服务端（ Server ，提供服务的程序或主机。）则是请求的处理端。作为服务端的程序有必要提前启动，随时准备接收客户端的请求。否则即使有客户端的请求发过来，也无法进行处理。\n\n确认一个请求究竟是发给哪一个服务端，可以通过收到数据包的目的端口号轻松识别。当收到 TCP 的建立连接请求时，如果目的端口号是 22 ，则转给 SSH ，如果是 80 则转给 HTTP 。\nTCPTCP 是面向连接的、可靠的流协议。流就是不间断的数据，当应用程序采用 TCP 发送消息时，虽然是按顺序发送，但接收端收到是没有间隔的数据流。比如，在发送端应用程序发送了 10 次 100 字节的数据，那么在接收端，应用程序可能会收到一个 1000 字节连续不间断的数据。\n\nTCP 为提供可靠性传输，实行顺序控制、重发控制机制。此外还有流量控制、拥塞控制、提高网络利用率等众多功能。\nUDPUDP 是不具有可靠性的协议，可靠性功能交给上层的应用去完成。UDP 虽然可以确保发送数据的大小，比如：发送端应用程序发送一个 100 字节的消息，那么接收端应用程序也会以 100 字节为长度接收数据。但不能保证数据一定会到达。因此，应用有时会根据需要进行重发处理。\n\nTCP 和 UDP 的区别TCP 是可靠的传输协议，一定会优于 UDP 吗？其实不然，TCP 是面向连接的，并且具备顺序控制、重发控制等机制，可以为应用提供可靠传输。而 UDP 主要用于对高速传输和实时性有较高要求的通信。比如：通过 IP 电话进行通话。如果使用 TCP ，数据如果丢失会重发，这样就无法流畅地传输通话的声音，导致无法进行正常交流。而采用 UDP ，它不会进行重发处理。也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也只会影响小部分的通话。因此，**TCP 和 UDP 需要根据应用的目的选择使用**。\n端口号数据链路层和网络层的地址，分别是 MAC 地址和 IP 地址。MAC 地址用来标识同一网段中不同的设备，IP 地址标识网络中的主机或路由器。传输层的地址就是端口号，端口号用来识别同一台主机中不同的应用程序，也被称为**程序地址**。\n一台主机可以同时运行多个程序，比如 WWW 服务的 Web 浏览器、电子邮箱客户端等程序都可同时运行。传输层协议正是利用这些端口号，识别主机正在进行通信的应用程序，并准确的传输数据。\n\n仅仅通过目的端口来识别某一个通信是不准确的。两台主机访问的目的端口号 80 相同，可以根据源端口号区分这两个通信。\n目的端口号和源端口号相同，但是两台主机的源 IP 地址不同；IP 地址和端口号都一样，只是协议号不同。这些情况，都会认为是两个不同的通信。\n因此，网络通信中通常采用 5 个信息来识别一个通信。它们是源 IP 地址、目的 IP 地址、协议号、源端口号、目的端口号。只要其中一项不同，就会认为是不同的通信。\n\nTCP/UDP 的端口号是一个 16 位二进制数，端口号范围为 0 ~ 65535 。在实际进行通信时，要事先确定端口号。确定端口号的方法分为两种：\n\n  标准端口号\n  这种方法也叫静态方法。它是指每个应用程序都有指定的端口号。HTTP 、TELNET 、FTP 等常用的应用程序所使用的端口号是固定的，这些端口号又称为知名端口号。知名端口号范围是 0 ~ 1023 。\n  除了知名端口号外，还有一些端口号也被正式注册，称为注册端口。它们分布在 1024 ~ 49151 之间。\n\n\n\n  时序分配法\n  这种方法也叫动态分配法。服务端有必要确定监听的端口号，但是接受服务的客户端不需要确定端口号。\n  客户端应用程序不用设置端口号，由操作系统进行分配。操作系统可以为每个应用程序分配不冲突的端口号。比如：每需要一个新的端口号时，就在之前分配号码的基础上加 1 。这样，操作系统就可以动态管理端口号了。\n  动态分配的端口号范围是 49152 ~ 65535 之间。\n\nUDPUDP ，全称 User Datagram Protocol 。UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的、不可靠的通信服务。并且它是将应用程序发来的数据，在收到的那一刻，立即按照原样发送到网络上的一种机制。\n即使在网络出现拥堵的情况下，UDP 也无法进行流量控制。传输途中出现丢包，UDP 也不负责重发。当出现包的到达顺序错误时也没有纠正的功能。如果需要这些细节控制，那么需要交由**上层的应用程序去处理**。也可以说，是损失信息传输的可靠性来提升信息传输的效率。\nUDP 的特点如下：\n\n  UDP 是无连接的：UDP 发送数据前不与对方建立连接。\n  UDP 不对数据进行排序：UDP 报文的头部没有数据顺序的信息。\n  UDP 对数据不发送确认，发送端不知道数据是否被正确接收，也不会重发数据。\n  UDP 传送数据比 TCP 快，系统开销也少。\n  UDP 缺乏拥塞控制机制，不能够检测到网络拥塞。\n\n由于 UDP 面向无连接，它可以随时发送数据。再加上 UDP 本身的处理既简单又高效，因此常用于以下几个方面：\n\n  包总量较少的通信（ DNS 、SNMP 等）\n  视频、音频等多媒体通信（即时通信）\n  只在局域网使用的应用通信\n  广播通信（广播、多播）\n\n\nTCPUDP 将部分控制转移给应用程序去处理，只提供作为传输层协议的最基本功能。与 UDP 不同，TCP 是对传输、发送、通信进行控制的协议。主要特点如下：\n\n  三次握手建立连接：确保连接建立的可靠性。\n  端口号：通过端口号识别上层协议和服务，实现网络的多路复用。\n  完整性校验：通过计算校验和，保证接收端能检测出传输过程中可能出现的错误。\n  确认机制：对于正确收到的数据，接收端通过确认应答告知发送方，超出一定时间后，发送方将重传没有被确认的段，确保传输的可靠性。\n  序列号：发送的数据都有唯一的序列号，标识了每一个段。接收端可以利用序列号实现丢失检测、乱序重排等功能。\n  窗口机制：通过可调节的窗口，TCP 接收端可以告知希望的发送速度，控制数据流量。\n\nTCP 实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序错误的分包进行顺序控制。作为一种面向有连接的协议，只有在确定对端存在时，才会发送数据，从而可以控制通信流量的浪费。由于 UDP 没有连接控制，即使对端不存在或中途退出网络，数据包还是能够发送出去。\n\n  连接\n  连接是指网络中进行通信的两个应用程序，为了相互传递消息而专有的、虚拟的通信线路，也叫做虚拟电路。\n  一旦建立了连接，进行通信的应用程序只使用这个虚拟线路发送和接收数据，就可以保障信息的传输。应用程序可以不用考虑 IP 网络上可能发生的各种问题，依然可以转发数据。TCP 则负责连接的建立、断开、保持等管理工作。\n\n\n为了在不可靠的 IP 通信实现可靠性传输，需要考虑很多事情，数据的破坏、丢包、重复以及分片顺序混乱等问题。**TCP 通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输**。\n\n序列号和确认应答在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个已收到的消息。这个消息叫做确认应答（ ACK ）。\n\n**TCP 通过确认应答实现可靠的数据传输**。当发送端将数据发出后，会等待对端的确认应答。如果有确认应答，说明数据已经成功到达对端。否则，数据可能已经丢失。\n在一定时间内没有等到确认应答，发送端会认为数据已经丢失，并进行重发。这样，即使有丢包，仍能保证数据到达对端，实现可靠传输。\n\n未收到确认应答，不一定是数据丢失。也可能对端已经收到数据，返回的确认应答在途中丢失，也会导致发送端重发。此外，也可能确认应答延迟到达，发送端重发数据后才收到。\n\n每一次传输数据时，TCP 都会标明段的起始序列号，以便对方确认。在 TCP 中并不直接确认收到哪些段，而是通知发送方下一次应该发送哪一个段，表示前面的段已经收到。比如：收到的确认应答序列号是 N + 1 时，表示 N 以及 N 之前的数据都收到了。\n\n由于每一个段都有唯一的编号，这样的话，当接收端收到重复的段时容易发现，数据段丢失后也容易定位，乱序后也可以重新排列。\n超时重发超时重发是指在重发数据之前，等待确认应答到来的那个间隔时间。如果超过 RTT（往返时间），仍未收到确认应答，发送端将进行数据重发。\n\n数据被重发后，若还收不到确认应答，则再次发送。这时，等待确认应答的时间将会以 2 倍、4 倍的指数函数增长。数据也不会无限地重发，达到一定的重发次数后，还没收到确认应答，就会认为网络或对端主机发送异常，强制关闭连接，并通知应用通信异常强行终止。\nRTT 时间是一个非常重要的参数。过大的 RTT 会导致 TCP 重传非常慢，降低传输的速度；过小的 RTT 会导致 TCP 频繁重传，降低资源的使用效率。在实际情况下，通过实时跟踪数据往返的时间间隔来动态调整 RTT 的数值。\n连接管理TCP 提供面向有连接的通信传输，面向有连接是指在数据通信前做好通信两端的准备工作。在数据通信前，发送一个 SYN 包作为建立连接的请求。如果对端发来确认应答，则认为可以开始数据通信。如果对端的确认应答未能到达，就不会进行数据通信。在通信结束时，会使用 FIN 包进行断开连接的处理。\nSYN 包和 FIN 包是通过 TCP 头部的控制字段来管理 TCP 连接。一个连接的建立与断开，正常过程至少需要来回发送 7 个包才能完成。建立一个 TCP 连接需要发送 3 个包，这个过程叫作三次握手。断开一个 TCP 连接需要发送 4 个包，这个过程也称作四次挥手。创建一个 TCP 连接，会产生一个 32 位随机序列号，因为每一个新的连接使用一个新的随机序列号。\n\n三次握手主机 A 想向主机 B 发送数据，TCP 模块通过三次握手建立连接 TCP 会话。\n三次握手，是指 TCP 会话建立过程中共交换了 3 个 TCP 控制段，它们分布是 SYN 段、SYN + ACK 段、ACK 段。详细过程如下：\n\n 发送端主机 A 向接收端主机 B 发出 SYN 段，表示发起建立连接请求，同时把自己的状态告诉主机 B 。将段的序列号设为 a ，SYN 置位，表示 SYN 管理段。\n 主机 B 收到连接请求后，回应 SYN + ACK 段，将序列号设为 b ，确认号设为 a + 1 ，同时将 SYN 和 ACK 置位。\n 主机 A 收到主机 B 的连接确认后，发送 ACK 段再次进行确认，确认会话的建立，将 ACK 置位。主机 A 收到确认号是 a + 1 、序列号是 b 的段后，发送序列号为 a + 1 、确认号为 b + 1 的段进行确认。\n 主机 B 收到确认报文后，连接建立。双方可以开始传输数据。\n\n\n经过 3 次握手后，**A 和 B 之间其实是建立了两个 TCP 会话**，一个是从 A 指向 B 的 TCP 会话，另一个是从 B 指向 A 的 TCP 会话。A 发送的 SYN 段，表示 A 请求建立一个 从 A 指向 B 的 TCP 会话，目的是控制数据能够正常、可靠的从 A 传输到 B 。B 在收到 SYN 段后，会发送一个 SYN + ACK 段作为回应。SYN + ACK 的含义是：B 一方面同意了 A 的请求，另一方面也请求建立一个从 B 指向 A 的 TCP 会话，这个会话目的是控制数据能够正确、可靠的从 B 传输到 A 。A 收到 SYN + ACK 段后，回应一个 ACK ，表示同意 B 的请求。\n四次挥手当 TCP 数据段的传输结束时，双方都需要发送 FIN 段和 ACK 段来终止 TCP 会话。这个方式叫做四次挥手，详细过程如下：\n\n 主机 A 想要终止连接，发送序列号为 p 的段，FIN 置位，表示 FIN 管理段。\n 主机 B 收到主机 A 发送的 FIN 段后，发送 ACK 段，确认号为 p + 1 ，同时关闭连接。\n 主机 B 发送序列号为 q 的段，FIN 置位，通知连接关闭。\n 主机 A 收到主机 B 发送的 FIN 段后，发送 ACK 段，确认号为 q + 1 ，同时关闭连接。TCP 连接至此结束。\n\n\nTCP 会话的终止分为两个部分。首先 A 发送 FIN 控制段，请求终止从 A 到 B 的 TCP 会话。B 回应 ACK 段，表示同意 A 的终止会话请求。A 收到 B 的 ACK 段后，才开始终止这个会话。同理，B 也会向 A 发起请求，终止从 B 到 A 的 TCP 会话。\n单位段经过传输层协议封装后的数据称为段。在建立 TCP 连接时，可以确定数据段的大小，也就是最大消息长度（ MSS ）。TCP 在传输大量数据时，是以 MSS 的大小将数据进行分割发送，重发也是以 MSS 为单位。\n\nMSS 是在三次握手时，由两端主机计算出来的。两端主机在发出建立连接的请求时，会在 TCP 头部写入 MSS 值。然后在两者间选择较小的值使用。MSS 默认值为 536 字节，理想值是 1460 字节，加上 IP 头部 20 字节和 TCP 头部 20 字节，刚好在 IP 层不会被分片。\n\n窗口控制TCP 是以 1 个段为单位，每发一个段进行一次确认应答。如果包的往返时间越长，通信性能就越低。\n\n为解决这个问题，TCP 引入了窗口的概念。确认应答不再是每个分段，而是以窗口的大小进行确认，转发时间被大幅度的缩短。窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。窗口大小是一个 16 位字段，因此窗口最大是 65535 字节。在 TCP 传输过程中，双方通过交换窗口的大小来表示自己剩余的缓冲区（ Buffer ）空间，以及下一次能够接受的最大数据量，避免缓冲区的溢出。\n\n发送数据中，窗口内的数据即使没有收到确认应答也可以发送出去。如果窗口中的数据在传输中丢失，也需要进行重发。因此，发送端主机在收到确认应答前，必须在缓冲区保留这部分数据。\n收到确认应答后，将窗口滑动到确认应答中的序列号位置。这样可以按顺序将多个段同时发送，这种机制也被称为**滑动窗口控制**。\n\n窗口控制和重发控制在使用窗口控制时，如果出现确认应答未能返回的情况，数据已经到达对端，是不需要再进行重发的。然而，在没有使用窗口控制时，没收到确认应答的数据是会重发的。而使用了窗口控制，某些确认应答即使丢失也无需重发。\n\n如果某个报文段丢失，接收主机收到序号不连续的数据时，会为已经收到的数据返回确认应答。即使接收端收到的包序号不是连续的，也不会将数据丢弃，而是暂时保存至缓冲区。出现报文丢失时，同一个序号的确认应答将会被重复发送。如果发送端收到连续 3 次同一个确认应答，就会将对应的数据进行重发。这种机制比超时管理更高效，也被称为高速重发机制。\n\n流控制接收端处于高负荷状态时，可能无法处理接收的数据，并丢弃数据，就会触发重发机制，导致网络流量无端浪费。\n为了防止这种情况，TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是流控制。它的具体操作是，接收端主机通知发送端主机自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据。这个限度的大小就是窗口大小。\nTCP 头部中有一个字段用来通知窗口大小。接收主机将缓冲区大小放入这个字段发送给接收端。当接收端的缓存不足或处理能力有限时，窗口大小的值会降低一半，从而控制数据发送量。也就是说，发送端主机会根据接收端主机的指示，对发送数据的量进行控制，也就形成了一个完整的 TCP 流控制。\n若接收端要求窗口大小为 0 ，表示接收端已经接收全部数据，或者接收端应用程序没有时间读取数据，要求暂停发送。\n\n如果窗口更新的报文丢失，可能会导致无法继续通信。为避免这个问题，发送端主机会时不时的发送一个叫窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。\n拥塞控制有了 TCP 的窗口控制，收发主机之间不再以一个数据段为单位发送确认应答，也能够连续发送大量数据包。在网络出现拥堵时，如果突然发送一个较大量的数据，有可能会导致整个网络瘫痪。\n为了防止这个问题出现，在通信开始时，就会通过一个叫慢启动的算法得出的数值，对发送数据量进行控制。\n\n为了在发送端调节发送数据的量，需要使用拥塞窗口。在慢启动时，将拥塞窗口的大小设置为 1 MSS 发送数据，之后每收到一次确认应答（ ACK ）, 拥塞窗口的值就加 1 。在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，选择它们当中较小的值发送数据。这样可以有效减少通信开始时连续发包导致网络拥堵，还可以避免网络拥塞的发生。\nTCP 和 UDP 的对比\nUDP 格式UDP 段由 UDP 头部和 UDP 数据组成。UDP 头部有源端口号、目的端口号、长度、校验和组成，UDP 头部长度为固定的 8 字节。\n\n\n  源端口号：字段长 16 位，表示发送端 UDP 端口号。\n  目的端口号：字段长 16 位，表示接收端 UDP 端口号。\n  长度：字段长 16 位，表示 UDP 头部和 UDP 数据的总长度。\n  校验和：字段长 16 位，是错误检查的字段，包括 UDP 头和 UDP 数据的内容计算得出，用于检查传输过程中出现的错误。\n\nTCP 格式TCP 头部比 UDP 头部复杂得多，由一个 20 字节的固定长度加上可变长的选项字段组成。\n\n\n  源端口号：字段长 16 位，表示发送端 TCP 端口号。\n  目的端口号：字段长 16 位，表示接收端 TCP 端口号。\n  序列号：字段长 32 位，是指 TCP 段数据的位置序号。根据序列号来判断是否存在重收、漏收、乱序等情况。\n  确认号：字段长 32 位，是指下一次应该收到的数据的序列号。收到这个确认号，表示这个确认号之前的数据都已经正常收到。\n  数据偏移：字段长 4 位，表示 TCP 数据从哪一位开始计算，也可以看作 TCP 头部的长度。\n  保留：字段长 6 位，保留给以后扩展使用。\n  控制位：字段长 6 位，每 1 位标志位可以打开一个控制功能，也叫做控制位。从左到右分别是 URG 、ACK 、PSH 、RST 、SYN 、FIN 。\n\n\n\n  URG：标志位为 1 时，表示有需要紧急处理的数据。\n\n  ACK：标志位为 1 时，表示确认应答有效。\n\n  PSH：标志位为 1 时，表示将数据立即上传给应用程序，而不是在缓冲区排队。\n\n  RST：标志位为 1 时，表示 TCP 连接出现异常，必须强制断开连接。\n\n  SYN：标志位为 1 时，表示请求建立连接，并设置序列号的初始值。\n\n  FIN：标志位为 1 时，表示数据发送结束，请求断开 TCP 连接。\n\n  窗口：字段长 16 位，标明滑动窗口的大小，表示自己还能接收多少字节的数据。\n\n  校验和：字段长 16 位，是错误检查的字段，包括 TCP 头和 TCP 数据的内容计算得出，用于检查传输过程中出现的错误。\n\n  紧急指针：字段长 16 位，表示紧急数据的长度。当 URG 位为 1 时，这个字段才有效。\n\n  选项：字段的长度是可变的。通过添加不同的选项，实现 TCP 的一些扩展功能。\n\n  填充：如果 TCP 段的头部不是 4 字节的整数倍，就填充一些 0 ，来保证头部长度是 4 字节的整数倍。\n\n  数据：TCP 段的数据部分，不是 TCP 头部内容，字段最大是 MSS 。\n\n\n车小胖​\n\n亚当和夏娃分别生活在两个山头，山头之间是万丈深渊，亚当采集野果需要分享给夏娃，如果他们之间有一条索道（物理连接），野果可以顺着索道滑到夏娃那一边，那就没有车小胖什么事了。\n事实上山头之间没有索道，但是亚当何等聪明，于是他想出了一个方法，假设亚当需要给夏娃 10 个野果，否则她会饿死。\n连接建立\n亚当对着夏娃大喊：爱妃，你听得到吗？\n夏娃回应：孩他爹，我听得到！\n亚当接着喊：那好，我扔果子给你吃，你接到果子就喊一声，一共十个。\n运送货物\n于是亚当开始扔第一个，夏娃喊收到了一个。\n亚当扔第二个，夏娃喊收到两个。\n超时重传 （ timeout retransmit)\n亚当扔第三个，可是夏娃迟迟没有回音，亚当意识到可能果子落到悬崖了，于是重新扔，夏娃喊收到第三个。\nAdvertised window size = 0\n于是亚当连续扔了第四、五、六个，夏娃急了：孩他爹，慢点扔，臣妾忙不过来了…\nAdvertised window size &gt; 0  \n于是亚当坐下休息，爱妃又开始叫了：继续扔吧。\n亚当开始扔第七个，夏娃喊收到七个。\n…\n关闭连接\n终于亚当扔完了，亚当喊：爱妃，果子扔完了，寡人去忙别的了。\n夏娃回复：好的，我也休息一下，再见\n亚当：再见\n以上的过程类似 TCP 连接的过程，TCP 是一个虚拟连接。\n何为虚拟连接？\n和物理连接所对应，物理连接是实实在在存在的，看得见摸得着，比如索道。而虚拟连接是不存在的，看不见摸不着，通过双向的消息、消息确认来模拟物理连接。\n由于有确认机制，亚当可以确保夏娃可以收到 10 个果子。\n那接下来再谈谈什么是无连接的 UDP？\n亚当和夏娃吵架了，任凭亚当如何大声喊，夏娃躲在树林后生闷气，一声不响，亚当害怕夏娃饿死，于是开始自说自话朝着夏娃的山头扔玉米棒子：\n一个、两个、三个…\n一共扔了十个，但最终扔到对方山头到底有几个，亚当没有底，也许有的玉米棒子落到悬崖了，但是这个效率高啊，可以连续扔，以前扔 10 个果子需要一分钟，现在只需要 20 秒。\n亚当扔果子、扔玉米都有可能扔到悬崖下，但是扔果子为何可以确保对方收到十个？那是因为夏娃收到一个果子，然后喊收到了，如果没有收到，亚当就重新扔，直到夏娃说收到了。而扔玉米棒子对方没有确认，所以对于丢弃的情况无法知道，也无法重新扔。\n2018.08.16 文章更新于公众号，欢迎阅读：\n更新系列一：怎么理解 TCP 的面向连接和 UDP 的无连接（不面向连接）？\nDuke​\n“我给你讲一个关于 TCP 的笑话。”\n“好的你给我讲一个关于 TCP 的笑话。”\n“好的。”\n“苟。这是第一个字。”\n“第一个字收到，请发第二个字。”\n“利。这是第二个字。”\n“第二个字收到，请发第三个字。”\n“国。这是第三个字。”\n“国。这是第三个字。”\n“第三个字收到，请发第四个字。”\n“家……”\n……\n“我讲完了。”\n“好的。我听完了。”\n“好的。”\n“我给你讲一个关于 UDP 的笑话。”\n“咦我好像听见一个关笑 P 话的 U……？咦这苟啊国家啊这什么什么之是啥玩意？我让应用层看看…… 应用层说应该是两句诗？”\n","tags":["计算机网络"]},{"title":"好看的几个CSDN背景图","url":"/2021/05/02/simpread-%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%87%A0%E4%B8%AA%20CSDN%20%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BE_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2_csdn%20%E7%9A%84%E8%83%8C%E6%99%AF%E5%9B%BE/","content":"以下是比较好看的  CSDN 背景图\n保存一下\nhttps://blog.csdn.net/qq_36650546\nhttps://blog.csdn.net/weixin_54225634https://blog.csdn.net/weixin_45157820\nhttps://blog.csdn.net/eastmount?spm=1000.2115.3001.4128\n","tags":["喜欢"]},{"title":"桌面云（Citrix+XenAppXenDesktop）","url":"/2023/01/31/simpread-%E6%9C%80%E5%85%A8%E6%95%B4%E5%A5%97%E4%BC%81%E4%B8%9A%E4%BA%91%E6%A1%8C%E9%9D%A2%EF%BC%88Citrix+XenApp&XenDesktop%EF%BC%89%E9%83%A8%E7%BD%B2%E6%89%8B%E5%86%8C/","content":"一、案例概述为了方便对公司办公计算机桌面系统的管理，公司需要搭建一套桌面虚拟化平台。公司运维工程师决定使用 Cirtix 桌面 虚拟化解决方案。Citrix XenServer 服务器虚拟化系统通过更快的应用交付、更高的 IT 资源可用性和利用率，使数据中心变得更加灵活、高效。在提供关键工作负载（操作系统、应用和配置）所需的先进功能的同时，也不会牺牲大规模部署必需的、易于操作的特点、\n二、案例前置知识点1、桌面虚拟化介绍桌面虚拟化是指将计算机的桌面进行虚拟化，以达到桌面使用的安全性和灵活性，可以通过任何设备，在任何地点、任何时间访问在网络上的属于用户个人的桌面系统。如下图：  \n\n2、XenServerXenServer 是由美国 Citrix 公司推出的一种服务器虚拟化平台，其功能强大、丰富，具有卓越的开放性架构、性能和存储集成。它是基于开源 Xen Hypervisor 的免费虚拟化平台，该平台引进了多服务器管理控制台 XenServer，具有强大管理能力。安装 XenServer 硬件要求如下：1、CPU：一个或多个 x86_64 位 CPU，最低 1.5GHz，建议 2GHz 以上或更快的多核 CPU。  \n2、内存：最低 2GB，建议 4GB 或更多。  \n3、硬盘：本地存储（PATA、SATA、SCSI），最低 46GB，建议 70GB 磁盘空间。  \n4、网卡：100Mb/s 或更快的 NIC\n3、XenDesktopXenDesktop 安装向导是一种工具，自动完成虚拟桌面大型安装的创建和交付部分。此向导集成了 Citrix 组件，系统管理员可以快速创建多个桌面。\n4、XenCenterXenCenter 是在独立的计算机上运行的独立应用程序。通过 XenCenter 可以创建和管理虚拟服务器、虚拟机模板、快照、共享存储支持、资源池和 XenMotion 实时迁移。\n1）安装 XenCenter 操作系统要求如下：\n\n  Windows 7 SP1、Windows 8.1、Windows 10（.NET Framework 版本号基于. NET4.6）。\n  Windows server 2008 SP2、Windows server 2008 R2 SP1（.NET Framework 版本号基于. NET4.6）。\n  Windows server 2012、Windows server 2012 R2（.NET Framework 版本号基于. NET4.6）。\n\n2）安装 XenCenter 硬件要求如下：\n\n  CPU 主频最低为 750MHz，建议使用 1GHz 及以上。\n  内存最低为 1GB，建议使用 2GB 及以上最低为 100MB。\n  网卡为 100Mb/s 或更快的 NIC。\n  屏幕分辨率最低为 1024 X 768 像素。\n\n5、Desktop Delivery Controller桌面传送控制器（Desktop Delivery Controller，DDC）是 XenDesktop 的一个组件，可以单独安装，也可以把所有组件安装在一起。该控制器安装在数据中心的服务器上，用于对用户进行身份验证，管理用户虚拟桌面环境的程序集，以及代理用户及其虚拟桌面之间的连接。它控制桌面的状态，根据需要管理配置启动和停止它们。其中的 Profile Management 还可以管理 Windows 环境中用户个性化设置 VDA\n虚拟桌面访问（Virtual Desktop Access，VDA）是一种授权策略，是指每个访问虚拟桌面的设备都要获取的访问许可。它是通过许可访问虚拟桌面的设备，而不是许可虚拟桌面本身。\n三、案例环境\n此案例用到的所有工具 可以访问网盘下载链接：https://pan.baidu.com/s/1JEsDt-DI88DKz7aEn8PisQ&amp;shfl=sharepset提取码：v287复制这段内容后打开百度网盘手机 App，操作更方便哦\n四、问题分析XenServer 对服务器的配置要求并不太高，处理器要求是一个或多个 64 位 x86 x86CPU，主频最低位 1.5GHz；内存要求最低为 2GB；硬盘本地连接的存储（PATA、SATA、SCSI），最低磁盘空间为 46GB；千兆网卡。由于服务器上要运行虚拟机，因此建议在实际生产环境中资源配置应该 根据应用规模适度调节。\n五、案例实施1、新建 XenServer：选择典型安装，单击下一步  \n\n选择稍后安装操作系统，单击下一步  \n\n选择 Linux 操作系统，版本选择 Red Hat Enterprise Linux 5 版本，单击下一步  \n\n编辑虚拟机名字，浏览安装位置，单击下一步  \n\n磁盘空间调为 500GB，单击下一步  \n\n新建完成  \n\n编辑虚拟机处理器  \n\n编辑虚拟机内存，网卡 VM2，挂载光盘，开启虚拟机  \n\n键盘选择 US，单击 OK  \n\n选择 OK 开始进行安装  \n\n阅读许可协议，单击 Accept EULA  \n\n安装在 500G 硬盘，默认已经选中，单击 OK  \n\n选择从本地启动，单击 OK  \n\n不添加数据包，单击 NO  \n\n选择跳过  \n\n配置密码  \n\n手动配置 IP 地址、网关子网掩码  \n\n修改计算机名。配置 DNS  \n\n时区选择亚洲上海  \n\n手动配置时间  \n\n开始安装  \n\n安装中  \n\n配置时间  \n\n安装完成，重启即可  \n\n2、开启 DC01_AD ：\n配置 IP 地址  \n\n添加域服务  \n\n一流下一步，安装即可  \n\n安装完成，设置为域控制器  \n\n选择添加新林，设置域名，单击下一步  \n\n设置域控制器密码  \n\n默认下一步  \n\n开始安装  \n\n域管理员登录  \n\n关闭域防火墙  \n\n修改 DNS  \n\n域控制器添加数据库管理员账户 sqladmin  \n\n用户设置密码  \n\n用户 隶属于 domain admins  \n\n3、开启 DC02_SQL：\n配置 IP 地址、子网掩码和 DNS  \n\nDC02_SQL 加入域  \n\n登录域  \n\n将 sqladmin 数据库管理员用户添加到本地 administrators 组  \n\n将本地管理员 administrator 禁用  \n\n注销使用数据库管理员 sqladmin 账户登录域  \n\n关闭域防火墙  \n\n安装. NAT Framework 3.5  \n\n一流下一步安装即可  \n\n安装完成  \n\n切换 sql_server_2008_R2 光盘  \n\n打开 DVD，选择全新安装  \n\n检查先决条件，通过后单击确定  \n\n输入产品密钥  \n\n接受许可条款，单击下一步  \n\n单击安装，开始安装  \n\n一条警告，忽略下一步  \n\n选择 SQL Server 功能安装，单击下一步  \n\n勾选数据库引擎和管理工具，单击下一步  \n\n默认下一步  \n\n选择默认实例，单击下一步  \n\n单击下一步  \n\n配置服务器账户密码  \n\n选择混合模式，输入密码，添加当前账户  \n\n默认下一步  \n\n先决条件通过单击下一步  \n\n单击安装  \n\n安装完成  \n\n4、开启 DC03_XenCenter：配置 IP 地址、子网掩码和 DNS  \n\nDC03_XenCenter 加入域  \n\n重启使用本地管理员登录域  \n\n关闭域防火墙  \n\n安装 windows 8.1-KB2919442-x64  \n\n安装完成  \n\n安装 windows 8.1-KB2919355-x64  \n\n安装完成，重启计算机  \n\n重启完成后安装 http://Microsoft.NET 2015  \n\n安装完成，重启计算机  \n\n选择所有用户，单击下一步  \n\n单击安装  \n安装完成  \n\n打开 Citrix XenCenter  \n\n连接服务器  \n\n连接成功，确定即可  \n\n切换 sql 光盘，安装 sql 客户端  \n\n选择全新安装  \n\n检查先决条件，单击确定  \n\n输入产品密钥  \n\n接受许可条款，单击下一步  \n\n单击安装  \n\n单击下一步  \n\n选择 SQL Server 功能安装，单击下一步  \n\n勾选管理工具，单击下一步  \n\n检查完成，单击下一步  \n\n默认下一步  \n\n单击安装  \n\n安装完成  \n\n连接数据库  \n\n输入 SQL 服务器名称，选择身份验证，输入登录名和密码，单击连接  \n\n成功连接数据库  \n\n切换 XenAPP_and_XenDesktop 光盘  \n\n打开 DVD，启动 XenDesktop  \n\n点击安装 Delicery Controller  \n\n接受许可条款，单击下一步  \n\n勾选安装全部核心组件，单击下一步  \n\n勾选安装 windows 远程协助，单击下一步  \n\n防火墙规则选择手动配置，单击下一步  \n\n单击安装  \n\n安装完成  \n\n基础环境已经全部搭建完成，接下来开始配置\n首先在域控制器创建一个组织单位  \n\nXen_Client 里创建 3 个测试账户  \n\n账户创建完成  \n\n在 DC02_SQL 部署 DHCP  \n\n一流下一步开始安装  \n\n安装完成  \n\n新建作用域  \n\n单击下一步  \n\n编辑作用域名字  \n\n输入地址范围  \n\n默认下一步  \n\n选择否，单击下一步  \n\n作用域新建完成  \n\n添加 DNS  \n\n打开 DC03_XenCenter\n复制 Windows 7 光盘到虚拟机，创建共享文件夹将光盘共享  \n\n打开 XenCenter，连接服务器  \n\n连接共享  \n\n选择 Windows 文件共享  \n\n编辑名字  \n\n输入共享名称，  \n\n选择向用户交付应用程序和桌面  \n\n编辑站点名字，单击 下一步  \n\n连接数据库  \n\n默认下一步  \n\n连接 XenServer  \n\n编辑网络名字，单击下一步  \n\n默认下一步  \n\n选择否，以后加入，单击完成  \n\n配置完成  \n\n开启 win7_01  \n\n运行 cmd 释放 IP 地址重新获取 DHCP 自动下发  \n\nIpconfig/all 查看详细信息，查看 DNS 是否正确  \n\n计算机加入域，重启计算机  \n\n将域控制器创建的 bob 账户添加到本地 administrators 组  \n\n禁用本地 administrator，注销使用 bob 登录域  \n\nBob 登录域  \n\n切换光盘  \n\n选择 XenDesktop 交付应用程序和桌面  \n\n单击 Virtual Delivery Agent for Windows Desktop OS  \n\n选择启用 Remote PC Access，单击下一步  \n\n选择否，单击下一步  \n\n根据需求是否勾选 Citrix Receiver，我这里用不到平板电脑或者手机，所有就不勾选了  \n\n添加 Controller 地址  \n\n默认下一步  \n\n防火墙选择手动，单击下一步  \n\n单击安装  \n\n安装完成，重启计算机  \n\n开启远程访问  \n\nXenCenter 计算机打开 Citrix Studio 应用程序创建计算机目录  \n\n选择未进行电源管理的计算机，单击下一步  \n\n桌面体验选择静态桌面，单击下一步  \n\n添加计算机  \n\n编辑计算机目录名字，单击完成  \n\n显示已注册  \n\n创建交付组  \n\n选择交付组计算机数量  \n\n选择交付桌面，单击下一步  \n\n添加用户  \n\n选择自动  \n\n编辑交付组的名字  \n\n开启 win7_02 客户端  \n\n运行 cmd，ipconfig /renew 自动获取 IP 地址  \n\n打开浏览器访问安装  \n\n安装 Citrix Receiver  \n\n安装完成  \n\nWin 7_01 更新清单，更新完成关机开启即可  \n\nBob 登录  \n\n正在连接  \n\n交付静态桌面：\n打开 XenCenter  \n\n连接 XenServer  \n\n新建存储  \n\n选择 Windows 文件共享，单击下一步  \n\n编辑共享名字，单击下一步  \n\n输入共享位置，勾选其他用户，输入用户名和密码  \n\n共享存储添加完成  \n\n新建 VM  \n\n选择操作系统，单击下一步  \n\n名字设置为 Windows 7  \n\n选择操作系统光盘  \n\n将 VM 放在此服务器上，单击下一步  \n\n内存 2GB，CPU 1 个，单击下一步  \n\n磁盘大小设置为 50GB，单击下一步  \n\n网络连接保持默认，单击下一步  \n\n开始创建  \n\n自动开启虚拟机  \n\n选择现在安装  \n\n接受许可条款，单击下一步  \n\n创建 30GB 磁盘，单击下一步  \n\n安装完成，编辑计算机名字  \n\n密码忽略，我这里就不设置了  \n\n虚拟机自动获取 IP 地址  \n\n关闭防火墙  \n\n切换光盘安装 tools  \n\n单击下一步  \n\n接受许可条款  \n\n默认安装位置  \n\n单击安装  \n\n安装完成  \n\n重启  \n\n关闭虚拟机转换为模板  \n\n新建 VM 向导  \n\n选择 VM 模板  \n\n编辑名称  \n\n默认下一步，内存 1GB  \n\n完成，立即创建  \n\n打开控制台，加入域重新启动  \n\n切换管理员登录域  \n\n关闭域防火墙  \n\n切换光盘  \n\n选择创建主映像，单击下一步  \n\n选择不安装 VDA  \n\n此选项根据个人需求勾选选项  \n\n连接 Controller 地址  \n\n功能全选，单击下一步  \n\n防火墙规则选择手动，单击下一步  \n\n开始安装  \n\n安装完成，重启计算机  \n\n更新清单  \n\n关机之后创建交付  \n\n默认下一步  \n\n选择 Windows 桌面操作系统  \n\n选择进行电源管理的计算机  \n\n选择静态桌面  \n\n默认下一步  \n\n虚拟机数量选 2 台，单击下一步  \n\n编辑账户命名方式  \n\n编辑名称  \n\n域控制器查看  \n\n创建交付组，交付数量为 2  \n\n交付桌面  \n\n添加用户  \n\n选择自动，单击下一步  \n\n编辑名称  \n\n更改交付用户  \n\nWin7_02 更改交付用户为 alice  \n\n开启 win7-01  \n\n检查远程访问  \n\n开启远程访问，添加 tom 账户  \n\n将 tom 设置为管理权限  \n\n禁用 benet 用户  \n\n用客户端浏览器访问  \n\n成功登录  \n\n注销切换 Alice 登录  \n\n开启远程访问，添加 Alice 用户  \n\n将 Alice 加入 administrators 组  \n\n禁用 benet 用户  \n\n","tags":["桌面云"]},{"title":"-秒懂二层交换机16个问题","url":"/2023/01/31/simpread-%E7%A7%92%E6%87%82%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%2016%20%E4%B8%AA%E9%97%AE%E9%A2%98%20__%20%20%20%20%20%20%20%20_%20%20%20%20%20%20%20%20Yixin%20blog/","content":"\nHexo Theme Keep\n\n1、什么是中继器？中继器（ repeater ）是一种信号增强设备，运行在 OSI 参考模型的_第一层_。它的功能仅仅是将信号重新输出，延迟网络的传输距离，不进行其它的数据控制，也无法识别数据链路层的 MAC 地址和网络层的 IP 地址。\n\n2、什么是网桥？网桥（ bridge ）是具有两个端口的_二层_网络设备，可隔离冲突域。作用相当于 OSI 模型中的数据链路层，能够根据 MAC 地址进行数据转发。只能连接同构网络 (同一网段)，不能连接异构网络（不同网段）。\n\n3、什么是集线器？集线器（ hub ）是工作在_物理层_、具有信号放大功能、以它为中心的网络设备。即一个多端口的中继器，以集线器为中心，连接多个节点。广播方式发送数据，也就是说，当它要发送数据时，会发送到与集线器相连的所有节点。\n\n由于集线器没有控制功能，因此所有终端共享带宽，同一时刻只能一个终端发送数据，多个终端同时发送数据就会产生冲突。这时，集线器、连接线缆以及连接在集线器上的终端设备构成了一个冲突域。于是采用 CSMA/CD 方式决定终端能否发送数据。\n4、什么是交换机？集线器是从接收方收到的数据，会转发给所有非发送方端口，也就是简单的通过复制电气信号来实现发送。\n但是交换机是通过学习连接的每个终端的 MAC 地址，将数据发送给对应的目的终端上，避免将数据发送到无关端口，提供网络利用率。这里说的交换机都是_二层_交换机。\n\n如果是没有学习到的 MAC 地址，或者想跟网段内所有终端进行通信，交换机会使用广播方式，将数据帧进行泛洪。\n5、交换机如何学习 MAC 地址？交换机通过数据帧的源 MAC 地址，学习到交换机端口和 MAC 地址的对应关系，并记录到交换机的 MAC 地址表中。\n主机 A 向主机 D 发送数据：A 发送数据帧，数据帧的源 MAC 地址是 11:11:11:11:11:11 ，目的 MAC 地址是 44:44:44:44:44:44 。交换机端口 1 收到数据帧，记录源 MAC 地址和端口的对应到 MAC 地址表项。交换机不知道目的 MAC 地址在哪个端口，于是将数据帧进行泛洪，即转发到除端口 1 之外的所有端口。B 和 C 发现目的 MAC 地址不是自己，将丢弃数据帧。\n\nD 发现是发送给自己的数据帧，于是发送应答数据帧，源 MAC 地址是 44:44:44:44:44:44 ，目的 MAC 地址是 11:11:11:11:11:11 。交换机端口 4 收到数据帧，记录 D 的 MAC 地址表项。于是交换机知道了主机 A 和主机 D 的 MAC 地址信息，之后会根据 MAC 地址表进行转发。交换机通过同样的方式，可以学习到主机 B 和主机 C 的 MAC 地址。\n\n6、对比集线器，交换机有哪些优点？\n7、以太网数据帧有哪些类型？\n8、交换机如何转发数据帧？交换机收到数据帧后，会有三种处理方法：_直通转发_、_碎片隔离_和_存储转发_。\n\n  直通转发\n\n直通转发是交换机只读取数据帧的前 14 个字节就进行转发。由于读取的数据量固定，发送方和接收方的速度需要一致，导致无法桥接不同速率的以太网。另外，只读取前 14 个字节，会跳过了 FCS 域，因此无法检测并丢弃 CRC 校验错误的数据帧。\n\n\n  碎片隔离\n\n碎片隔离是读取数据帧的前 64 个字节就进行转发，可以防止转发小于 64 字节的残帧。但是如果出现 CRC 错误，还是会转发数据帧。也无法桥接不同速率的以太网。\n\n\n  存储转发\n\n存在转发会读取数据帧全部内容再进行转发。这样就可以识别残帧和 CRC 校验错误帧，并将它们丢弃。交换机还能对数据帧进行缓存，因此可以桥接不同速率的以太网。\n\n9、单工和双工通信有什么区别？\n10、交换机的处理能力的指标是什么？交换机的处理能力也叫做背板容量或交换机容量。容量单位是 bit/s（比特每秒），值越大，说明交换机在单位时间内传输的数据越多。\n当交换机的所有端口的总带宽小于交换机的容量时，交换结构为非阻塞，即带宽充裕，没有等待处理的情况。反之，当所有端口总带宽超过交换机的容量时，叫做交换机结构过载。\n交换机是千兆端口时，处理能力达到端口数 × 2 × 1Gbit/s 的数值，就是非阻塞。其中 × 2 表示上行和下行都是 1Gbit/s 的全双工通信。假如交换机有 24 个端口，背板容量到达 24 × 2 × 1G = 48Gbit/s ，就是非阻塞。\n11、根据功能分类，交换机有几种类型？交换机按照功能可以分为_二层交换机_和_三层交换机_。\n\n  二层交换机\n\n没有 IP 路由功能、仅处理数据链路层的交换机叫做二层交换机。二层交换机根据不同的功能而不同。\n\n\n  三层交换机\n\n带有 IP 路由功能的交换机叫做三层交换机。\n12、根据外形分类，交换机有几种类型？根据外形，交换机可分为_桌面式交换机_、_箱式交换机_和_机框式交换机_。\n\n  桌面式交换机\n\n桌面式交换机是指放在桌面上使用的交换机。它体积不大，只能连接几台网络设备，通常用于家庭网络中，主要有 3 端口、5 端口、8 端口和 16 端口的产品。\n桌面式交换机通常不安装风扇，采用无风扇设计，运行噪声小。\n\n  箱式交换机\n\n箱式交换机通常高度是 1U 或 2U ，可以安装在 19 英寸的机柜内。通常采用金属外壳、内置电源，并配置冷却风扇。下行有 24 千兆网口或 48 千兆网口，上行有 2 万兆光口或 4 万兆光口的配置较多。下行使用 RJ-45 的网线接口，上行使用 SFP+ 槽进行连接。\n主要作为企业中作为接入交换机使用，支持电源冗余。\n\n  框式交换机\n\n框式交换机是指在机框内组合多个接口模块的交换机。可以根据需要选择端口数量和不同类型的接口模块，扩展性好，端口数量多。\n在机框中可以添加电源、风扇等组成部分，再插入管理模块和接口模块。接口模块和管理模块叫做线卡。机框上总线的主板叫做背板，可以插入线卡。\n13、根据用途分类，交换机有几种类型？根据交换机在网络中的位置和用途，可分为三类：核心交换机（核心层）、汇聚交换机（汇聚层）和接入交换机（接入层）。\n\n14、交换机有几种端口类型？选择交换机时，需要根据实际的使用需求，以及具体的端口类型、端口数量和设备性能等参数，决定购买哪款交换机。\n千兆以太网端口大部分交换机都配置了 RJ-45 的千兆以太网接口，连接千兆接口要使用增强型 5 类双绞线。通过自适应功能，还可以连接百兆接口。\n光纤端口箱式交换机会配置光纤端口，主要是用于连接上行链路。为了连接万兆以太网的上行链路，通常会搭载 SFP+ 接口。\n框式交换机中，一般会配置多个千兆以太网 SFP 或万兆以太网 SFP+ 接口的接口卡。\nPoE 端口接入交换机还会配 PoE 端口。Poe 端口使用网线连接 IP 电话或无线 AP ，并通过网线对设备进行供电。\n为了让 IP 电话或无线 AP 无需外接电源也能接入网络，通过一根网线给设备供电的技术就是 PoE 技术。PoE 技术有简化布线、节省人工成本，管理方便，使用灵活，安全等优点，得到广泛的应用。\nPoE 技术作为 IEEE 802.af 在 2003 年完成了标准化工作，这个技术还用于网络摄像头、POS 终端等连接以太网的硬件设备。\n\n  PoE（ IEEE 802.3af ） **PoE+（ IEEE 802.3at ）PoE++**（ IEEE 802.3bt ）\n\nPoE 的供电标准是 IEEE 802.3af ，最大能提供 15.4W 的功率，可以为 IP 电话、无线 AP 等终端设备供电。 PoE+ 是 PoE 的增强版，供电标准是 IEEE 802.3at ，最大能提供 30W 的功率，可以为视频电话、 摄像机等终端设备供电。 PoE++ 是 PoE+ 的增强版，供电标准是 IEEE 802.3bt ，最大能够提供 60W 的功率，能够满足更多的终端功率需求，可以为基站、室外热感摄像机等终端设备提供更大功率的供电。\n\n支持 PoE 功能的交换机，会说明每个端口最大支持 ×× W ，设备最大供电 ×× W 等电能信息，可以算出交换机最多可接入的 PoE 设备数量。\n\n上行链路端口接入交换机和汇聚交换机要集中下行连接的所有设备流量，并将流量传输到上行的网关或核心交换机中，向网关、核心交换机传输流量的端口叫做上行链路端口，反向就叫做下行链路端口。在箱式交换机中一般会配置 2~4 个万兆上行链路端口。\n\n下行链路端口通常下行链路是 RJ-45 的接口，也有使用光纤接口的。一台交换机或一块板块，能提供 24 或 48 个接口。\n\n交换机堆叠通过堆叠线缆可以把多台交换机连接起来，成为逻辑上的一台交换机。\n15、交换机有哪些功能？交换机的完整功能说明，可以查看官网的产品文档，里面进行了详细的描述。\nMAC 地址数MAC 地址数是指一台交换机最大可以学习到的 MAC 地址表数量。\n生成树功能为了避免二层环路，我们使用生成树协议（ STP ），让交换机知道对方的存在，具体做法是在交换机之间交换 BPDU 数据帧。详情可看《图解 STP 》和《图解 RSTP 和 MSTP 》。\n链路聚合链路聚合是将交换机的多条线路汇聚成一条逻辑线路在网络中使用。有多个称呼：端口聚合、链路捆绑、绑定等。\n如果不使用链路聚合功能，直接将交换机的多个物理端口连接起来，可能会导致网络环路。如果使用生成树协议，又会避开某些链路，导致只有一条物理链路可用。如果使用链路聚合，把几条物理链路聚合成一条逻辑链路，即使某一条物理链路断开，由于逻辑线路还有其它物理链路在维持，因此通信也不会中断，到达线路冗余的效果。\nVLAN将广播域分割成一个个逻辑网段的功能叫做 VLAN 。\n端口镜像将某个端口接收和发送的数据帧复制到镜像端口的功能叫做端口镜像，被复制的源端口叫做监控端口。\n为了分析网络故障或检测网络中的流量，交换机会将收到的数据帧复制一份并转发到网络分析设备或流量监控设备中。\nQoS 优先级队列QoS 是 Quality of Service 的缩写，也叫做服务质量。当数据通过网络设备时，根据通信种类控制通信优先级和带宽的功能。通常是将声音、视频等数据定义为高优先级，高优先数据优先处理，保障这类数据的稳定和低延迟。\n除了交换机在二层进行的 QoS 控制外，还有路由器和三层交换机的三层（ IP ）的 QoS 控制，以及 TCP 进行的四层的 QoS 控制。\nIEEE 802.1p 标准完成了对二层的 QoS 优先级控制的标准化工作。通过 3bit 长度的优先级控制信息，定义了从 0 到 7 的 8 个优先级，即 CoS 值（服务等级值），交换机会优先转发值大的数据帧。\nMAC 地址过滤为了网络安全，只让指定的设备接入网络。二层交换机提供了以数据帧的头部信息进行过滤的功能。具体过程是，先设置一个过滤条件，比如目的 MAC 地址、源 MAC 地址等，满足条件的数据帧通过，阻断不满足条件的数据帧。\n考虑到伪造 MAC 地址的情况发生，还可以跟 802.1X 一起使用。三层交换机或路由器可以根据 IP 头部信息完成 IP 通信过滤的功能。\n基于端口的认证在交换机中，只有通过认证的客户端才能使用有线端口。这个功能由 IEEE 802.1X 完成标准化，对接入 LAN 的客户端进行认证的机制。\n当 PC 连接交换机时，认证过程启动。根据发送方的 MAC 地址信息进行客户端识别，通过用户名、口令或证书等认证信息进行用户认证。对于没有认证的客户端发来的数据帧，交换机只接收包含认证信息的数据帧，其余的全部丢弃。对于认证失败的客户端发来的数据帧，交换机就直接丢弃不会进行转发。\n\n要使用基于端口的认证功能，客户端的电脑和交换机都要支持 802.1X 认证功能，缺一不可。\n802.1X 认证中使用 PPP 的扩展协议 EAP ，通过 EAPOL 协议封装 EAP 认证消息，然后在 LAN 中进行传输。认证结束之前，客户端电脑只能进行 EAPOL 通信。\n\n网络管理远程管理、监控和配置网络设备可以使用 SNMP 协议。SNMP 协议可以对整个网络结构内的交换机和其它网络设备进行集中统一的管理。\n被 SNMP 管理的网络设备叫做 Agent ，管理网络的设备叫做 Manager 。\n16、交换机的架构是由什么组成？交换机的基本架构是由 RJ-45 接口、PHY 、MAC 等模块的 NIC 和管理由 NIC 收发帧缓存、转发表的软件组成，通过查看转发表信息，在 NIC 之间进行数据帧交互。\n\n","tags":["计算机网络"]},{"title":"深度学习有哪些好玩且易于实现的论文？","url":"/2021/11/12/simpread-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E7%8E%A9%E7%9A%84%E4%B8%94%E6%98%93%E4%BA%8E%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%AE%BA%E6%96%87%EF%BC%9F%2020211114/","content":"\nGitHub 上发现了一个不错的项目，收集了中国科学技术大学课程资源，主要包括了计算机学院，也包括经管、经济、物理、数学等相关课程的 repo，甚至包含了人文社科类的。目前该项目已收获了 13716 个 Star，4221 个 Fork。课程的结构大致如下：\nhttps://ustc-resource.github.io/USTC-Course/\n有很多\nMachine Learning solutions in AWS Marketplace\n亚马逊的机器学习的博客\nAWS Marketplace\n2019/10/25 再次更新\nLearn Python - Free Interactive Python Tutorial\n优达学城，乔治亚理工学院的课程\n优达学城课程分类_在线视频课程 - 优达学城 (Udacity) 官网\n关于软件和镜像下载源，大家可以看看我这篇回答。管清华和中科大的朋友要的。 清华，中科大，计算机学院下载资源\n2019/10/17 更新 ，基于大家对我的喜爱，我就放两本很好的电子书的链接在上边。深度学习的哦。如果你们给我点赞多一点，或者转发，我会放更多的资料在上边。\nDeep LearningNeural networks and deep learning\n—————————————- 我是分割线 —————————————— 有很多！今天来强答一波。祭出我的月光宝盒来。各位小哥哥，小姐姐，看完记得点个赞哦 (´-ω-`)。还有机器学习大礼包，含 tensorflow 书籍和李航统计学习法，以及斯坦福的课件，大小 400 多 M，有需要的小宝贝私聊我就好。！(上传百度网盘链接，居然涉及违法违规～)\n1. 网站 https://paperswithcode.com/sota\n\n2. 网站 https://github.com/zziz/pwc/blob/master/README.md#—- ，是这个样子的，和上边差不多。\n\n3. 还有视频，讲神经网络的，附 YouTube 链接 https://www.youtube.com/watch?v=aircAruvnKk\n\n4. 以及_DeepLearning-500-questions，_https://github.com/scutan90/DeepLearning-500-questions 深度学习 500 问，以问答形式对常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题进行阐述，以帮助自己及有需要的读者。\n\n5. 以及莫烦小哥的 python https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/\n\n6. 这个是思科的，Welcome to Deep Learning NLP documentation!\n\n7. 这网站非常硬核，讲的清楚，而且很干净漂亮。还有 python 跟 R 的内容代码https://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/\n\n\n\n还有一个开放的社区，会定期讨论大家最近在看什么文章，机器学习相关的项目。前两天还让我投票，说是发起了请愿书，让大家呼吁不要去美国开 AI 的国际会议。https://www.reddit.com/r/MachineLearning/\n\n\n\n还有中科大的这个教程，从人工智能到区块链应有尽有\n\n\n给大家放上几本好书，推荐！\n\n","tags":["学习"]},{"title":"-联想 XC 服务器命名规范","url":"/2021/05/02/simpread-%E8%81%94%E6%83%B3%20XC%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"\n","tags":["学习"]},{"title":"计算机组成原理（万字爆肝整理）","url":"/2023/01/30/simpread-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%20(%E4%B8%87%E5%AD%97%E7%88%86%E8%82%9D%E6%95%B4%E7%90%86)/","content":"第一章 计算机系统概述“较简单，不做过多赘述，后面会详细学到”\n第一节 计算机系统层次结构\n计算机系统的基本组成：硬件 + 软件\n\n计算机硬件的基本组成：运算器 + 存储器 + 控制器 + 输入设备 + 输出设备\n\n系统软件和应用软件\n\n\n系统软件操作系统、数据库管理系统、语言处理程序、分布式软件系统、网络软件系统、标准库语言、服务性程序应用软件科学计算类程序、工程设计类程序、数据统计与处理程序\n\n4.（易考）翻译程序：\n汇编程序（汇编器）将汇编语言程序翻译成机器语言程序解释程序（解释器）将源程序翻译成机器指令并立即执行编译程序（编译器）将高级语言翻译城机器语言或汇编语言\n\n第二节 计算机性能指标\n  吞吐量：表征一台计算机在某一时间间隔内能够处理的信息量。\n  响应时间：表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量。\n  利用率：在给定的时间间隔系统被实际使用的时间所占的比率，用百分比表示。\n  处理机字长：指处理机运算器中一次能够完成二进制数运算的位数，如 32 位、64 位。\n  总线宽度：一般指 CPU 中运算器与存储器之间进行互连的内部总线二进制位数。\n  存储器容量：存储器中所有存储单元的总数目，通常用 KB、MB、GB、TB 来表示。公式一般是：位数 × 个数\n\n（MAR×MDR）\n\n  存储器带宽：单位时间内从存储器读出的二进制数信息量，一般用字节数 / 秒表示。\n  主频 / 时钟周期：CPU 的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟度量单位是 MHz、GHz\n\n主频的倒数称为 CPU 时钟周期（T），T=1/f，度量单位是 μs、ns。\nK= $10^3$10^3 ，M= $10^{6}$10^{6} ，G= $10^9$10^9\n易错：时钟频率的提高，不能保证 CPU 执行速度又同倍速的提高，有时候还会减慢。\n\n  CPU 执行时间：表示 CPU 执行一般程序所占用的 CPU 时间，可用下式计算：\n\nCPU 执行时间 = CPU 时钟周期数 * CPU 时钟周期\n\n  CPI：执行一条指令所需的平均时钟周期数。用下式计算：\n\nCPI = 执行某段程序所需的 CPU 时钟周期数 / 程序包含的指令条数\n\n  MIPS：（Million Instructions Per Second）的缩写，表示平均每秒执行多少百万条定点指令数，用下式计算：\n\nMIPS = 指令数 / （程序执行时间 * 10^6）\n\n  FLOPS：（Floating-point Operations Per Second）的缩写，表示每秒执行浮点操作的次数，用来衡量机器浮点操作的性能。用下式计算：FLOPS = 程序中的浮点操作次数 / 程序执行时间（s）\n\n题目总结：①对于高级语言程序员来说，浮点数格式、乘法指令、数据如何在运算器中运算时透明的。对于汇编语言程序员，指令格式，机器构造，数据格式则不是透明的。\n②在 CPU 中，IR、MAR、MDR 对各类程序员都是透明的。\n③机器字长，指令字长，存储字长\n机器字长也称字长——是计算机直接处理二进制数据的位数，机器字长一半等于内部寄存器的大小，它决定了计算机的运算精度。\n指令字长——一个指令中包含的二进制代码的位数。\n存储字长——一个存储单元中二进制代码的长度。\n指令字长一般是存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 次访存来取出一条指令，因此取值周期为机器周期的 2 倍；若指令字长等于存储字长，则取值周期等于机器周期。\n第二章 数据的表示和运算一、无符号整数的表示和运算\nⅠ、无符号整数的加法：从最低位开始，按位相加，并往更高位进位。\nⅡ、”被减数 “不变，” 减数“全部按位取反，末位 + 1，减法变加法。\n二、带符号整数的表示和运算\n带符号的整数表示：原码、补码、反码\n※带符号的整数运算可以用原码吗？\n用原码的话符号位不能参与运算，需要设计复杂的硬件电路才能处理，贵。\n这时候就可以利用补码来进行带符号的整数运算。\n①涉及原码和补码的转化。\n正数：原码 -&gt; 补码，不变\n负数：原码 -&gt; 补码，除符号位外，各位取反，末位 + 1\nⅠ、补码的加法\n\n从最低位开始，然后按位相加，并往高位进位。算出来的结果，转回原码，就可以得到正值。\n补充：补码 -&gt; 原码：类似，除符号位外，各位取反，末位 + 1\nⅡ、补码的减法\n※加法电路造价便宜，减法电路造价昂贵，若将减法变为加法，更加 economize。\n\n  那我们知道了”减数 “的补码，那如何求得” 减数“负值的补码呢？\n\n补码全部位取反，末位 + 1（易错这里是全部位取反，而带符号位的负数，是除符号位外，各位取反）\n其实啊，这里的运算的逻辑结构和无符号的减法运算是一样的，通用一套电路，省钱！\n三、原码、反码和补码的特性对比\n8bit合法的表示范围最大的数最小的数真值 0 的表示带符号原码-127~127127-127+0=00000000-0=10000000带符号反码-127~127127-127+0=00000000-0=11111111带符号补码-128~127127-128-/+0=00000000只有这一种无符号整数0~255255000000000带符号移码-128~127127-1280=10000000只有这一种\n\n原码和反码的合法表示范围完全相同，而且都有两种表示真值 0 的方法。\n补码的合法表示范围多一个负数，原因就是只有一种 0 的表示方法，因为 - 0 的补码就是 00000000\n\n四、移码，定点小数\n移码：在补码的基础上符号位取反。且移码只能表示整数。表示范围和补码相同。\n移码的作用：移码的作用就是方便计算机比较两个数数值的大小。\n定点小数的编码表示：原码、反码、补码。\n运算规则和整数的运算规则一模一样。\n五、电路的基本原理和加法器设计\nⅠ、补码 / 无符号整数加减法运算器\n\n减法运算过程：\n①首先 Sub 信号置为 1；\n②多路选择器的值为 1，Y（减数）经过非门，都取反；\n③cin 来自低位加 1；\nⅡ、标志位生成\n①进位标志 CF (Carry Flag) 只对无符号运算有意义当运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置 1，\n即 CF = 1；否则 CF= 0。\n49H + 6DH＝B6H，　没有进位：CF = 0\nBBH + 6AH＝（1）25H，有进位：CF = 1②零标志 ZF (Zero Flag)若运算结果为 0，则 ZF = 1；否则 ZF = 0\n49H + 6DH＝B6H，结果不是零：ZF = 0\n75H + 8BH＝（1）00H，结果是零：ZF = 1③符号标志 SF (Sign Flag) 只对有符号运算有意义运算结果最高位为 1，则 SF = 1；否则 SF = 0\n49H + 6DH＝B6H=10110110B，SF=1\n④溢出标志 OF (Overflow Flag) 只对有符号运算有意义若算术运算的结果有溢出，则 OF＝1；否则 OF＝0\n49H + 6DH ＝B6H，产生溢出：OF = 1\n75H + 8BH ＝（1）26H，没有溢出：OF = 0\n进位 CF 和溢出 OF 位有什么区别呢？\n进位标志表示无符号数运算结果是否超出范围，运算结果仍然正确，对有符号位加减法无意义。\n溢出标志表示有符号数运算结果是否超出范围，运算结果已经不正确，对无符号加减无意义。\n溢出的判断判断运算结果是否溢出有一个简单的规则：\n只有当两个相同符号数相加（包括不同符号数相减），而运算结果的符号与原数据符号相反时，产生溢出；因为，此时的运算结果显然不正确其他情况下，则不会产生溢出\n\n当两个符号相同的数相加，结果的符号与之相反，则 OF=1, 否则 OF=0.\n\n当两个符号不同的数相减，结果的符号与减数相同，则 OF=1, 否则 OF=0.\n\n\n六、定点数的移位运算\n\n  左移 1 位相当于 ×2，右移 1 位相当于 ÷2\n  原码：符号位不参与移位。左移，右移都补 0\n  反码：符号位不参与移位。若反码是负数补 1；若反码是正数补 0\n  补码：符号位不参与移位。若补码是负数左移低位补 0，右移高位补 1；若补码是正数，左移右移都补 0\n\n七、原码补码的乘法除法运算\nⅠ、原码的一位乘法\n符号位通过异或确定；数值部分通过被乘数和乘数绝对值的 n 轮加法、移位完成，根据当前乘数中参与运算的位确定（ACC）加什么。若当运算位 = 1，则（ACC）+[|x|], 若为 0，则 (ACC)+1。每轮加法完成后，ACC,MQ 的内容统一逻辑右移。\n\n先 ACC 初始化。x 置于通用寄存器中，y 置于 MQ。\nⅡ、补码的一位乘法\n原码一位乘法和补码一位乘法的不同点\n原码一位乘法补码一位乘法进行 n 轮的加法、移位进行 n 轮加法，移位，最后再多来一次加法每次加法相加，只有两种情况 + 0 或加 x每次加法加有三种情况，0 或 + x 或 +[-x]每次移位都是逻辑右移，补 1每次都是补码的右移，正数右移补 0，负数右移补 1符号位不参与运算符号位参与运算\n\n\n  会添加一位辅助位\n  辅助位 - MQ 中 “最低位”=1 时，(ACC)+[X)] 补\n  辅助位 - MQ 中 “最低位”=0 时，(ACC)+0\n  辅助位 - MQ 中 “最低位”=-1 时，(ACC)+[-X] 补\n\n\n八、C 语言类型转换和数据存储排列\n\n  C 语言中定点整数是用” 补码 “存储的。\n  无符号数转为有符号数：不改变数据内容，改变解释方式。\n  长整数变为短整数：高位截断，保留低位。\n  短整数变长整数：若为有符号数，在符号位和数值位添 1，若为无符号，直接在高位添 0。\n  大小端模式：大端方式便于人类阅读；小段方式便于机器处理，因为机器最先读入的就是最应被处理的数据。\n  边界对齐：假设存储字长为 32 位，则 1 个字 = 32bit, 半字 = 16bit。每次访存只能读 / 写 1 个字。若采用边界对齐的方式，则访问一个字 / 半字都需要一次访存，虽然会造成一点点的空间浪费。采用不对齐的方式，对空间利用率高，但是可能会涉及到两次访存时间大大增加。\n\n九、浮点数的表示和运算\nⅠ、概念：之前我们学习了定点数，其中「定点」指的是约定小数点位置固定不变。那浮点数的「浮点」就是指，其小数点的位置是可以是漂浮不定的。\nⅡ、表示：阶符表示的是阶码正负，尾数的数符表示的是尾数正负。\n阶码：常用补码或移码表示的定点整数，反映表示范围。\n尾数：常用原码或补码表示的定点小数，反映精度。\n\nⅢ、规格化：规定尾数的最高位必须是有效位。\n①” 有效位 “又分两种情况。分为尾数是补码表示还是原码表示\n原码表示的尾数视格化：尾数的最高数值位必须是 1\n补码表示的尾数规格化：尾数最高数值位必须和尾数符号位相反\n②左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减 1。\n\nb= $2^2\\times(+0.01001)=2^1\\times(+0.10010)$2^2\\times(+0.01001)=2^1\\times(+0.10010) #尾数最高位为 0，左规\n\n右规：当浮点数运算的结果尾数出现溢出（双符号位为 01 或 10）时，将尾数算数右移一位，阶码加 1。\n\n采用双符号位，当发生溢出时（双符号位为 01 或 10），可以采用右规，更高位的符号位是正确的符号位。\n③虽然浮点数的范围和精度也有限，但其范围和精度都已非常之大，所以在计算机中，对于小数的表示我们通常会使用浮点数来存储。\n\n十、IEEE 754\n背景：在浮点数提出的早期，各个计算机厂商各自制定自己的浮点数规则，导致不同厂商对于同一个数字的浮点数表示各不相同，在计算时还需要先进行转换才能进行计算。后来 IEEE 组织提出了浮点数的标准，统一了浮点数的格式，并规定了单精度浮点数 float 和双精度浮点数 double，从此以后各个计算机厂商统一了浮点数的格式，一直延续至今。\n\n十一、浮点数运算（重点）\n现代计算机表示数的方法通常都是浮点数了，所以这节很重要。\n①对阶：小阶向大阶靠齐，方便计算机对尾数进行处理。\n②尾数加减：尾数常规加减。\n③规格化：如果尾数加减出现类似 0.0099517× $10^{12}$10^{12} 时，需要 “左规”；\n如果尾数加减出现类似 99.517107× $10^{12}$10^{12} 时，需要 “右规”。\n④舍入：尾数位数有限，若规定只能保留 6 位有效尾数，则 9.9517107× $10^{12}$10^{12} →9.95171× $10^{12}$10^{12} (多余的直接砍掉) 或者，9.9517107× $10^{12}$10^{12} →9.95172× $10^{12}$10^{12} （若砍掉分非 0，则入 1) 或者，也可以采用四舍五入的原则，当舍弃位≥5 时，高位入 1。\n⑤判溢出：若规定阶码不能超过两位，则运算后阶码超出范围，则溢出。\n如：9.85211× $10^{99}$10^{99} +9.96007× $10^{99}$10^{99} =19.81218× $10^{99}$10^{99} 规格化并用四舍五入的原则保留 6 位尾数，得 1.98122× $10^{100}$10^{100} , 阶码超过两位，溢出。\n\n强制类型转化：\n无损：char-&gt;int-&gt;long-&gt;double\nfloat-&gt;double\n有损：int-&gt;float, 可能会损失精度\nfloat-&gt;int，可能会溢出，也可能会损失精度\n第三章 存储系统第一节 存储器概述一、存储器的层次结构\n寄存器 -&gt;Cache-&gt; 主存 -&gt; 辅存 -&gt; 外存\nCache - 主存：解决了主存与 CPU 速度不匹配的问题。\n主存 - 辅存：实现虚拟存储系统，解决了主存容量不够的问题。\n※辅存中的数据要调入到主存才能被 CPU 访问\n二、存储器的分类\nⅠ、按照存取方式：分为随机存取存储器（RAM），如内存；顺序存取存储器（SAM），如磁带；直接存取存储器（DAM），如磁盘；相联存储器（可按内容访问的存储器，CAM），如快表。\nⅡ、按信息是否可改：分为读 / 写存储器和只读存储器（ROM）\nⅢ、断电后是否消失：分为易失性存储器，如内存、Cache；非易失性存储器，如磁盘、光盘\n三、存储器的性能指标\n\n存储容量：存储字数 × 字长\n\n单位成本：每位价格 = 总成本 / 总容量\n\n存储速度：数据传输率 = 数据的宽带 / 存储周期\n\n\n存储周期 = 存取时间 + 恢复时间\n第二节 主存储器一、SRAM 和 DRAM\n一个静态 RAM，一个动态 RAM。动态的用于主存，静态的用于 Cache\nSRAM 和 DRAM 的差别\n类型特点SRAMDRAM存储信息触发器电容破坏性读出非是读出后是否需要重写不用需要运行速度快慢集成度低高发热量大小存储成本高低是否易失易失易失是否需要刷新不需要需要作用常用作 Cache常用作主存\n\n二、ROM 只读存储器\nRAM 芯片——易失性，断电后数据消失\nROM 芯片——非易失性，断电后数据不会消失\n①MROM——掩模式只读存储器：任何人都不可重写\n②PROM——可编程只读存储器：写一次后就不可更改\n③EPROM——可擦除可编程只读存储器：可进行多次重写，写入时间很长\n④Flash Memory——闪速存储器：可进行多次快速擦除重写，但写的速度比读的速度慢\n⑤SSD——固态硬盘：可进行多次快速擦除重写，目前个人电脑大都市这种。速度快，功耗低，价格高。\n第三节 主存储器与 CPU 的连接一、单块存储器与 CPU 连接\nⅠ、连接原理：主存器通过数据总线，地址总线和控制总线与 CPU 连接。\n地址总线的位数决定了可寻址的最大内存空间。\n控制总线指出总线周期类型和本次输入输出操作完成的时刻。\n\n二、多块存储器与 CPU 连接\nⅠ、位扩展法\n原理：CPU 的数据线与存储芯片的数据位数不相等，此时必须使用多个存储器件对字长进行扩位。每个存储器的数据线都并行连接在 CPU 的数据总线上，而地址位数是串行相连。那 CPU 传一个地址过来，怎么知道是使用哪个存储芯片呢，此时就要 WE 来控制使用哪个存储芯片。\n\nⅡ、字扩展法\n原理：当主存储器位数不足，字数足够时，我们会通过位扩展的方法来扩展主存储器，将多个字数相同的存储芯片并联起来，增加位数，并且存储空间是连续的。里面还会涉及译码器，主要功能就是增加控制存储器的个数，如有两位地址线连接了译码器，那么译码器可以控制 $2^2$2^2 个存储器。\n线选法译码片选法n 条线 n 个片选信号n 条线 2 的 n 次方个片选信号电路简单电路复杂地址不连续（两位举例，00 和 11 的地址用不到）地址连续（00 和 11 的地址也都用到了）\nⅢ、字位同时扩展\n原理：而当字数和位数都不足时，我们会通过字位同时扩展的方法来扩展存储器，将多个字数和位数都相同的存储芯片连接起来，同时增加字数和位数。\nⅣ、三者比较\n字扩展方法只能增加主存储器的容量，存取速度没有提升。而位扩展方法不光可以增加主存储器的容量，同时还可以让多个存储芯片同时工作，同时做读写操作，增加了存取速度。字位同时扩展的方法又可以增加主存储器的容量，又可以让多个存储芯片同时工作，那么是不是只用字位同时扩展这一种方法就可以了呢？任何事情都是有利弊两面性的，在能力增强的同时，他的成本，功耗和体积都会增加，所以我们还是要根据实际的系统需求来判断具体使用的主存储器扩展方法。\nⅤ、题目总结\n【2018 统考真题】假定 DRAM 芯片中存储阵列的行数为 r、列数为 c, 对于一个 2K×1 位的 DRAM 芯片，为保证其地址引脚数最少，并尽量减少刷新开销，则 r、c 的取值分别是 ()。\n解：r 是行，c 是列，为了保证地址引脚数最少，就要求，行列相差小，并且减少刷新开销，则要求行数越小越好。故最终行数位 32，列数位 64。\n三、多模块存储器\n背景：随着 CPU 的功能不断增强，I/O 设备数量不断增多，这也导致了主存的存取速度已成为计算机系统的发展瓶颈。为了解决此问题，除了寻找更高速的原件和采用存储器层次结构外，调整主存的结构也可以提高访存速度，这就涉及到了多模块存储器。\n由于取值周期 = 存取时间 + 恢复时间。DRAM 芯片恢复时间较短，有可能是存取时间的几倍。那怎么半，不能让设备停着吧。那太浪费资源了。\nⅠ、双端口 RAM\n顾名思义，就是利用两个端口实现多核 CPU 存储，需要有两组完全独立的数据线，地址线，控制线。支持两个 CPU 同时访问。\n两个端口可以同时对不同单元的地址中取数据，也可以对同一地址单元中读出数据，但是不行同时对同一单元中写入数据，也不能对同一单元一边读一边写入数据。\n解决办法：发出”busy“信号，其中一个 CPU 的访问端口暂时关闭。\nⅡ、单体多字存储器\n原理：原来每行只存放一个存储字，变为每行存放多个存储字，这样原来一次只能读取一个存储字，变为一次能读取多个存储字，这需要数据总线根数变大。\n限制：指令和数据在主存必须是连续存放的。\n\nⅢ、多体并行存储器（重点）\n原理：每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路，地址寄存器，和数据寄存器，既能并行工作，又能交叉工作（一个模块进入恢复时间，另一个模块进行存取）。\n\n区别：在高位交叉中，由于下一个访问的地址还是在这个存储体上，所以必须等到恢复时间结束后才能继续访问，故不能并行访问。效果也仅仅是扩容。而在低位交叉编制中，下一个访问地址不在同一个存储体上，所以可以交叉访问，不仅扩容还加快了访问速度。当块数 m $\\geq$\\geq T/r 时，能达到最佳存储效率。T 为存取周期，r 为存取时间。\n\n第四节 外部存储器一、磁盘存储器\n优点：存储容量大，价格低，长期保存而不丢失。\n缺点：存取速度慢，机械结构复杂，对环境要求高。\n磁盘最小的读写单位是一个扇区。\n二、固态存储器 SSD（新增考点）\n优点：读写速度快。若要写的页有数据，则不能写入，需要将块内其他页全部复制到一个新的块中，再写入新的页。\n缺点：价格高，一个块被写入多次可能会坏掉（采用平均磨损，对我们来说仍然很耐用）而磁盘不会。\n第五节 高速缓冲存储器（重点）一、什么是 Cache，为什么要引入 Cache？\nCache 存储器也被称为高速缓冲存储器，位于 CPU 和主存储器之间。之所以在 CPU 和主存之间要加 cache 是因为现代的 CPU 频率大大提高，内存的发展已经跟不上 CPU 访存的速度。在 2001 – 2005 年间，处理器时钟频率以每年 55% 的速度增长，而主存的增长速度只是 7%。在现在的系统中，处理器需要上百个时钟周期才能从主存中取到数据。如果没有 cache，处理器在等待数据的大部分时间内将会停滞不动。\n二、原理\n采用了程序访问的时间局部性原理和空间局部性原理\n时间局部性：如果一个数据现在被访问了，那么以后很有可能也会被访问\n空间局部性：如果一个数据现在被访问了，那么它周围的数据在以后可能也会被访问\n三、多级 Cache 的由来？\ncache 分为 L1，L2，L3 甚至 L4 等多级。为什么不能把 L1 的容量做大，不要其它的 cache 了？原因在于性能 / 功耗 / 面积（PPA）权衡考虑。L1 cache 一般工作在 CPU 的时钟频率，要求的就是够快，可以在 2-4 时钟周期内取到数据。L2 cache 相对来说是为提供更大的容量而优化的。虽然 L1 和 L2 往往都是 SRAM，但构成存储单元的晶体管并不一样。L1 是为了更快的速度访问而优化过的，它用了更多 / 更复杂 / 更大的晶体管，从而更加昂贵和更加耗电；L2 相对来说是为提供更大的容量优化的，用了更少 / 更简单的晶体管，从而相对便宜和省电。在有一些 CPU 设计中，会用 DRAM 实现大容量的 L3 cache。\n四、如何区分 Cache 和主存的数据块对应关系？\n每次被访问的主存块，一定会被立即调入 Cache，而且是以块为单位进行调入。\n\n那是采用什么方式将主存块号调入到 Cache 呢？有三种方式\n①全相联映射——主存块可以放在 Cache 的任意位置。\n那它是如何来访问主存的呢？\n\n对以上图只要能看懂，对于全相联映射就没什么问题了。做几点说明，CPU 在访问主存时，会先对比 Cache 所有块中的标记 Tag，Tag 就是在主存中的主存块号，占 22 位。\n②直接映射——每个主存块只能放在一个特定的位置。Cache 块号 = 主存块号 %Cache 块总数\n\n做以下几点说明\n\n  相对于全相联映射，直接映射对 Tag 进行了优化，因为主存块号最后三位地址就是 Cache 中的位置，所以将主存块号其余位作为标记即可。\n  若 Cache 总块数 = $2^n$2^n , 则主存块号末尾 n 位直接反映它在 Cache 的位置，所以将主存块号其余位作为标志位即可。\n\n③组相联映射——Cache 块分为若干组，每个主存块可以放到特定分组中的任意一个位置。组号 = 主存块号 % 分组数\n\n做以下几点说明\n\n  相对于全相联映射，直接映射对 Tag 进行了优化，因为主存块号最后两位地址就是 Cache 中的位置，所以将主存块号其余位作为标记即可。\n  一个组内有几个 Cache 块就成为几路相联映射\n\n④三种映射方法对比总结\n全相联直接组相联特点任意位置特定位置分组中的任意位置主存地址结构标记 + 块内地址标记 + 行号 + 块内地址标记 + 组号 + 块内地址优点Cache 存储空间利用充分对任意地址，执行对比一个 Tag，速度快折中办法缺点可以会对比所有行的标记，速度慢Cache 空间利用不充分/\n\n五、Cache 很小，而主存很大，如果 Cache 满了，是利用了什么替换算法？\n替换条件：对于全相联映射，需要在全局中选择替换哪一块，对于直接映射，若非空，则直接替换，对于组相联，组内满了，则在组内选择替换哪一块。\nⅠ、随机算法 (RAND)\n随机，随便，随意，换哪一个都行。实现简单，但完全没有考虑局部性原理，命中率低，实际效果很不稳定。\n可能会导致，换出的块，下一次又需要访问。就会多次访问内存块。导致抖动现象。\nⅡ、先进先出算法 (FIFO)\n替换最先进入的块。同样实现简单，但仍然没有考虑到局部性原理，最先被调入 Cache 块可能是被访问最频繁的。\nⅢ、近期最少使用 (LRU)\n为每个 Cache 块设置一个”计数器 “，用于记录每个 Cache 块多久没有被访问了。然后替换” 计数器“值最大的。\n\n  计数器的位数 = Cache 块的总数 = $2^n$2^n ，只需要 n 位，且 Cache 装满后所有计数器的值一定不重复。\n  基于局部性原理，近期被访问的主存块，未来可能仍会被使用，LRU 算法实际运行效果优秀。\n  若频繁访问的主存块数量 &gt; Cache 行的数量，则有可能发生” 抖动 “\n\nⅣ、最近不经常使用 (LFU)\n为每个 Cache 设置一个”计数器 “，用于记录 Cache 被访问过几次，然后替换” 计数器“值最小的（访问次数最少的）\n曾经被经常访问的主存块不一定在未来会被用到。并没有很好的遵循局部性原理，因此实际运行效果不如 LRU。\n六、Cache 写策略——CPU 修改了 Cache 中的数据副本，如何确保主存中数据母本一致性？\nⅠ、写命中——写入的时候，在 Cache 中\n①回写法：当 CPU 对 Cache 写命中时，只修改 Cache 的内容，而不立即写入主存，只有当次块被换出时才写回主存。减少了访存次数，但存在数据不一致的隐患。\n被换出时，看” 脏位 “是否知道是否被修改。\n②全写法：当 CPU 对 Cache 写命中时，必须把数据同时写入 Cache 和主存，一般使用写缓冲。访存次数增加，速度变慢，但是能保证数据的一致性。无脏位。\nⅡ、写不命中——写入的时候，不在 Cache 中\n①写分配法——当 CPU 对 Cache 不命中时，把主存中的块调入 Cache，在 Cache 中修改。通常搭配回写法使用，改完后要被换出，才在主存中修改。\n②非写分配法——当 CPU 对 Cache 写不命中时，只写入主存，不调入 Cache，搭配全写法使用。\n第六节 虚拟存储器虚拟存储器：在操作系统的管理下，只把当前需要的部分数据调入主存，暂不需要的部分留在辅存中。在用户看来，似乎获得了一个超大的主存。（虚拟性）\n一、页式虚拟存储器\n背景：CPU 执行的机器指令中，使用的是”逻辑地址 “，因此需要通过” 页表“将逻辑地址转为物理地址。\n一个程序在逻辑上被分为若干个大小相等的”页面 “，” 页面 “大小与” 块“的大小相同。每个页面可以离散的存放在不同主存块中。\n页表的作用：记录了每个逻辑页面存放在哪个主存块中。\n无快表：\n\n\n  逻辑地址 = 逻辑页号 + 页内地址\n  物理地址 = 主存块号 + 页内地址\n\n增加快表（存放在 Cache 中，先访问快表，若未命中，则去访问主存中的慢表）\n\n\n  快表查询速度很快，若快表中无，则会去慢表中查找，会把相应的内容存入快表中\n\n清楚整个查找流程\n\n二、段式虚拟存储（按功能拆分成大小不同的模块）\n按照功能模块拆分不同的模块大小。\n虚拟地址：段号 + 段内地址\n优点：段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护。\n缺点：段的长度可变，分配空间不便，容易留下碎片，不好利用，造成浪费。\n三、段页式虚拟存储\n把程序按逻辑结构分段，每段在分固定大小的页，主存空间也划分为大小相等的页，每个程序对应一个段表，每段对应一个页表。\n虚拟地址：段号 + 段内地址 + 页内地址\n优点是兼具段式和页式的优点缺点是需要查两次表，系统开销较大。\n四、虚拟存储器与 Cache 的比较\nCache虚拟存储器解决 CPU 与主存速度不匹配的问题解决主存容量的问题全由硬件组成，对所有程序员透明由 OS 和硬件组成，逻辑上存储器对系统程序员不透明不命中影响小不命中影响大不命中时，主存直接与 CPU 通信不命中时，不能直接和 CPU 通信，要先硬盘调入主存\n\n题目总结：【2015 统考真题】假定主存地址为 32 位，按字节编址，主存和 Cache 之间采用直接映射方式，主存块大小为 4 个字，每字 32 位，采用回写方式，则能存放 4K 字数据的 Cache 的总容量的位数至少是 ()\n\n  Cache 的容量分为两个部分一个是数据存储容量 + 标记阵列容量\n  标记阵列中一定包含有效位和标记位，若为回写法，则还存在一位的” 脏位 “，若为 LRU、LFU 替换算法，则还存在替换算法位（计数器）位数为 $log_2^n$log_2^n ,n 为 Cache 的个数。\n  本题按照字节编址，则块内地址占 4 位，采用直接映射方法中的标志位为 32-4-10=18，Tag=18。\n  采用回写法，有一位脏位，故最终标记项有 18+1+1=20\n  标记阵列容量为 $2^{10}$2^{10} ×20=20K，数据储存容量为 4K×32=128K，故总的为 148K。\n\n第四章 指令系统第一节 指令格式指令概念：又称机器指令，是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。\n一条指令就是机器语言的一个语句，一条指令通常要包括操作码和地址码两部分：操作码主要指明用户干什么，地址码主要指明对谁操作。\n一、指令分类\n按操作数个数分：\nⅠ、零地址指令：不需要操作数，如空操作、停机、关中断等指令\nⅡ、一地址指令：只需要单个操作数，如自增，自减，取反，求补，需要两个操作数，但其中一个隐含在某个寄存器中\nⅢ、二地址指令：常用于两个操作数的算术运算、逻辑运算相关指令。\n完成一条指令需要访存四次，分别为取值，读第一个操作数，读第二个操作数，写回第一个操作数。\nⅣ、三地址指令：常用于两个操作数的计算，结果放在第三个地址中。\n完成一条指令需要访存四次，分别为取值，读读一个操作数，读第二个操作数，写到第三个操作数。\n※若指令长度不变，地址码数量越多，寻址能力就越差\n按指令长度是机器指令的多少倍分：\nⅠ、半长指令：是机器指令长度一半\nⅡ、单字长指令：与机器指令长度一样\nⅢ、双字长指令：是机器指令长度两倍\n二、扩展操作码指令格式（考点：会设计指令系统）\n概念：指令是定长的，但是操作码的长度可变。\n通常情况下，使用频率高的指令使用短的操作码，减少指令译码和分析的时间。而使用频率低的指令使用长的操作码\n\n定长指令和扩展操作码的比较\n定长操作码扩展操作码优点硬件设计简单，识别速度快在指令长度限制下仍有丰富指令缺点指令难以增加，不灵活增加指令译码和分析难度，速度慢\n\n【2017 统考真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29 条、二地址指令 107 条，每个地址字段为 6 位，则指令字长至少应该是 ()。\n解答：三地址 29 条需要的位数是 5 位，多出 3 位，而 107 条需要 6 位。故总共 5+6+12=23，因为按照字节编址，所以最少需要 24 位。\n第二节 寻址方式（重点）一、指令寻址（由 PC 指出）\nⅠ、顺序寻址\nPC+”1“，这里的 1 指指令字长，每次取值结束后 PC 会 + 1\nⅡ、跳跃寻址\n执行转移类指令导致的 PC 值改变\n二、数据寻址（由本条指令的地址码指明真实地址）\n非偏移指令\n寻址方式有效地址优点缺点访存次数（指令执行期间）直接寻址操作数的真实地址简单限制寻址范围1间接寻址操作数地址的地址可扩大寻址范围指令在执行阶段要多次访存最少 2 次寄存器寻址寄存器的地址不访问主存，速度快寄存器昂贵0寄存器间接寻址寄存器地址，内部是操作数主存地址与一般的间址快但执行仍然会访存1隐含寻址指令中隐含操作数地址有利于缩短指令字长需要增加存储操作数的硬件0立即寻址就是操作数本身最快限制操作数范围0\n\n偏移寻址（重中之重）\n指令执行过程中，都会在将运算结果放入主存中，涉及一次访存。\nⅠ、基址寻址\n将 CPU 中基址寄存器 (BR)/ 通用寄存器的内容加上指令格式中的形式地址 A，而形成操作数的有效地址，即 EA=(BR)+A\n\n※采用通用寄存器作为基址寄存器 $R_0$R_0 的位数，根据通用寄存器的总数判断，程序运行前，CPU 将 BR 的值修改为该程序的起始地址。\n\n  基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。用户无法修改，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。\n  当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统确定。\n  优点：可扩大寻址范围（基址寄存器的位数大于形式地址 A 的位数）\n\nⅡ、变址寻址\n有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容相加之和，即 EA= (IX)+A，其中 IX 可为变址寄存器（专用），也可用通用寄存器作为变址寄存器 。\n\n\n  变址寄存器是面向用户的，在执行过程中，变址寄存器的内容可由用户改变（IX 作为偏移量），形式地址 A 不变（作为基地址）。刚好与基址寻址相反。\n  在针对数组处理过程中，不断改变 IX 的值，便很容易形成数组中任一数据的地址，特别适合编制循环程序。\n  基址变址复合执行。EA=(IX)+(BR)+A。\n\nⅢ、相对寻址\n相对寻址：把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址，即 EA=(PC)+A，其中 A 是相对于 PC 所指地址的位移量，可正可负，补码表示 。\n\n\n  优点：这段代码在程序内浮动时不用更改跳转指令的地址码\n  相对寻址广泛应用于转移指令\n  注意：对于 JMP A 转移指令，当从 CPU 中取出一字节时，会自动执行 PC+1。若指令的地址为 X，且占 2B，在取出该指令后，会自定跳转到 X+2+A。\n\n堆栈寻址\n操作数存放在堆栈中，隐含使用堆栈指针作为操作数地址。\n\n  硬堆栈是将寄存器作为栈，成本很高；软堆栈是将主存作为栈，成本低。\n  硬堆栈不访存，软堆栈访存一次\n\n第三节 高级语言程序与机器级代码之间的对应一、基本概念\n\n  对操作数的操作地址只涉及三种：寄存器到寄存器，主存到寄存器，立即数到寄存器。\n  dword 32bit ；word 16bit ；byte 8bit\n  通用寄存器 eax ebx ecx edx 变址寄存器 esi edi 堆栈寄存器 ebp esp。\n\n二、选择结构语句的机器级表示\njejump when equal,jnejump when not equal,jgjump when greater,jgejump when greater or equaljljump when lessjlejump when less or equal![](https://pic2.zhimg.com/v2-4b5d24029f1096007c35dcb29e34a7a9_r.jpg)\n\n例如\n\ncmp eax ,ebx #比较寄存器 eax 和 ebx 里的值jg NEXT #若 eax&gt;ebx，则跳转到 NEXT\n\n三、循环结构语句的机器级表示\n用条件指令实现循环\n\n用 loop 指令实现循环\n\n就是将” 某些处理 “封装到了 Looptop 内，使得代码更加简洁。\n四、CISC 和 RISC\n对比项目CISCRISC指令系统复杂，庞大简单，精简指令数目一般大于 200 条一般小于 100 条指令字长不固定定长可访存指令没有限制只有 Load/Store 指令各种指令执行时间相差较大绝大多数在一个周期内完成各指令使用频率有的常用，有点不常用一般都常用通用寄存器的数量较少多控制方式绝大多数为微程序控制绝大多数为组合逻辑控制指令流水线可以通过一定方式实现必须实现\n\n第五章 中央处理器第一节 CPU一、CPU 的结构\nCPU 由运算器和控制器组成。\n\n二、CPU 的功能\n指令控制、操作控制、时间控制、数据加工、中断处理。\n运算器的功能：对数据加工\n控制器的功能：取指令、分析指令、执行指令\n第二节 指令执行过程在指令周期中，包含了：取指周期，在取指周期后需要判断是否有间址周期，如果没有就进入到执行周期，在执行周期后又需要判断是否有中断程序，如果有就响应中断并保存断点生成中断服务程序入口；如果没有就进入下一个取指周期。\n\n\n四个周期都有 CPU 访存操作，只是访存目的不同。取值周期是取指令；间址周期是取有效地址；执行周期是为了取操作数；中断周期是为了保存程序断点。\n\n指令周期常常有若干个机器周期，机器周期里面又包含若干个时钟周期。每个指令周期内的机器周期可以不同，机器周期内的时钟周期也可以不同。时钟周期是 CPU 操作的最基本单位。\n\n一、取值周期\n取指周期：取指周期的任务是根据 PC 中的内容从主存中取出指令代码并存放在 IR 中。而 PC 中存放的是指令的地址，根据这个地址从内存单元取出的是指令，并放在指令寄存器 IR 中，取指令的同时，PC 加 1。\n\n二、间址周期\n间址周期：间址周期的任务是取操作数有效地址，以一次间址为例，将指令中的地址码送到 MAR 并送至地址总线，此后 CU 向存储器发读命令，以获取有效地址并存至 MDR。\n\n三、执行周期\n执行周期：执行周期的任务是根据 IR 中的指令字的操作码和操作数通过 ALU 操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。\n指令执行方案：\n单指令周期所有指令选用相同的执行时间（取决于最长指令执行时间），指令间串行，但原本只需要很短时间完成指令也分配了很长时间，降低整个系统运行速度多指令周期对不同指令选用不同的执行时间，需要更复杂的硬件设计，指令间是串行流水线在每个时钟周期让多个指令同时运行，指令间是并行\n\n四、中断周期\n中断周期：中断周期的任务是处理中断请求。假设程序断点存入堆栈中，并用 SP 指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据。\n\n第三节 数据通路的功能和基本结构一、数据通路的基本结构\nⅠ：CPU 内部单总线方式。将所有寄存器的输入端和输出端都连接在一条公共通路上。易发生冲突。\nⅡ：双总线 / 多总线方式。多个总线上传不同的数据，提高效率。\nⅢ：专用数据通路方式。专门给某些部件设计通路。性能很高但是硬件量大。\n说明：\n①对于单总线的连接方式来说，ALU 只能有一端与总线相连，因为两端相连就必会发生冲突。所以另一段要设计一个暂存器，先把数据放入暂存器，暂存器再与总线相连。\n②单周期就是指令在一个周期内完成，这是需要与多总线结构配合。才能使各个部件的数据传递。因为单总线一个周期内只能传递一个数据，所以指令不可能在一个周期内完成。\n内部总线是指同一部件，如 CPU 内部连接各个寄存器及运算部件之间的总线系统总线指同一台计算机的各部件，如 CPU，主存，I/O 之间连接的总线\n\n第四节 控制器的功能和工作原理一、硬布线控制器\n多提一嘴，一定要看看王道视频是如何设计出组合逻辑图的，我保证看完一定会有颠覆性的收获。\n根据指令操作码、目前的机器周期、节拍信号、机器状态条件，即可确定现在这个节拍应该发出哪些” 微命令 “\n\n硬布线控制器的特点：\n\n  指令越多，设计和实现就越复杂（逻辑图很复杂），因此一般使用 RISC。\n  如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较为困难。\n  由于使用存纯硬件实现控制，因此执行速度很快。\n\n二、微程序控制器（重难点）\n要求：会基本概念微命令与微操作，微指令与微周期，主存储器与控制存储器，程序与微程序，MAR 与 CMAR，IR 与 CMDR。还会一些基本结构，比如为地址形成部件，微地址寄存器 CMAR，微指令寄存器 CMDR, 控制存储器 CM。\n\n  微命令：控制器部件向执行部件发出的控制命令，是构成控制序列的最小单位，例如打开或者关闭控制门的电位信号。是各部件完成某个基本微操作的命令\n  微操作：执行部件接受微命令后所进行的操作，和微操作是一一对应的。 （实际上，微命令是微操作的控制信号，微操作是微命令的执行过程，微操作是执行部件中最基本的操作）\n  微指令：若干微命令的集合，存放在一个控制存储器中，而存放微指令的控制存储器的单元成为微地址。在同一 CPU 周期内，并行执行的一组微命令，存储在控制存储器上面，称为一条微指令。\n  微周期：从读取一条微指令，到执行执行完毕所需要的时间称为微周期。\n  控制存储器：主存储器，主要用来存放程序和数据，位于 CPU 的外部，使用的是 RAM。而控制存储器，则主要用于存储微程序，位于 CPU 内部，采用的是 ROM。\n  微程序：实现一条机器指令功能的微指令序列。\n  程序与微程序：程序由机器指令构成，编写好以后放到主存中运行，可以改写。而微程序由微指令构成，事先编写好在 CM（控制存储器）中，一般是不可改写的。微程序的作用就是实现一条对应的机器指令。\n  微程序 &gt; 微指令 &gt; 微命令 = 微操作是微命令的执行过程。\n\n\n\n  一台计算机可以分为控制部件和执行部件。其中控制部件有指令寄存器，程序计数器，操作控制器，执行部件有运算器，存储器，外围设备，状态条件寄存器。\n  汇编程序员可见的寄存器有基址寄存器和状态 / 标志寄存器，程序计数器 PC 及通用寄存器。而 MAR,MDR,IR, 是 CPU 内部寄存器，汇编程序员不可见，微指令相关的汇编程序员也不可见。\n\n水平型微指令的编码方式（重点会考）\n①字段直接编码对于直接编码的方式最大的好处就是能够并行微操作，缩短了微命令的字段长度。有个题能很好的解释这其中的原因。某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码方式，共有 33 歌微命令，构成 5 个互斥类，分别包含 7，3，12，5 和 6 个微命令，则操作控制字段至少有几位？\n每个互斥类要留 1 个状态位不操作，故为 8，4，13，6，7 个微命令。则需要 3，2，4，3，3 位共 15 位控制字段，而直接控制法要 33 位。很明显的缩减操作字段位数。\n优点明显，缺点也明显啊。增加了译码，执行时间会增长，而却增大成本。\n②直接编码就是每个控制字段位，就代表一个微命令，优点就是快，电力嘎嘎简单。但是若微命令要是多达几百条。那不是要几百位了。因此指令位数太长。\n③某带有中断的指令系统有 101 中操作，采用微程序控制方式，存储器中相应最少有 103 个微程序。\n要加上取值操作和终端操作，若有 n 条操作，则有 n+2 个微程序\n④下一条微指令的形成方法常考的：断定法（根据当前执行的微指令寻找到下一条微指令）和计数器法（类似 PC）\n第五节 异常和中断机制这节会在后面第七章一起讲\n第六节 指令流水线讲在前面，为什么要引入指令流水线。相信都听说过华强北的流水线运作方式吧。最明显的优点就是相较于顺序执行的吞吐量更大（单位时间内）运行相同数量的指令也更快。效率也更高。\n这里就可以知道指令流水线的概念：把指令执行过程划分为不同的阶段，占用不同的资源，就能使多条指令同时执行。\n①在流水执行的过程中，会经常遇到冲突，包括结构冲突，数据冲突，控制冲突。\n结构相关 / 冲突 / 冒险数据相关 / 冲突 / 冒险控制相关 / 冲突 / 冒险概念多条指令在同一时刻争用同一资源下一条指令会用到当前指令计算的结果遇到执行转移、调用、返回导致 PC 中断处理办法1. 单独设置数据存储器和指令存储器，使取数和取值操作在不同的存储器中进行2. 暂停时钟周期1. 暂停时钟周期2. 数据旁路技术3. 编译优化1. 早判断，早生成2. 预取转移成功和不成功两个控制流方向的目标指令3. 加快和提前形成条件码4. 提高转移方向的猜准率\n\n②五段式指令流水线（超重要）\n\n顾名思义，五段分为 IF(取值),ID(译码 &amp; 取数),EX(执行),M(访存),WB(写回寄存器)\n只有上一条指令进入 ID 段后，下一条指令才能开始 IF 段，否则会覆盖 IF 段锁存器的内容\n考试中常见的五类指令：\nⅠ、运算类指令的执行过程\nIF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器\nID：取出操作数至 ID 段的锁存器\nEX：运算，将结果存入 EX 段锁存器\nM：空段\nWB：将运算结果写回指定的寄存器\nⅡ、LOAD 指令执行过程\n作用：load 指令可以完成将数据从存储器中复制到目的寄存器中，会访存\nIF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器\nID：将基址寄存器的值放到锁存器 A，将偏移量的值放到 lmm\nEX：运算，得到有效地址\nM：从数据 Cache 中取数并放入锁存器\nWB：将运算结果写回指定的寄存器\nⅢ、STORE 指令执行过程\n作用：将数据从寄存器中，复制到存储器中，会访存\nIF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器\nID：将基址寄存器的值放到锁存器 A，将偏移量的值放到 lmm。将要存的数放到 B\nEX：运算，得到有效地址。并将锁存器 B 的内容放到锁存器 Store\nM：写入数据 Cache\nWB：空段\nⅣ、条件转移指令执行过程\nIF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器\nID：进行比较的两个数放入锁存器 A，B；偏移量放入 lmm\nEX：运算，比较两个数\nM：将目标 PC 值写回 PC\nWB：空段\nⅤ、无条件转移指令的执行过程\nIF：根据 PC 从指令 Cache 取指令至 IF 段的锁存器\nID：偏移量放入 lmm\nEX：将目标 PC 值写回 PC\nM：空段\nWB：空段\n针对条件转移指令和无条件转移指令做以下说明：写入 PC 的好事比 EX 更短，可以安排在 EX 段时间内完成。越早完成就越能避免控制冲突。当然也有在 WB 段修改 PC 值的\n题目总结：①流水 CPU 是由一系列叫做 “段” 的处理线路组成的。一个 m 段流水线稳定时的 CPU 的吞吐能力，与 m 个并行部件的 CPU 的吞吐能力相比具有相同的吞吐能力\n原因是当流水线稳定后，说明已经进行了一条指令，往后每多一个时钟周期就多一条指令执行成功。\nm 个并行平均下来也是一个时针周期就多条指令\n故具有相同的吞吐能力，但是流水线的方式，结构实现较为简单。\n第七节 多处理器的基本概念（选择题）这节的要求就是明白基本概念\n①SISD（单指令流单数据流）\n特点：只能并发，不能并行，每条指令处理一个指令\n不是数据级并行技术\nSISD（单指令流单数据流）SIMD（单指令多数据流）MIMD（多指令多数据流）多处理器系统多计算机系统特点不是数据级并行技术是一种数据级并行技术是一种线程级并行技术多个处理器共享单一物理地址空间每台计算机拥有私有存储器，相互独立特征一条指令处理一个数据一条指令处理多个数据多条指令处理多个数据多个处理器 + 一个主存储器多个处理器 + 多个主存储器\n\n\n  并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。\n  并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。\n\n并发不是并行。并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。（你学废了吗？）\n第六章 总线第一节 总线的概述\n\n  片内总线：芯片内部的总线，是 CPU 芯片内部寄存器与寄存器之间，寄存器与 ALU 之间的公共连接线\n  系统总线：计算机系统内部功能部件（CPU、主存、I/O 接口）之间相互连接的总线，可分为三类，数据总线，地址总线，控制总线\n  通信总线：计算机系统之间或计算机系统与其它系统之间的信息传送的总线\n\n数据总线地址总线控制总线功能传输数据信息传输地址信息传输控制信息大小与什么有关机器字长、存储字长主存地址空间大小传输一个信号方向双向单向既有双向也有单向总线结构单总线（常用）双总线三总线内容系统总线主存总线、I/O 总线主存总线、I/O 总线、DMA 总线结构CPU、主存、I/O 设备都连接在一组总线上主存总线用于 CPU，主存之间的传送；I/O 总线用于多个外部设备与通道之间进行传送多加的一条 DMA 总线是用于主存访问高速外设优点结构简单，成本低，易于接入新的设备将较低速的 I/O 设备从单总线分离出来，实现存储器总线和 I/O 总线分离更加提高了 I/O 设备的性能，更快响应命令，提高系统吞吐量缺点带宽低，负载重，不支持并发传送操作需要增加硬件设备系统工作效率低，同一时刻只能一个总线工作\n\n第二节 性能指标写一些会考的性能指标，配合相应的题\n第三节 总线定时方式同步通信异步通信半同步通信分离式通信特点由统一时钟控制数据传送采用应答方式，没有公共时钟的标准同步、异步结合充分挖掘系统总线每瞬间的潜力优点传送速度快保证两个工作速度相差很大的部件之间进行传输缺点强制性同步复杂，慢\n\n补充：关于异步通信还分为三类：不互锁，速度最快，可靠性最差；半互锁；全互锁。速度最慢，可靠性最好。\n第七章 I/O 系统第一节 I/O 接口简单来说，I/O 接口就是负责协调主机与外部设备之间的数据传输。\n可以这样理解就是你的电脑，怎么控制你的 U 盘上，做一些读写操作。U 盘不是 “亲儿子” 啊，所以要单独给它设置接口来控制它。\nCPU 那如何确定要操作的是主存还是外部设备呢。这就引出了编制方式——统一编制和独立编址\n统一编制独立编制内容把外部设备的存储当成内存进行分配，有统一的地区分配，靠不同的地址区别内存和外部设备独立编制，专门为输入 / 输出指令设置访问端口，靠不同指令区别内存和外部设备优点1. 不需要专门的指令表示访问外存2. 读写控制电路简单3，程序设计灵活性高1. 地址译码快2. 不占用主存地址空间缺点1. 端口占用了主存地址空间，使主存地址空间变小2. 寻址时间长（外部设备）1. 程序设计灵活差2. 指令增加，控制电路复杂\n\n补充个会考的内容，关于显存 VRAM（就是显示存储器）\n显存是为了提高刷新图像的信号，会提前把需要显示的数据放入显存中。如今的计算机很多都有独立显存，就这可以避免，显存占用主存的空间。\n显存会考的计算：\n容量 = 分辨率 × 灰度级位数\n带宽 = 分辨率 × 灰度级位数 × 帧数\n第二节 主机访问 I/O 设备的控制方式一、程序查询方式\n特点：CPU 与 I/O 串行工作，CPU 不断查询 I/O 设备状态，直到外设准备就绪。\n优点：接口设计简单，设备量少。\n缺点：CPU 信息传送过程中要花费很多时间用于查询和等待，而且在一段时间内只能和一台外设交换信息，效率低。\n独占查询：CPU100% 的时间都在查询 I/O 状态，完全串行。\n定时查询：每隔一段时间 CPU 就查询 I/O 状态，查询的间隔内 CPU 可以执行其他程序。\n二、中断方式\nⅠ、程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU 暂时中断现行程序，而转去执行这些异常情况或特殊请求进行处理。处理完毕后又自动返回到现行程序的断点处，继续执行原程序。\n引出几个问题：\n问题一：接收到中断信号后是怎么转到执行中断程序的？\n问题二：中断程序执行完后是怎么回来执行原先程序的？\n问题三：假如有多个程序断源同时申请，怎么专门安排优先顺序？\n问题四、如何判断是哪个设备发来的中断信号？\nⅡ、**整个中断方式的流程（重点）**\n\n中断请求\n\n“先说明开中断和关中断的作用，关中断保证原子操作，不会被打断，标志位 IF=1 为开中断（允许中断）”\nCPU 在统一时刻每条指令执行阶段结束前向接口发出中断查询信号，获取 I/O 的中断请求，也就是说，CPU 响应中断的时间是在每条指令执行阶段的结束时刻。\n如何判断是哪个设备发来的中断信号？\n会存在一个中断请求标记寄存器，里面不同位代表不同的设备中断。状态位为 1 的话，代表处理中断申请。\nCPU 响应中断必须满足以下 3 个条件：\n①中断源有中断请求。\n②CPU 允许中断即断开中断。\n③一条指令执行完毕，且没有更紧迫的任务。\n\n中断响应\n\n假如有多个程序断源同时申请，怎么专门安排优先顺序？\n有两种处理办法：\n①硬件实现硬件排队器\n②软件实现查询程序\n中断的优先级：\n硬件故障中断 &gt; 软件中断\n非屏蔽中断 &gt; 可屏蔽中断\nDMA 请求 &gt; I/O 设备传送的中断请求\n有再补充\n\n中断处理\n\n接收到中断信号后是怎么转到执行中断程序的？\n这时候就需要中断隐指令：保存原程序的 PC 值，并让 PC 指向中断程序的第一条。\n中断隐指令的任务：\n①关中断。在中断服务程序中，为保护中断现场不会再被新的中断打断，就必须关中断\n②保存断点。保证 “回得来”\n③引出中断服务。将中断服务程序入口地址传送给程序计数器\n引出中断服务，如何将中断传给 PC？\n通过硬件向量法，将硬件（中断向量地址形成部件）产生向量地址，再由向量地址找到入口地址。\n中断处理过程—硬件向量法。为什么要用向量地址去寻找中断的入口，而不是直接去寻找中断入口？\n\n若是通过中断向量地址形成部件直接去入口地址的话，会造成中断程序有时候长短不一，就要频繁修改中断向量地址形成部件。\n\n若是先通过向量地址，在内存中找到中断地址的话，只需修改内存的地址就可以。\n\n\n\n中断服务程序的任务\n①保护现场。保存通用寄存器和状态寄存器的内容。\n②中断服务。主体部分。例如将需要打印的字符传送到打印机的缓冲存储器中。\n③恢复现场。通过出栈或取值把之前保存的信息传送回寄存器中。\n④中断返回。通过中断返回指令回到原程序断点处。\n总结：中断处理过程 = 中断隐指令 + 中断服务程序\n\nⅢ、单重中断和多重中断\n单重中断：执行中断服务程序时不响应新的中断请求。\n多重中断：又称中断嵌套，执行中断服务程序时可响应新的中断请求。\n对于多重中断有中断屏蔽技术，在中断服务开启前打开中断指令。优先级别高的中断源有权中断优先级别低的中断源。\n这时候就要设置一个屏蔽触发器，1 表示屏蔽该中断请求，0 表示正常申请，所有屏蔽触发器构成一个屏蔽寄存器，屏蔽寄存器里面内容就是屏蔽字。\n有以下几个说明\n①每个中断源至少有一个 1（对自身中断源）\n②1 越多，优先级越高\n\n三、DMA 方式\nDMA 的特点：\n1、内存既可以被 CPU 访问也可以被 DMA 控制器访问，CPU 和 DMA 控制器会竞争总线的使用权，因而需要仲裁机制。\n2、外部设备与内存之间的整个数据交换过程全部在 DMA 控制器的控制下完成，CPU 能够与外部设备并行工作，大大提高了效率。\n3、在 DMA 方式开始之前 CPU 要对 DMA 控制器进行初始化，在 DMA 方式结束之后，CPU 要申请中断，对内存缓冲区进行后处理。\nDMA 的处理方式：\n\n预处理：CPU 完成寄存器初值设置等准备工作。\n\n数据传输：CPU 继续执行主程序，DMA 控制器完成数据传送\n\n后处理：CPU 执行中断服务程序做 DMA 结束处理\n\n\nDMA 的传送方式：\n\n停止 CPU 访存：需要传送数据时，停止 CPU 访存，总线控制器交给 DMA 控制器。\n\n周期挪用方式：当 I/O 接口没有 DMA 请求时，CPU 按程序要求访问内存；一旦 I/P 接口有 DMA 请求，则 I/O 接口挪用一个或几个周期。缺点是：数据输入或输出过程中实际占用了 CPU 时间。\n\n交替访存方式：CPU 与 DMA 控制器交替访问内存。不需要总线使用权的申请、建立和归还过程。\n\n\n效率高，但实现起来有困难，基本上不被使用。\n\n  DMA 与中断方式的差别\n\n中断DMA数据传送程序控制硬件控制—DMA 控制器。CPU 只需进行预处理和后处理中断请求传送数据向 CPU 报告传输结束响应指令执行周期结束后响应中断每个机器周期结束都可，即总线空闲即可适用场景CPU 控制，低速设备DMA 控制器控制，高速设备优先级低于 DMA高于中断工作方式CPU 与外设并行，传送与主程序串行CPU 与外设并行，传送与主程序并行请求内容请求的是 CPU 处理时间请求的是总线使用权\n\n\n  中断的分类：\n\n\n","tags":["计算机组成原理"]},{"title":"静态IP 动态IP 浮动IP 虚拟IP 区别是什么？","url":"/2021/11/16/simpread-%E9%9D%99%E6%80%81%20ip%20%E5%8A%A8%E6%80%81%20ip%20%E6%B5%AE%E5%8A%A8%20ip%20%E8%99%9A%E6%8B%9F%20ip%20%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/","content":"static ip 就是固定分配的 ip，需要手工管理，非常麻烦。为了减少麻烦，人们发明了 dhcp 协议，来自动为电脑分配 ip，这就是 dynamic ip。floating ip 跟 dynamic ip 有点像，参考各公有云厂商的弹性 ip。\n但不论 static ip、dynamic ip 还是 floating ip，一个 ip 只能分配给一台电脑。\n在有些情况（比如高可用场景）下我们需要多台电脑共用一个 ip，也就是说一个 ip 「属于」多台电脑。那怎么实现呢？是给两台电脑设置同一个 ip 吗？显然不是，因为为产生 ip 冲突。这就需要 virtual ip。\n比如我们有两台服务器 AAA 和 BBB，它们的 IP 分别是 10.0.0.1 和 10.0.0.2。它们功能相同，提供相同的服务。\n理论上大家可以直接能过 10.0.0.1 或者 10.0.0.2 来访问 AAA 或 BBB 的服务。但如果某一台机器宕机，就没法访问了。要解决这个问题就需要 virtual ip。\n\n首先，我们从 AAA 和 BBB 中选一个作主，另一个作备。然后要求它们互相探测，确保对方都在线。然后给 AAA 和 BBB 同时「分配」一个 virtual ip 10.0.0.100。其他主机需要通过 10.0.0.100 来访问 AAA 或 BBB 提供的服务。\n一般来说，其他主机要访问 10.0.0.100 需要通过 ARP 获取对应的 MAC 地址。如果 AAA 和 BBB 同时应答 ARP 请求，就会产生冲突。因为 10.0.0.100 是 virtual ip，所以，只有主服务器 AAA 才能应答。BBB 收到 ARP 请求后发现 AAA 还活着，就自动闭嘴。\n\n之后所有访问 10.0.0.100 这个 virtual ip 的请求都会发到 AAA。\n如果 AAA 出现故障呢？这个时候其他主机发现 10.0.0.100 不通了，于是发出新的 ARP 请求\n\n同时，BBB 也探测不到 AAA，它知道自己的高光时刻来到了，于是 BBB 大声响应 ARP 请求说「向我开炮」。\n\n总结下来，virtual ip 就是多主机设置相同 ip，但只有一台主机可以在特定条件下响应 arp 请求。\n","tags":["计算机网络"]},{"title":"计网基础知识","url":"/2021/11/16/simpread-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%AA%E9%9A%BE%EF%BC%9F%E4%BA%86%E8%A7%A3%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/","content":"计算机网络、计算机操作系统这两个 “兄弟” 是所有开发岗位都需要 “结拜” 的，不管你是 Java、C++ 还是测试。对于后端开发的童鞋来说，计算机网络的重要性不亚于语言基础，毕竟平时开发经常会和网络打交道，比如：抓个包等等。所以对这一块知识点的准备还是要抱着敬畏之心，不要放过任何一个漏网之题。下面分享下我的学习过程：\n\n看书：对于计算机比较基础的模块，我都是比较推荐找一本经典的书籍来好好学习下，不可以只看面经就去面试了。我一共看了两本书：汤小丹的《计算机操作系统》和《图解 HTTP》。《计算机操作系统》是教科书，所以知识点相对比较基础，覆盖范围也比较广，非科班的学生还是很有必要看一看的。《图解 HTTP》这本书用很多插图将一些知识点讲的通俗易懂，看起来也很快，还是比较推荐的。\n\n做笔记：计算机网络的知识点还是比较多的，需要看书的时候做好笔记，方便复习。而且做笔记的时候可以就这个知识点去百度下，看看有没有自己遗漏的点，再给补充进来。在这里说下，我为什么一直强调做笔记？好处 1：做笔记是第 1 次你对书中的知识点的回顾，加深记忆；好处 2：而且如果你是发表在公关社区的肯定要保证最大限度的正确性，就需要再去看看这个知识点，核对下自己是否有理解偏差和遗漏等，这样就完成了知识点的深挖；好处 3：正在到面试复习的时候，你是不太可能重新看一本书的，那么笔记就显得很重要了，自己做的笔记，复习起来很快，而且最好在笔记里能有一些自己区别于面经的理解。\n\n看面经：经常刷一刷牛客，看看对于计算机网络，面试官们都是怎么问的？很多问题你可能会，但是不懂面试官的问法，也会回答不上来；问到的题目自己是否准备了？而且对于计算机网络和计算机操作系统会因为公司和岗位的不同而有所侧重的，多看看面经就会发现还是有一点规律的，但是这都不是绝对的，最后还要看面你的面试官的喜好。\n\n\n1、谈下你对五层网络协议体系结构的理解？学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。\n\n  1. 应用层\n\n应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。\n\n  2. 运输层\n\n运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的” 是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。\n由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。\n\n  3. 网络层\n\n在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。\n\n  4. 数据链路层\n\n数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。\n在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。\n\n  5. 物理层\n\n在物理层上所传送的数据单位是比特。物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流” 表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。\n2、简单说下每一层对应的网络协议有哪些？计算机五层网络体系中涉及的协议非常多，下面就常用的做了列举：\n\n3、ARP 协议的工作原理？网络层的 ARP 协议完成了 IP 地址与物理地址的映射。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。\n此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。\n4、谈下你对 IP 地址分类的理解？IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。\n每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：\nA 类地址：以 0 开头，第一个字节范围：0~127；\nB 类地址：以 10 开头，第一个字节范围：128~191；\nC 类地址：以 110 开头，第一个字节范围：192~223；\nD 类地址：以 1110 开头，第一个字节范围为 224~239；\nE 类地址：以 1111 开头，保留地址\n5、TCP 的主要特点是什么？\nTCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；\n\n每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；\n\nTCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；\n\nTCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；\n\n面向字节流。TCP 中的 “流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流” 的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。\n\n\n6、UDP 的主要特点是什么？\nUDP 是无连接的；\n\nUDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；\n\nUDP 是面向报文的；\n\nUDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；\n\nUDP 支持一对一、一对多、多对一和多对多的交互通信；\n\nUDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。\n\n\n7、TCP 和 UDP 的区别？TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。\nUDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等。\n8、TCP 和 UDP 分别对应的常见应用层协议有哪些？\n  1. TCP 对应的应用层协议\n\nFTP：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。\nTelnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是 - 纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。\nSMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置 - 中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。\nPOP3：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是 163 邮箱就没有必要先进入网易网站，再进入自己的邮 - 箱来收信）。\nHTTP：从 Web 服务器传输超文本到本地浏览器的传送协议。\n\n  2. UDP 对应的应用层协议\n\nDNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。\nSNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。\nTFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。\n9、详细说下 TCP 三次握手的过程？\n  1. 三次握手\n\nTCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。\n\n最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。\n一开始，B 的 TCP 服务器进程首先创建传输控制块 TCB，准备接受客户端进程的连接请求。然后服务端进程就处于 LISTEN(监听) 状态，等待客户端的连接请求。如有，立即作出响应。\n第一次握手：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。\n第二次握手：B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。\n第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。\n10、为什么两次握手不可以呢？为了防止已经失效的连接请求报文段突然又传送到了 B，因而产生错误。比如下面这种情况：A 发出的第一个连接请求报文段并没有丢失，而是在网路结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段。但是 B 收到此失效的链接请求报文段后，就误认为 A 又发出一次新的连接请求。于是就向 A 发出确认报文段，同意建立连接。\n对于上面这种情况，如果不进行第三次握手，B 发出确认后就认为新的运输连接已经建立了，并一直等待 A 发来数据。B 的许多资源就这样白白浪费了。\n如果采用了三次握手，由于 A 实际上并没有发出建立连接请求，所以不会理睬 B 的确认，也不会向 B 发送数据。B 由于收不到确认，就知道 A 并没有要求建立连接。\n11、为什么不需要四次握手？有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？\n我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。\n12、Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。\nSYN 是 TCP / IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符，在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误]）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。\n13、传了 SYN，为什么还要传 ACK？双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。\n14、详细说下 TCP 四次挥手的过程？据传输结束后，通信的双方都可以释放连接。现在 A 和 B 都处于 ESTABLISHED 状态。\n​\n\n第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待 1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。\n第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加 1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待 2) 状态，等待 B 发出的连接释放报文段。\n第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认) 状态，等待 A 的确认。\n第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。\n15、为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？\n为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。\n\n防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。\n\n\n16、为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。\n17、保活计时器的作用？除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。\n服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。\n18、TCP 协议是如何保证可靠传输的？\n数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；\n\n对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；\n\n丢弃重复数据：对于重复数据，能够丢弃重复数据；\n\n应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；\n\n超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；\n\n流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。\n\n\n19、谈谈你对停止等待协议的理解？停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。\n20、谈谈你对 ARQ 协议的理解？\n  自动重传请求 ARQ 协议\n\n停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。\n\n  连续 ARQ 协议\n\n连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\n21、谈谈你对滑动窗口的了解？TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。\nTCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。\n22、谈下你对流量控制的理解？TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n23、谈下你对 TCP 拥塞控制的理解？使用了哪些算法？拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。\n拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。\n为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 (cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。\nTCP 的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。\n\n  慢开始：\n\n慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。\n\n  拥塞避免：\n\n拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。\n\n  快重传与快恢复：\n\n在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。\n没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。\n有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。\n24、什么是粘包？在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。\n\nTCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；\n\n从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。\n\n\n基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。\n接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。\n25、TCP 黏包是怎么产生的？\n  发送方产生粘包\n\n采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。\n\n  接收方产生粘包\n\n接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）\n26、怎么解决拆包和粘包？分包机制一般有两个通用的解决方法：\n\n特殊字符控制；\n\n在包头首都添加数据包的长度。\n\n\n如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。\ntips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。\n27、你对 HTTP 状态码有了解吗？\n  1XX 信息\n\n\n100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。\n\n\n  2XX 成功\n\n\n200 OK\n\n204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。\n\n206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。\n\n\n\n  3XX 重定向\n\n\n301 Moved Permanently ：永久性重定向；\n\n302 Found ：临时性重定向；\n\n303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。\n\n304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。\n\n307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。\n\n\n\n  4XX 客户端错误\n\n\n400 Bad Request ：请求报文中存在语法错误。\n\n401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。\n\n403 Forbidden ：请求被拒绝。\n\n404 Not Found\n\n\n\n  5XX 服务器错误\n\n\n500 Internal Server Error ：服务器正在执行请求时发生错误；\n\n503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n\n\n28、HTTP 状态码 301 和 302 代表的是什么？有什么区别？301，302 都是 HTTP 状态的编码，都代表着某个 URL 发生了转移。\n\n  区别：\n\n301 redirect: 301 代表永久性转移（Permanently Moved）\n302 redirect: 302 代表暂时性转移（Temporarily Moved）\n29、forward 和 redirect 的区别？Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。\n直接转发方式（Forward）：客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。\n间接转发方式（Redirect）：实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。\n\n  举个通俗的例子：　\n\n直接转发就相当于：“A 找 B 借钱，B 说没有，B 去找 C 借，借到借不到都会把消息传递给 A”；\n间接转发就相当于：”A 找 B 借钱，B 说没有，让 A 去找 C 借”。\n30、HTTP 方法有哪些？客户端发送的 请求报文 第一行为请求行，包含了方法字段。\n\nGET：获取资源，当前网络中绝大部分使用的都是 GET；\n\nHEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；\n\nPOST：传输实体主体\n\nPUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。\n\nPATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。\n\nOPTIONS：查询指定的 URL 支持的方法；\n\nCONNECT：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。\n\nTRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。\n\n\n31、说下 GET 和 POST 的区别？GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。\n本质区别：GET 只是一次 HTTP 请求，POST 先发请求头再发请求体，实际上是两次请求。\n\n从功能上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；\n\n从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；\n\n从请求参数形式上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母 / 数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串 (如果是空格，转换为 +，如果是中文 / 其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的 请求体 中；\n\n就安全性而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；\n\n从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。\n\n\n32、在浏览器中输入 URL 地址到显示主页的过程？\nDNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析 (此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；\n\nTCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；\n\n发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；\n\n服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；\n\n浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。\n\n连接结束。\n\n\n33、DNS 的解析过程？\n主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文 (即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。\n\n本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。\n\n\n34、谈谈你对域名缓存的了解？为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。\n由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。\n不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。\n35、谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。\n而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码\nConnection:keep-alive\n\n在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。\nKeep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。\n36、谈下 HTTP 1.0 和 1.1、1.2 的主要变化？\n  HTTP1.1 的主要变化：\n\n\nHTTP1.0 经过多年发展，在 1.1 提出了改进。首先是提出了长连接，HTTP 可以在一次 TCP 连接中不断发送请求。\n\n然后 HTTP1.1 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，post 请求默认就是这样做的。\n\nHTTP1.1 的 host 字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。\n\n\n\n  HTTP2.0 的主要变化：\n\n\nHTTP2.0 支持多路复用，同一个连接可以并发处理多个请求，方法是把 HTTP 数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP 请求顺序到达；\n\nHTTP2.0 支持服务端推送，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；\n\nHTTP2.0 压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少；\n\nHTTP2.0 适用于 HTTPS 场景，因为其在 HTTP 和 TCP 中间加了一层 SSL 层。\n\n\n37、HTTPS 的工作过程？\n客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；\n\n服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；\n\n客户端收到网站的证书之后要做下面的事情：\n\n\n\n  3.1 验证证书的合法性；\n  3.2 果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；\n  3.3 用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。\n\n\n服务器接收到客户端传送来的信息，要做下面的事情：\n\n\n  4.1 用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致；\n  4.2 使用密钥加密消息；\n\n\n如果计算法 hash 值一致，握手成功。\n\n38、HTTP 和 HTTPS 的区别？\n开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；\n\n资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；\n\n端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443；\n\n安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。\n\n\n39、HTTPS 的优缺点？\n  优点：\n\n\n使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；\n\nHTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；\n\nHTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。\n\n\n\n  缺点：\n\n\nHTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；\n\nHTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；\n\nSSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；\n\nSSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；\n\nHTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。\n\n\n40、什么是数字签名？为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。\n41、什么是数字证书？对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。\n42、什么是对称加密和非对称加密？对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。\n非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。\n由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。\n","tags":["计算机网络"]},{"title":"使用Linux的iptables实现路由转发","url":"/2023/02/03/%E4%BD%BF%E7%94%A8linux%E7%9A%84iptables%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E8%BD%AC%E5%8F%91/","content":"使用linux的iptables实现路由的转发开启ip包转发功能linux默认关闭该功能\nvim /etc/sysctl.conf#加入或修改net.ipv4.ip_forward = 1\n重启\nreboot\n\n开启NAT功能sudo iptables -t nat -A POSTROUTING -o enp0s3 -j MASQUERADE\n将非本机地址的ip包修改源地址后从连网的网口发出去，enp0s3修改为自己的外网网卡重启会发现配置失效。下面有一种方案可以让配置永久生效，但是不是很优雅，但是可以避免使用iptables-services\niptables-save &gt; /etc/sysconfig/iptables\n然后修改/etc/rc.d/rc.local，可以在启动时自动执行该命令\n#将下面一行加入文件最后iptables-restore &lt; /etc/sysconfig/iptables\n将该文件设为可执行文件\nchmod +x /etc/sysconfig/iptables\n这样重启时就可以保持该设置了。\nNAT本机网卡设置# 将ifcfg-enp0s8网卡配置的下列内容修改为你的信息IPADDR=172.10.1.1MASK=255.255.0.0\n\n其它机器网卡设置# 将网关gateway设置为上边nat主机的地址IPADDR=172.10.1.2MASK=255.255.0.0GATEWAY=172.10.1.1DNS1=114.114.114.114","tags":["Linux"]},{"title":"使用windows网络共享实现NAT","url":"/2023/02/03/%E4%BD%BF%E7%94%A8windows%E7%BD%91%E7%BB%9C%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0NAT/","content":"使用windows网络共享实现NAT适用范围有一台可以上外网的机器，局域网内其它多台机器无法访问外网，只有一根网线，又没有交换机等等，比如虚拟机集群中，使用vsphere，没有自带的NAT功能，这时候就可以使用本文档的方法实现局域网NAT访问外网。使用VirtualBox时，也可以通过这种方法，只需要配置一个host only网卡即可，不需要另外配置一个NAT网卡。Vmware Workstation自带了NAT转换功能，在windows中建立了host only和nat网卡，已经做好了功能，也不需要本文档描述的功能。\n配置方法\n操作主机A，进入到控制面板网络连接界面，选择可以访问外网的适配器，右键打开属性，进入到共享tab页\n勾选允许其他网络用户通过此计算机的Internet连接来连接\n选择家庭网络连接为内部网络，比如VirtualBox的Host-Only网络，点击确定\n右键打开内部网卡属性，在网络tab下，找到Internet协议版本4（TCP/IPv4）设置，双击打开，会发现内部网络的ip修改为了预设的ip\n配置其它机器的网络，可以使用自动获取也可以设置为固定ip，如果选择固定ip就将ip设置为主机A内部网络设置的ip和子网掩码网段下，网关设置为主机A内部网络的ip，即可实现外网访问。\n如果不想使用默认的主机A的ip网段，则可以在Internet协议版本4（TCP/IPv4）设置中，点击高级，在IP设置tab页，IP地址添加，将需要的网关地址和子网掩码填入，然后保存即可。\n\n扩展vmware workstation的NAT网络架构\nVirtualBox的NAT网络架构\n","tags":["Linux"]},{"title":"很好的论文网站","url":"/2023/02/01/%E5%BE%88%E5%A5%BD%E7%9A%84%E8%AE%BA%E6%96%87%E7%BD%91%E7%AB%99/","content":"\nhttps://ujjwalkarn.me/2016/08/11/intuitive-explanation-convnets/\n\nhttps://paperswithcode.com/sota\n","tags":["论文"]},{"title":"精选链接","url":"/2023/01/31/%E9%87%8D%E8%A6%81%E9%93%BE%E6%8E%A5/","content":"中国科学技术大学开源镜像资源：http://mirrors.ustc.edu.cn/\n清华大学开源镜像： https://mirrors.tuna.tsinghua.edu.cn/\n各种版本的git:  https://npm.taobao.org/mirrors/git-for-windows/\n人工智能还能最新论文和代码：  https://paperswithcode.com/sota\n各种版本JDK:   https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html\n在线将Excel换成MarkDown：https://tableconvert.com/excel-to-markdown\nC++教程    ：https://hackingcpp.com/\n莫凡Python：  https://mofanpy.com/\n英特尔® 至强® 可扩展处理器 - 查看全新一代至强处理器：\nhttps://www.intel.cn/content/www/cn/zh/products/details/processors/xeon/scalable.html\n！！英特尔® 产品规格对比 至强处理器！！：https://ark.intel.com/content/www/cn/zh/ark/compare.html?productIds=192478,192447,193394,193381\n英特尔工具和实用程序：https://www.intel.cn/content/www/cn/zh/support/topics/utility-tools.html\nVMware常用软件ISO下载汇总（2021年3月更新） – 丁辉博客：https://www.dinghui.org/vmware-iso-download.html\n固件和驱动相关：https://datacentersupport.lenovo.com/cn/zh/\nLenovo硬件信息：https://lenovopress.com/#sort=relevance\n联想ThinkSystem机器安装2008R2详细教程 - 猫先生的日常点滴：https://www.mr-mao.cn/archives/thinksystem-2008.html\n服务器配置的网站和工具： https://dcsc.lenovo.com/#/\n英特尔CPU EVC矩阵（VMware增强的vMotion兼容性） :   https://www.virten.net/2013/04/intel-cpu-evc-matrix/\nvMotion兼容性（EVC）处理器支持:     https://kb.vmware.com/s/article/1003212\nvmware 中EVC是做什么用的？能起到什么样的效果？_百度知道：   https://zhidao.baidu.com/question/426142671976251772.html\nCreating a vSAN Cluster without a vCenter Server | MrVSAN：  https://www.mrvsan.com/creating-vsan-cluster-without-vcenter-server/\nMSDN原版之家：https://msdn.pe8.com/win11.html\nMSDN老版：http://www.msdn1.cn/index.html\nMSDN新版：http://xin.msdn1.cn/\n","tags":["学习"]},{"title":"Meta Learning 单排小教学","url":"/2023/02/01/simpread-Meta%20Learning%20%E5%8D%95%E6%8E%92%E5%B0%8F%E6%95%99%E5%AD%A6/","content":"大家好！欢迎来到 FloodSung 的 AI 游乐场！\n虽然 Meta Learning 现在已经非常火了，但是还有很多小伙伴对于 Meta Learning 不是特别理解。考虑到我的这个 AI 游乐场将充斥着 Meta Learning 的分析解读及各种原创思考，所以今天 Flood 就和大家做一个 Meta Learning 小教学，希望能够用最简短，最通俗的语言来让大家明白 Meta Learning 的概念，Meta Learning 的几种研究方法，以及 Meta Learning 未来的发展，带大家上分！相信这个 Meta Learning 小教学是目前全网唯一的中文教程。\n当然要看懂这个小教学，大家至少要对深度学习和增强学习有一定了解。下面我们就开始吧!\n1.Meta Learning 到底研究什么？\n要回答这个问题，我们先来问另一个问题：  \nDeep Learning 是在研究什么？\n简单一句话就是 Deep Learning 研究一个从 x 到 y 的映射 mapping，只是这个映射函数 f 是用一个端到端的深度神经网络来表示：\n\n如果是计算机视觉中的图像识别，那么 x 就是图片，y 就是标签；\n如果是自然语言处理中的文本翻译，那么 x 就是比如中文，y 就是英文；\n如果是深度增强学习中的玩 Atari 游戏，那么 x 就是屏幕画面，y 就是输出的动作。\n所以，我们可以看到，深度学习研究的就是通过深度神经网络来学习一个针对某一特定任务 task 的模型。通过大量的样本进行训练，训练完，这个模型就可以用在特定任务上。\n说完 Deep Learning 研究什么，那 Meta Learning 呢？\nMeta Learning 研究 Task！\nMeta Learning 的目的是希望学习很多很多的 task，然后有了这些学习经验之后，在面对新的 task 的时候可以游刃有余，学的快又学的好！\n为什么叫 Meta 呢？Deep Learning 是在 Task 里面研究，现在 Meta Learning 是在 Task 外面，更高层级来研究。也就是在 Meta Learning 的问题上，Task 是作为样本来输入的。这里我们将用 Few-Shot Learning 的问题加以解释。\n\n但在此之前，我们要先从人类智能的角度，仿生学的角度说说 Meta Learning 的意义！\n2. 为什么研究 Meta Learning？\nDeep Learning 现在的研究，训练一个模型，都是从 0 开始，也就是所谓的 train from scratch。但是对比一下人，我们人是从 0 开始学习嘛？没有，人就算是刚出生的婴儿，都已经有一套本能的智能来引导他们去学习，而之后随着人不断长大，我们就慢慢的不再从 0 开始学习了，都是基于我们已有的知识学习，也就是所谓的先验知识 Prior。比如我们没有玩过炉石传说这个游戏，但是我们通过我们的先验知识知道这是卡牌游戏，然后我们理解了游戏规则，我们也就可以上手来玩了。所以，我们人要玩一个新游戏是非常快的，而现在 Deep Learning，Deep Reinforcement Learning 在做什么？在让一个婴儿从 0 开始学习玩游戏。这不符合现实，而实际上我们也发现从 0 开始学习需要巨量的时间，虽然最后学会了甚至学的比人更好，但是这很不类人，很不智能。\n因此，我们的研究需要转换一下思路了，我们为什么要从 0 开始学习呢？我们为什么不先学习一个 Prior 先验知识呢？如果我们构建的深度学习系统能够学到先验知识，并且能够利用这些知识，我们就可以在新的问题上学的更快更好！那么，这个就是 Meta Learning 要做的事情了，非常有意义，非常符合人工智能的发展路线。更进一步的，如果我们能够实现 lifelong learning 终身学习，那么我们的人工智能系统就可以越来越智能了。\n有了这样的背景知识，我们就更好的理解 Meta Learning 要干什么了？我们不是要学一个具体的模型，我们要学的是一个先验知识。这里我特别喜欢用金庸武侠的武功修炼比喻，如果说 Deep Learning 是学习具体的外功的话，Meta Learning 我们要学的是内功。\n\n相信大家都看过倚天屠龙记，里面张无忌自从学习了九阳神功之后，学任何武功什么太极拳，乾坤大挪移都变得特别快。Meta Learning 就是我们的九阳神功。\n那么从 AI 的发展角度看，人工智能的发展肯定是一个由外向内的过程，简单的 x 到 y 的映射这种其实一点都不知道，想想人的情感，人的思维，一句话可以解毒出无数种可能，怎么可能是简单的 x 到 y 呢？ 也因此，Meta Learning 是 AI 研究的必然趋势。\n3. Few-Shot Learning，一个引子\n有了上面的知识基础，我们现在就要深入一点，具体的看一个典型的 Meta learning 问题，也就是 Few-Shot Learning 少样本学习！\n\n这里我引用了 Google Brain 的 Hugo Larochelle 的一张 ppt 来加以说明。我们知道一般的图像识别比如 imagenet，就是给你 1000 个类的训练集进行训练，每一个类有 600 张图片，然后训练好神经网络后，我们要用 1000 个类里面新的图片对这个神经网络进行测试，看能够识别多好。那么 Few-Shot Learning 的要求就是少样本，我们希望给你 5 个类的训练集进行训练，每一个类只有 1 张或者几张图片，总之非常少，然后训练好神经网络之后，我们要用着 5 个类里面的新的图片进行测试，看识别效果。\n那么我们直接看这个问题，肯定觉得不可能啊，只用几张图片怎么训练？不得分分钟过拟合吗？没关系，我们有 Meta Learning 的设定，这训练样本和测试样本都只是一个 task，我们可以用很多别的 task 进行训练，学习一个 Prior，然后我们希望在新的 task 上能够学出效果来。\n所以就如上图所示，在 Meta Learning 上，我们不再直接叫 train 和 test 了，而是叫 Meta-train 和 Meta-test。在上图中，每一行都是一个 task，包含了 task 的 train set 和 test set，图中展示就是所谓的 5way 1shot 设定，也就是一个 task 包含 5 个类，每一个类一个训练样本，然后给你 2 个测试样本测试。我们可以把每一个 task 当做一个 meta learning 的训练样本。我们要通过多种 task 的训练，从而在 Meta-test 的时候也就是在新的 task 上取得好效果。\n相信通过上面的解释，大家对于 Meta Learning 这个问题设定是理解的了。下面我们就来看看怎么来学这些 task。\n4.Meta Learning 的三种解决办法\n我们还是根据 Few-Shot Learning 的问题设定来说明怎么学。\n我们看到，现在输入到神经网络的数据变了，实际上就是多了一个 D_train 训练集，也就是这个 task 拥有的东西。这个训练集比如上面说的 5way 1shot，也就是 5 张图片和 5 个对应的标签。我们希望我们的神经网络能够仅根据这几张图片得到一个针对这几张图片的神经网络，从而能够对新的样本进行识别。所以，这里就产生一个问题：\n怎么使用 D_train 来影响我们的神经网络呢？\n1）HyperNetwork 生成参数\n\nHyperNetwork 是一个蛮有名的网络，简单说就是用一个网络来生成另外一个网络的参数。那么我们这里非常直接，我们的设想就是希望用一个 hypernetwork 输入训练集数据，然后给我输出我的对应模型也就是上图 f 的参数，我们希望输出的这个参数能够使得在测试图片上取得好的识别效果。那么，有了这样设计，这个 hypernetwork 其实就是一个 meta network。大家可以看到，本来基本的做法是用训练集直接训练这个模型 f，但是现在我们用这个 hypernetwork 不训练了，直接给你输出参数，这等价于 hypernetwork 学会了如何学习图像识别，这也是为什么 meta learning 也同时叫做 learning to learn 的原因。我们通过 hypernetwork 学会学习。训练好了这个模型，连反向传播梯度下降都不要了，直接给你参数，是不是很酷？\n那怎么训练这个神经网络呢？\n这里有个所谓的 episodic training！一个 episode 就是包含了一个 task，有训练集有测试集。我们使用训练集输入到 hypernetwork，得到 f 的参数，然后使用测试集输入到 f 得到预测的标签，最后用测试集的样本标签得到模型的 loss，之后就用梯度下降进行训练。所以我们可以看到，整个模型是端到端的。通过大量的 episodic training，也就是大量的 task 进行训练，我们就可以训练出一个模型出来。\n需要稍微说明一下这个 task 哪里来呢？我们采样出来的。比如我们给你 100 个类的训练样本，每一个类可能有 600 个图片，也就是 imagenet 的规模。但是我们这里不是直接 batch 这些样本进行训练，而是随机采样出一个 task，比如选 5 个类，每一个类 1 个图片，然后再每一个类选 5 个图片作为 task 的测试集。这样采样是为了模拟 meta-test 阶段的 task 构造。\n\n那么因为 meta-train 和 train 和乱，常常会混掉，所以大家约定俗成的把 task 里面的训练集称为 support set，把 task 里面的测试集称为 query set。而 Meta training set 和 Meta test set 分别直接称为 training set 和 test set。\n使用 Hypernetwork 在我看来是最直接表现 meta learning 的一种做法。但是现在实际上我们好像没有看到直接用 hypernetwork 做 few shot learning 的 paper，而都是间接的使用，或者简单使用一下。具体的优缺点我们还是等下再总结。先说第二个方法。\n2）Conditional Neural Network 条件神经网络\n\n这个做法其实就是上图啦，我们直接把 D_train 当做条件输入到 f 中，那么这个 f 本身就变成一个 meta network 了。也就是条件神经网络实际上能够得到和上面的 hypernetwork 一样的意义。因为我们可以想，只要条件 D_train 变了，那么 y_test 肯定也就变了。所以这里就非常非常直接了。把数据全部输入进去，让神经网络自己学就行了，不外乎就是去设计一个合适的网络结构而已。那么，这里最最简单粗暴的网络结构就是 SNAIL 算法使用 temporal convolutional network，也就是 wavenet 的架构：\n\n当然，我们也可以巧妙一点的设计，比如我的 relation net，不把标签 y 作为输入：\n\n事实上基于条件神经网络的做法，效果是最好的。\n3）MAML 基于梯度的做法\n现在我们来说 MAML，这个可以单独算一个不一样的做法。\n\n这个思路只能说也太简单了，就是为什么不用 D_train 先用一般的监督学习方式更新一下网络，然后再使用更新参数后的 f 来使用 D_test 进行训练呢？这样的话，我们也通过 D_train 更新了网络了，只是我们希望我们只需用极少的 step 训练 D_train 就能使 D_test 取得好的效果。\n所以，MAML 的核心步骤就是\n（1）采集 Task，得到 D_train 和 D_test\n（2）使用 D_train 对神经网络 f 训练少数几步，得到新的参数\n（3）利用新的参数训练 D_test，然后使得梯度下降更新一开始的参数。\n这里最不好理解的可能就是二次梯度了，也就是我们的目的还是要训练一开始的参数，只是中间我们要先计算梯度得到新的参数，然后用新的参数再算一次梯度，这样对于一开始的原始参数就要算两次梯度。这是 MAML 比较麻烦的地方，也可以认为是一种缺点。当然，现在使用 Pytorch 可以分分钟实现这种二次梯度的操作。\n可以说 MAML 还是非常巧妙的，一种不一样的方法，当然了已经被 Chelsea Finn 发扬光大了。\n5. 三种解决办法有什么优缺点呢？\n下面我们来谈谈三种办法的优缺点。先说 HyperNetwork 生成参数的做法。这种做法最大的问题就在于参数空间是很大的，所以要生成合适的参数特别是巨量的参数其实是比较困难的，所以目前绝大多数生成参数的做法都是只生成少量参数，比如一层的 MLP，或者对于参数的空间进行一定的限制，比如就在 [-1,1] 之间，否则空间太多，有无数种选择输出一样的结果，就很难训了。但是采样 HyperNetwork 又有其灵活性，意味着我们可以只更新少部分参数，而不用全部。\n接下来就是条件神经网络了。这又有什么问题呢？我觉得在性能上绝对会是最好的，很直接，但是不好看，一直要拖着一个条件，网络很大。不管是生成参数还是 MAML，他们的模型网络就是独立的，之后只要输入 x 就行了，而条件神经网络每次都要输入条件，很烦啊。\n那么 MAML 呢？可能最烦人的就是二次梯度了，这意味着 MAML 的训练会很慢，那么就很难 hold 住大网络了。实际上 MAML 目前对于大的网络结构比如 Resnet 效果并不好。然后 MAML 是使用 D_train 的 Loss 来更新整个网络，对比 HyperNetwork 缺少灵活性。这个 Loss 就是最好的吗？不见得。如果 D_train 是无监督数据，那怎么办？所以 MAML 是有局限性的。\n目前各种各样的 Meta Learning 研究，在方法论上都逃不出这三种方法。要么改改网络结构，要么结合一下上面的方法，比如先 MAML 再生成参数，或者 hypernetwork 和 conditional neural network 混着用等等。那么什么才是终极必杀呢？可能还是要具体问题具体看吧，对于不同的问题采用不同办法效果会不一样。这些都值得我们去探索。\n6. Meta Learning 的潜在威力！\n讲完了前面的方法论，相信大家对于 Meta Learning 已经有所了解了。但是大家肯定会疑问，难道 Meta Learning 只是在做 Few-Shot Learning 这种有点 boring 的任务吗？  \n当然不是。\n首先我们可以改成增强学习的 task，对于增强学习的 task，这里的 D_train 就是历史信息了:\n\n所谓的历史信息也就是之前的 transitions(state,action,reward,next_state)。把历史信息输入进去，原来的 reinforcement learning 就分分钟变成 meta reinforcement learning 啦。\n那么，Meta Learning 也仅仅止步于此吗？\n也当然不是！\n扩宽思维极限的时候到了！\n谁说 D_train 和 D_test 要一样呢！！！\n这才是 Meta Learning 最最重要的思想！一个 task 里面的训练集和测试集可以完全不一样。只要通过 D_test 的 loss signal 能够传递到 D_train 中，整个网络就可以端到端的训练。\n比如 D_train 可以是完全的无监督数据（没有标签），那么我们同样可以构造一个 hypernetwork 来更新我们的模型，然后用 D_test 有标签的数据来训练。这样训练完之后，我们就得到了一个能够无监督学习的 hypernetwork 了。\n实际上 D_train 和 D_test 的差异性可以进一步变大，训练可以是增强学习，测试可以是模仿学习，训练可以是语音，测试可以是图像，等等，会不会很有趣呢？\n最后，我们可以举一个更形象一点的 idea：比如有一个虚拟世界，里面可以生成虚拟人在里面生活，我们的 train 过程就是让这个虚拟人在里面爱干啥干啥，可以玩比如 1 年的游戏时间，然后我们的 test 过程要求这个虚拟人通过 200 的智商测试。那么通过巨量的虚拟 meta training 之后，我们就能得到一个这样的人工智能系统，这个虚拟人懂得自己去学习了，而我们还完全不知道他怎么学的。\nSo, this is \nMeta\nLearning!\nThe Future of AGI!\n","tags":["论文"]},{"title":"演示如何确定英特尔 ® 处理器的数量","url":"/2021/11/08/%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E8%8B%B1%E7%89%B9%E5%B0%94%20%C2%AE%20%E5%A4%84%E7%90%86%E5%99%A8/","content":"\n\n\nDocumentation\nContent Type Identify My Product\nArticle ID 000006059\nThere are different options to get the name and the number of the Intel® Processors. \nThe methods below apply on all Intel® processors such as Intel® Core™, Intel® Xeon®, Intel® Pentium®, Intel® Celeron®, and Intel Atom® processors. \nOption 1: Operating SystemWindows*\n Press on the Windows key  on your keyboard and start typing System, choose System Information which will show Processor information with the name, number, and speed of the processor.\nIf the Windows key is not available on your keyboard, using your mouse, go to the Windows icon located on the bottom-left corner of your screen, right-click, and choose System. Look up the processor’s name and number in the Processor information. The examples below show the case when choosing System Information and System.  \n\nLinux*Type the following command\nlscpu | grep “Model name”\nSee examples:\n\n\nMAC OSType the following command in the terminal app\nsysctl -a | grep machdep.cpu.brand_string\nSee an example:\n\nOption 2: Packaging BoxIf you bought an Intel® Boxed Processor, the information about the number of the processor along with other information like the batch number (FPO) and the serial number (ATPO) are listed on the packaging box.\n\nOption 3: Markings on the ProcessorsThe name and number of the Intel® Processor is listed on the top of the processor. See the example below.\n\nWatch this video to see how to identify your Intel® Processor name and number.\nIdentify the Generation for your Intel® Core™ Processors\nYou can also identify the generation of the processor if your processor is Intel® Core™. The generation of the processor is the first number after i9, i7, i5, or i3.\nHere are some examples:\n\n  Intel® Core™ Processor i7-10710U Processor is 10th generation because the number 10 is listed after i7.\n  Intel® Core™ Processor i9-9900 Processor is 9th generation because the number 9 is listed after i9.\n  Intel® Core™ Processor i7-9850H Processor is 9th generation because the number 9 is listed after i7.\n  Intel® Core™ Processor i5-8600 Processor is 8th generation because the number 8 is listed after i5.\n  Intel® Core™ Processor i3-7350K Processor is 7th generation because the number 7 is listed after i3.\n  Intel® Core™ Processor i5-6400T Processor is 6th generation because the number 6 is listed after i5.\n\n\nClose Window\n","tags":["VMware"]},{"title":"为松江医院开两台虚拟机","url":"/2021/05/02/simpread-%E4%B8%BA%E6%9D%BE%E6%B1%9F%E5%8C%BB%E9%99%A2%E5%BC%80%E9%80%9A%E4%B8%A4%E5%8F%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%20Windows%20Server%202016_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"需求：\n服务部署计划&nbsp;Windows 操作系统配置编号项目数量（台）操作系统说明&nbsp;1Zookeeper、ElasticSearch、分析服务、规则维护、前置审方（应用）1Windiws注册中心、应用等&nbsp;CPU：3.2GHz * 4 核以上内存：内存 32GB 及以上 ，DDR4 RDIMM硬盘：容量 500G 及以上，SAS 硬盘通讯端口：双端口千兆以太网2数据库集群1Windiws数据库服务&nbsp;合计2　　&nbsp;\n\n\n\n 图 3\n\n\n\n\n\n服务不可用，估计啥服务宕了。\n\n\n\n 查看 Vcenter 报错日志\n\n\n\n\n 只是网卡开通了 DHCP，但是网络中没有 DHCP 服务器。IP 目前为回环地址。\n\n\n\n网关：192.168.5.1(通常)，只要不练外网可以不写。 随便我的，也可以是 192.168.5.254.\n网关就是一个边界。\n\n\n注册中心和应用 \n\n\n开启远程桌面\n https://jingyan.baidu.com/article/154b463136661728ca8f4125.html\n或如下\n\n\n\n安装 VMware tools\n\n","tags":["VMware"]},{"title":"联想SR630服务器","url":"/2021/11/12/simpread-%E8%81%94%E6%83%B3%20SR630%20%E6%9C%8D%E5%8A%A1%E5%99%A8_Yixin%20%E7%9A%84%E5%8D%9A%E5%AE%A2%20-%20CSDN%20%E5%8D%9A%E5%AE%A2/","content":"\n \n \n \n \n \n \n\n","tags":["服务器"]}]